// This file was generated by gir (a4dcfea) from gir-files (???)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals)]

extern crate libc;
#[macro_use] extern crate bitflags;
extern crate glib_sys as glib;
extern crate gobject_sys as gobject;
extern crate gstreamer_sys as gst;
extern crate gstreamer_base_sys as gst_base;
extern crate gstreamer_tag_sys as gst_tag;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType, Volatile};

// Enums
extern "C" {
    pub fn gst_audio_base_sink_discont_reason_get_type() -> GType;
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstAudioBaseSinkDiscontReason {
    NoDiscont = 0,
    NewCaps = 1,
    Flush = 2,
    SyncLatency = 3,
    Alignment = 4,
    DeviceFailure = 5,
}
pub const GST_AUDIO_BASE_SINK_DISCONT_REASON_NO_DISCONT: GstAudioBaseSinkDiscontReason = GstAudioBaseSinkDiscontReason::NoDiscont;
pub const GST_AUDIO_BASE_SINK_DISCONT_REASON_NEW_CAPS: GstAudioBaseSinkDiscontReason = GstAudioBaseSinkDiscontReason::NewCaps;
pub const GST_AUDIO_BASE_SINK_DISCONT_REASON_FLUSH: GstAudioBaseSinkDiscontReason = GstAudioBaseSinkDiscontReason::Flush;
pub const GST_AUDIO_BASE_SINK_DISCONT_REASON_SYNC_LATENCY: GstAudioBaseSinkDiscontReason = GstAudioBaseSinkDiscontReason::SyncLatency;
pub const GST_AUDIO_BASE_SINK_DISCONT_REASON_ALIGNMENT: GstAudioBaseSinkDiscontReason = GstAudioBaseSinkDiscontReason::Alignment;
pub const GST_AUDIO_BASE_SINK_DISCONT_REASON_DEVICE_FAILURE: GstAudioBaseSinkDiscontReason = GstAudioBaseSinkDiscontReason::DeviceFailure;

extern "C" {
    pub fn gst_audio_base_sink_slave_method_get_type() -> GType;
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstAudioBaseSinkSlaveMethod {
    Resample = 0,
    Skew = 1,
    None = 2,
    Custom = 3,
}
pub const GST_AUDIO_BASE_SINK_SLAVE_RESAMPLE: GstAudioBaseSinkSlaveMethod = GstAudioBaseSinkSlaveMethod::Resample;
pub const GST_AUDIO_BASE_SINK_SLAVE_SKEW: GstAudioBaseSinkSlaveMethod = GstAudioBaseSinkSlaveMethod::Skew;
pub const GST_AUDIO_BASE_SINK_SLAVE_NONE: GstAudioBaseSinkSlaveMethod = GstAudioBaseSinkSlaveMethod::None;
pub const GST_AUDIO_BASE_SINK_SLAVE_CUSTOM: GstAudioBaseSinkSlaveMethod = GstAudioBaseSinkSlaveMethod::Custom;

extern "C" {
    pub fn gst_audio_base_src_slave_method_get_type() -> GType;
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstAudioBaseSrcSlaveMethod {
    Resample = 0,
    ReTimestamp = 1,
    Skew = 2,
    None = 3,
}
pub const GST_AUDIO_BASE_SRC_SLAVE_RESAMPLE: GstAudioBaseSrcSlaveMethod = GstAudioBaseSrcSlaveMethod::Resample;
pub const GST_AUDIO_BASE_SRC_SLAVE_RE_TIMESTAMP: GstAudioBaseSrcSlaveMethod = GstAudioBaseSrcSlaveMethod::ReTimestamp;
pub const GST_AUDIO_BASE_SRC_SLAVE_SKEW: GstAudioBaseSrcSlaveMethod = GstAudioBaseSrcSlaveMethod::Skew;
pub const GST_AUDIO_BASE_SRC_SLAVE_NONE: GstAudioBaseSrcSlaveMethod = GstAudioBaseSrcSlaveMethod::None;

extern "C" {
    pub fn gst_audio_cd_src_mode_get_type() -> GType;
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstAudioCdSrcMode {
    Normal = 0,
    Continuous = 1,
}
pub const GST_AUDIO_CD_SRC_MODE_NORMAL: GstAudioCdSrcMode = GstAudioCdSrcMode::Normal;
pub const GST_AUDIO_CD_SRC_MODE_CONTINUOUS: GstAudioCdSrcMode = GstAudioCdSrcMode::Continuous;

extern "C" {
    pub fn gst_audio_channel_position_get_type() -> GType;
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstAudioChannelPosition {
    None = -3,
    Mono = -2,
    Invalid = -1,
    FrontLeft = 0,
    FrontRight = 1,
    FrontCenter = 2,
    Lfe1 = 3,
    RearLeft = 4,
    RearRight = 5,
    FrontLeftOfCenter = 6,
    FrontRightOfCenter = 7,
    RearCenter = 8,
    Lfe2 = 9,
    SideLeft = 10,
    SideRight = 11,
    TopFrontLeft = 12,
    TopFrontRight = 13,
    TopFrontCenter = 14,
    TopCenter = 15,
    TopRearLeft = 16,
    TopRearRight = 17,
    TopSideLeft = 18,
    TopSideRight = 19,
    TopRearCenter = 20,
    BottomFrontCenter = 21,
    BottomFrontLeft = 22,
    BottomFrontRight = 23,
    WideLeft = 24,
    WideRight = 25,
    SurroundLeft = 26,
    SurroundRight = 27,
}
pub const GST_AUDIO_CHANNEL_POSITION_NONE: GstAudioChannelPosition = GstAudioChannelPosition::None;
pub const GST_AUDIO_CHANNEL_POSITION_MONO: GstAudioChannelPosition = GstAudioChannelPosition::Mono;
pub const GST_AUDIO_CHANNEL_POSITION_INVALID: GstAudioChannelPosition = GstAudioChannelPosition::Invalid;
pub const GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT: GstAudioChannelPosition = GstAudioChannelPosition::FrontLeft;
pub const GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT: GstAudioChannelPosition = GstAudioChannelPosition::FrontRight;
pub const GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER: GstAudioChannelPosition = GstAudioChannelPosition::FrontCenter;
pub const GST_AUDIO_CHANNEL_POSITION_LFE1: GstAudioChannelPosition = GstAudioChannelPosition::Lfe1;
pub const GST_AUDIO_CHANNEL_POSITION_REAR_LEFT: GstAudioChannelPosition = GstAudioChannelPosition::RearLeft;
pub const GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT: GstAudioChannelPosition = GstAudioChannelPosition::RearRight;
pub const GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER: GstAudioChannelPosition = GstAudioChannelPosition::FrontLeftOfCenter;
pub const GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER: GstAudioChannelPosition = GstAudioChannelPosition::FrontRightOfCenter;
pub const GST_AUDIO_CHANNEL_POSITION_REAR_CENTER: GstAudioChannelPosition = GstAudioChannelPosition::RearCenter;
pub const GST_AUDIO_CHANNEL_POSITION_LFE2: GstAudioChannelPosition = GstAudioChannelPosition::Lfe2;
pub const GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT: GstAudioChannelPosition = GstAudioChannelPosition::SideLeft;
pub const GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT: GstAudioChannelPosition = GstAudioChannelPosition::SideRight;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT: GstAudioChannelPosition = GstAudioChannelPosition::TopFrontLeft;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT: GstAudioChannelPosition = GstAudioChannelPosition::TopFrontRight;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER: GstAudioChannelPosition = GstAudioChannelPosition::TopFrontCenter;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_CENTER: GstAudioChannelPosition = GstAudioChannelPosition::TopCenter;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT: GstAudioChannelPosition = GstAudioChannelPosition::TopRearLeft;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT: GstAudioChannelPosition = GstAudioChannelPosition::TopRearRight;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_LEFT: GstAudioChannelPosition = GstAudioChannelPosition::TopSideLeft;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_RIGHT: GstAudioChannelPosition = GstAudioChannelPosition::TopSideRight;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_REAR_CENTER: GstAudioChannelPosition = GstAudioChannelPosition::TopRearCenter;
pub const GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_CENTER: GstAudioChannelPosition = GstAudioChannelPosition::BottomFrontCenter;
pub const GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_LEFT: GstAudioChannelPosition = GstAudioChannelPosition::BottomFrontLeft;
pub const GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_RIGHT: GstAudioChannelPosition = GstAudioChannelPosition::BottomFrontRight;
pub const GST_AUDIO_CHANNEL_POSITION_WIDE_LEFT: GstAudioChannelPosition = GstAudioChannelPosition::WideLeft;
pub const GST_AUDIO_CHANNEL_POSITION_WIDE_RIGHT: GstAudioChannelPosition = GstAudioChannelPosition::WideRight;
pub const GST_AUDIO_CHANNEL_POSITION_SURROUND_LEFT: GstAudioChannelPosition = GstAudioChannelPosition::SurroundLeft;
pub const GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT: GstAudioChannelPosition = GstAudioChannelPosition::SurroundRight;

extern "C" {
    pub fn gst_audio_dither_method_get_type() -> GType;
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstAudioDitherMethod {
    None = 0,
    Rpdf = 1,
    Tpdf = 2,
    TpdfHf = 3,
}
pub const GST_AUDIO_DITHER_NONE: GstAudioDitherMethod = GstAudioDitherMethod::None;
pub const GST_AUDIO_DITHER_RPDF: GstAudioDitherMethod = GstAudioDitherMethod::Rpdf;
pub const GST_AUDIO_DITHER_TPDF: GstAudioDitherMethod = GstAudioDitherMethod::Tpdf;
pub const GST_AUDIO_DITHER_TPDF_HF: GstAudioDitherMethod = GstAudioDitherMethod::TpdfHf;

extern "C" {
    pub fn gst_audio_format_get_type() -> GType;
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstAudioFormat {
    Unknown = 0,
    Encoded = 1,
    S8 = 2,
    U8 = 3,
    S16le = 4,
    S16be = 5,
    U16le = 6,
    U16be = 7,
    S2432le = 8,
    S2432be = 9,
    U2432le = 10,
    U2432be = 11,
    S32le = 12,
    S32be = 13,
    U32le = 14,
    U32be = 15,
    S24le = 16,
    S24be = 17,
    U24le = 18,
    U24be = 19,
    S20le = 20,
    S20be = 21,
    U20le = 22,
    U20be = 23,
    S18le = 24,
    S18be = 25,
    U18le = 26,
    U18be = 27,
    F32le = 28,
    F32be = 29,
    F64le = 30,
    F64be = 31,
}
pub const GST_AUDIO_FORMAT_UNKNOWN: GstAudioFormat = GstAudioFormat::Unknown;
pub const GST_AUDIO_FORMAT_ENCODED: GstAudioFormat = GstAudioFormat::Encoded;
pub const GST_AUDIO_FORMAT_S8: GstAudioFormat = GstAudioFormat::S8;
pub const GST_AUDIO_FORMAT_U8: GstAudioFormat = GstAudioFormat::U8;
pub const GST_AUDIO_FORMAT_S16LE: GstAudioFormat = GstAudioFormat::S16le;
pub const GST_AUDIO_FORMAT_S16BE: GstAudioFormat = GstAudioFormat::S16be;
pub const GST_AUDIO_FORMAT_U16LE: GstAudioFormat = GstAudioFormat::U16le;
pub const GST_AUDIO_FORMAT_U16BE: GstAudioFormat = GstAudioFormat::U16be;
pub const GST_AUDIO_FORMAT_S24_32LE: GstAudioFormat = GstAudioFormat::S2432le;
pub const GST_AUDIO_FORMAT_S24_32BE: GstAudioFormat = GstAudioFormat::S2432be;
pub const GST_AUDIO_FORMAT_U24_32LE: GstAudioFormat = GstAudioFormat::U2432le;
pub const GST_AUDIO_FORMAT_U24_32BE: GstAudioFormat = GstAudioFormat::U2432be;
pub const GST_AUDIO_FORMAT_S32LE: GstAudioFormat = GstAudioFormat::S32le;
pub const GST_AUDIO_FORMAT_S32BE: GstAudioFormat = GstAudioFormat::S32be;
pub const GST_AUDIO_FORMAT_U32LE: GstAudioFormat = GstAudioFormat::U32le;
pub const GST_AUDIO_FORMAT_U32BE: GstAudioFormat = GstAudioFormat::U32be;
pub const GST_AUDIO_FORMAT_S24LE: GstAudioFormat = GstAudioFormat::S24le;
pub const GST_AUDIO_FORMAT_S24BE: GstAudioFormat = GstAudioFormat::S24be;
pub const GST_AUDIO_FORMAT_U24LE: GstAudioFormat = GstAudioFormat::U24le;
pub const GST_AUDIO_FORMAT_U24BE: GstAudioFormat = GstAudioFormat::U24be;
pub const GST_AUDIO_FORMAT_S20LE: GstAudioFormat = GstAudioFormat::S20le;
pub const GST_AUDIO_FORMAT_S20BE: GstAudioFormat = GstAudioFormat::S20be;
pub const GST_AUDIO_FORMAT_U20LE: GstAudioFormat = GstAudioFormat::U20le;
pub const GST_AUDIO_FORMAT_U20BE: GstAudioFormat = GstAudioFormat::U20be;
pub const GST_AUDIO_FORMAT_S18LE: GstAudioFormat = GstAudioFormat::S18le;
pub const GST_AUDIO_FORMAT_S18BE: GstAudioFormat = GstAudioFormat::S18be;
pub const GST_AUDIO_FORMAT_U18LE: GstAudioFormat = GstAudioFormat::U18le;
pub const GST_AUDIO_FORMAT_U18BE: GstAudioFormat = GstAudioFormat::U18be;
pub const GST_AUDIO_FORMAT_F32LE: GstAudioFormat = GstAudioFormat::F32le;
pub const GST_AUDIO_FORMAT_F32BE: GstAudioFormat = GstAudioFormat::F32be;
pub const GST_AUDIO_FORMAT_F64LE: GstAudioFormat = GstAudioFormat::F64le;
pub const GST_AUDIO_FORMAT_F64BE: GstAudioFormat = GstAudioFormat::F64be;
pub const GST_AUDIO_FORMAT_S16: GstAudioFormat = GstAudioFormat::S16le;
pub const GST_AUDIO_FORMAT_U16: GstAudioFormat = GstAudioFormat::U16le;
pub const GST_AUDIO_FORMAT_S24_32: GstAudioFormat = GstAudioFormat::S2432le;
pub const GST_AUDIO_FORMAT_U24_32: GstAudioFormat = GstAudioFormat::U2432le;
pub const GST_AUDIO_FORMAT_S32: GstAudioFormat = GstAudioFormat::S32le;
pub const GST_AUDIO_FORMAT_U32: GstAudioFormat = GstAudioFormat::U32le;
pub const GST_AUDIO_FORMAT_S24: GstAudioFormat = GstAudioFormat::S24le;
pub const GST_AUDIO_FORMAT_U24: GstAudioFormat = GstAudioFormat::U24le;
pub const GST_AUDIO_FORMAT_S20: GstAudioFormat = GstAudioFormat::S20le;
pub const GST_AUDIO_FORMAT_U20: GstAudioFormat = GstAudioFormat::U20le;
pub const GST_AUDIO_FORMAT_S18: GstAudioFormat = GstAudioFormat::S18le;
pub const GST_AUDIO_FORMAT_U18: GstAudioFormat = GstAudioFormat::U18le;
pub const GST_AUDIO_FORMAT_F32: GstAudioFormat = GstAudioFormat::F32le;
pub const GST_AUDIO_FORMAT_F64: GstAudioFormat = GstAudioFormat::F64le;

extern "C" {
    pub fn gst_audio_layout_get_type() -> GType;
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstAudioLayout {
    Interleaved = 0,
    NonInterleaved = 1,
}
pub const GST_AUDIO_LAYOUT_INTERLEAVED: GstAudioLayout = GstAudioLayout::Interleaved;
pub const GST_AUDIO_LAYOUT_NON_INTERLEAVED: GstAudioLayout = GstAudioLayout::NonInterleaved;

extern "C" {
    pub fn gst_audio_noise_shaping_method_get_type() -> GType;
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstAudioNoiseShapingMethod {
    None = 0,
    ErrorFeedback = 1,
    Simple = 2,
    Medium = 3,
    High = 4,
}
pub const GST_AUDIO_NOISE_SHAPING_NONE: GstAudioNoiseShapingMethod = GstAudioNoiseShapingMethod::None;
pub const GST_AUDIO_NOISE_SHAPING_ERROR_FEEDBACK: GstAudioNoiseShapingMethod = GstAudioNoiseShapingMethod::ErrorFeedback;
pub const GST_AUDIO_NOISE_SHAPING_SIMPLE: GstAudioNoiseShapingMethod = GstAudioNoiseShapingMethod::Simple;
pub const GST_AUDIO_NOISE_SHAPING_MEDIUM: GstAudioNoiseShapingMethod = GstAudioNoiseShapingMethod::Medium;
pub const GST_AUDIO_NOISE_SHAPING_HIGH: GstAudioNoiseShapingMethod = GstAudioNoiseShapingMethod::High;

extern "C" {
    pub fn gst_audio_resampler_filter_interpolation_get_type() -> GType;
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstAudioResamplerFilterInterpolation {
    None = 0,
    Linear = 1,
    Cubic = 2,
}
pub const GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_NONE: GstAudioResamplerFilterInterpolation = GstAudioResamplerFilterInterpolation::None;
pub const GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_LINEAR: GstAudioResamplerFilterInterpolation = GstAudioResamplerFilterInterpolation::Linear;
pub const GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_CUBIC: GstAudioResamplerFilterInterpolation = GstAudioResamplerFilterInterpolation::Cubic;

extern "C" {
    pub fn gst_audio_resampler_filter_mode_get_type() -> GType;
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstAudioResamplerFilterMode {
    Interpolated = 0,
    Full = 1,
    Auto = 2,
}
pub const GST_AUDIO_RESAMPLER_FILTER_MODE_INTERPOLATED: GstAudioResamplerFilterMode = GstAudioResamplerFilterMode::Interpolated;
pub const GST_AUDIO_RESAMPLER_FILTER_MODE_FULL: GstAudioResamplerFilterMode = GstAudioResamplerFilterMode::Full;
pub const GST_AUDIO_RESAMPLER_FILTER_MODE_AUTO: GstAudioResamplerFilterMode = GstAudioResamplerFilterMode::Auto;

extern "C" {
    pub fn gst_audio_resampler_method_get_type() -> GType;
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstAudioResamplerMethod {
    Nearest = 0,
    Linear = 1,
    Cubic = 2,
    BlackmanNuttall = 3,
    Kaiser = 4,
}
pub const GST_AUDIO_RESAMPLER_METHOD_NEAREST: GstAudioResamplerMethod = GstAudioResamplerMethod::Nearest;
pub const GST_AUDIO_RESAMPLER_METHOD_LINEAR: GstAudioResamplerMethod = GstAudioResamplerMethod::Linear;
pub const GST_AUDIO_RESAMPLER_METHOD_CUBIC: GstAudioResamplerMethod = GstAudioResamplerMethod::Cubic;
pub const GST_AUDIO_RESAMPLER_METHOD_BLACKMAN_NUTTALL: GstAudioResamplerMethod = GstAudioResamplerMethod::BlackmanNuttall;
pub const GST_AUDIO_RESAMPLER_METHOD_KAISER: GstAudioResamplerMethod = GstAudioResamplerMethod::Kaiser;

extern "C" {
    pub fn gst_audio_ring_buffer_format_type_get_type() -> GType;
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstAudioRingBufferFormatType {
    Raw = 0,
    MuLaw = 1,
    ALaw = 2,
    ImaAdpcm = 3,
    Mpeg = 4,
    Gsm = 5,
    Iec958 = 6,
    Ac3 = 7,
    Eac3 = 8,
    Dts = 9,
    Mpeg2Aac = 10,
    Mpeg4Aac = 11,
    Mpeg2AacRaw = 12,
    Mpeg4AacRaw = 13,
    Flac = 14,
}
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW: GstAudioRingBufferFormatType = GstAudioRingBufferFormatType::Raw;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MU_LAW: GstAudioRingBufferFormatType = GstAudioRingBufferFormatType::MuLaw;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_A_LAW: GstAudioRingBufferFormatType = GstAudioRingBufferFormatType::ALaw;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IMA_ADPCM: GstAudioRingBufferFormatType = GstAudioRingBufferFormatType::ImaAdpcm;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG: GstAudioRingBufferFormatType = GstAudioRingBufferFormatType::Mpeg;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_GSM: GstAudioRingBufferFormatType = GstAudioRingBufferFormatType::Gsm;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IEC958: GstAudioRingBufferFormatType = GstAudioRingBufferFormatType::Iec958;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_AC3: GstAudioRingBufferFormatType = GstAudioRingBufferFormatType::Ac3;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_EAC3: GstAudioRingBufferFormatType = GstAudioRingBufferFormatType::Eac3;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DTS: GstAudioRingBufferFormatType = GstAudioRingBufferFormatType::Dts;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC: GstAudioRingBufferFormatType = GstAudioRingBufferFormatType::Mpeg2Aac;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC: GstAudioRingBufferFormatType = GstAudioRingBufferFormatType::Mpeg4Aac;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC_RAW: GstAudioRingBufferFormatType = GstAudioRingBufferFormatType::Mpeg2AacRaw;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC_RAW: GstAudioRingBufferFormatType = GstAudioRingBufferFormatType::Mpeg4AacRaw;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_FLAC: GstAudioRingBufferFormatType = GstAudioRingBufferFormatType::Flac;

extern "C" {
    pub fn gst_audio_ring_buffer_state_get_type() -> GType;
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstAudioRingBufferState {
    Stopped = 0,
    Paused = 1,
    Started = 2,
    Error = 3,
}
pub const GST_AUDIO_RING_BUFFER_STATE_STOPPED: GstAudioRingBufferState = GstAudioRingBufferState::Stopped;
pub const GST_AUDIO_RING_BUFFER_STATE_PAUSED: GstAudioRingBufferState = GstAudioRingBufferState::Paused;
pub const GST_AUDIO_RING_BUFFER_STATE_STARTED: GstAudioRingBufferState = GstAudioRingBufferState::Started;
pub const GST_AUDIO_RING_BUFFER_STATE_ERROR: GstAudioRingBufferState = GstAudioRingBufferState::Error;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstStreamVolumeFormat {
    Linear = 0,
    Cubic = 1,
    Db = 2,
}
pub const GST_STREAM_VOLUME_FORMAT_LINEAR: GstStreamVolumeFormat = GstStreamVolumeFormat::Linear;
pub const GST_STREAM_VOLUME_FORMAT_CUBIC: GstStreamVolumeFormat = GstStreamVolumeFormat::Cubic;
pub const GST_STREAM_VOLUME_FORMAT_DB: GstStreamVolumeFormat = GstStreamVolumeFormat::Db;

// Constants
pub const GST_AUDIO_CHANNELS_RANGE: *const c_char = b"(int) [ 1, max ]\0" as *const u8 as *const c_char;
pub const GST_AUDIO_CONVERTER_OPT_DITHER_METHOD: *const c_char = b"GstAudioConverter.dither-method\0" as *const u8 as *const c_char;
pub const GST_AUDIO_CONVERTER_OPT_NOISE_SHAPING_METHOD: *const c_char = b"GstAudioConverter.noise-shaping-method\0" as *const u8 as *const c_char;
pub const GST_AUDIO_CONVERTER_OPT_QUANTIZATION: *const c_char = b"GstAudioConverter.quantization\0" as *const u8 as *const c_char;
pub const GST_AUDIO_CONVERTER_OPT_RESAMPLER_METHOD: *const c_char = b"GstAudioConverter.resampler-method\0" as *const u8 as *const c_char;
pub const GST_AUDIO_DECODER_MAX_ERRORS: c_int = 10;
pub const GST_AUDIO_DECODER_SINK_NAME: *const c_char = b"sink\0" as *const u8 as *const c_char;
pub const GST_AUDIO_DECODER_SRC_NAME: *const c_char = b"src\0" as *const u8 as *const c_char;
pub const GST_AUDIO_DEF_CHANNELS: c_int = 2;
pub const GST_AUDIO_DEF_FORMAT: *const c_char = b"S16LE\0" as *const u8 as *const c_char;
pub const GST_AUDIO_DEF_RATE: c_int = 44100;
pub const GST_AUDIO_ENCODER_SINK_NAME: *const c_char = b"sink\0" as *const u8 as *const c_char;
pub const GST_AUDIO_ENCODER_SRC_NAME: *const c_char = b"src\0" as *const u8 as *const c_char;
pub const GST_AUDIO_FORMATS_ALL: *const c_char = b" { S8, U8, S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE }\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RATE_RANGE: *const c_char = b"(int) [ 1, max ]\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_CUBIC_B: *const c_char = b"GstAudioResampler.cubic-b\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_CUBIC_C: *const c_char = b"GstAudioResampler.cubic-c\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_CUTOFF: *const c_char = b"GstAudioResampler.cutoff\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_FILTER_INTERPOLATION: *const c_char = b"GstAudioResampler.filter-interpolation\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_FILTER_MODE: *const c_char = b"GstAudioResampler.filter-mode\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_FILTER_MODE_THRESHOLD: *const c_char = b"GstAudioResampler.filter-mode-threshold\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_FILTER_OVERSAMPLE: *const c_char = b"GstAudioResampler.filter-oversample\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_MAX_PHASE_ERROR: *const c_char = b"GstAudioResampler.max-phase-error\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_N_TAPS: *const c_char = b"GstAudioResampler.n-taps\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_STOP_ATTENUATION: *const c_char = b"GstAudioResampler.stop-attenutation\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_OPT_TRANSITION_BANDWIDTH: *const c_char = b"GstAudioResampler.transition-bandwidth\0" as *const u8 as *const c_char;
pub const GST_AUDIO_RESAMPLER_QUALITY_DEFAULT: c_int = 4;
pub const GST_AUDIO_RESAMPLER_QUALITY_MAX: c_int = 10;
pub const GST_AUDIO_RESAMPLER_QUALITY_MIN: c_int = 0;
pub const GST_META_TAG_AUDIO_CHANNELS_STR: *const c_char = b"channels\0" as *const u8 as *const c_char;
pub const GST_META_TAG_AUDIO_RATE_STR: *const c_char = b"rate\0" as *const u8 as *const c_char;
pub const GST_META_TAG_AUDIO_STR: *const c_char = b"audio\0" as *const u8 as *const c_char;

// Flags
extern "C" {
    pub fn gst_audio_channel_mixer_flags_get_type() -> GType;
}

bitflags! {
    #[repr(C)]
    pub struct GstAudioChannelMixerFlags: c_uint {
        const GST_AUDIO_CHANNEL_MIXER_FLAGS_NONE = 0;
        const GST_AUDIO_CHANNEL_MIXER_FLAGS_NON_INTERLEAVED_IN = 1;
        const GST_AUDIO_CHANNEL_MIXER_FLAGS_NON_INTERLEAVED_OUT = 2;
        const GST_AUDIO_CHANNEL_MIXER_FLAGS_UNPOSITIONED_IN = 4;
        const GST_AUDIO_CHANNEL_MIXER_FLAGS_UNPOSITIONED_OUT = 8;
    }
}

extern "C" {
    pub fn gst_audio_converter_flags_get_type() -> GType;
}

bitflags! {
    #[repr(C)]
    pub struct GstAudioConverterFlags: c_uint {
        const GST_AUDIO_CONVERTER_FLAG_NONE = 0;
        const GST_AUDIO_CONVERTER_FLAG_IN_WRITABLE = 1;
        const GST_AUDIO_CONVERTER_FLAG_VARIABLE_RATE = 2;
    }
}

extern "C" {
    pub fn gst_audio_flags_get_type() -> GType;
}

bitflags! {
    #[repr(C)]
    pub struct GstAudioFlags: c_uint {
        const GST_AUDIO_FLAG_NONE = 0;
        const GST_AUDIO_FLAG_UNPOSITIONED = 1;
    }
}

extern "C" {
    pub fn gst_audio_format_flags_get_type() -> GType;
}

bitflags! {
    #[repr(C)]
    pub struct GstAudioFormatFlags: c_uint {
        const GST_AUDIO_FORMAT_FLAG_INTEGER = 1;
        const GST_AUDIO_FORMAT_FLAG_FLOAT = 2;
        const GST_AUDIO_FORMAT_FLAG_SIGNED = 4;
        const GST_AUDIO_FORMAT_FLAG_COMPLEX = 16;
        const GST_AUDIO_FORMAT_FLAG_UNPACK = 32;
    }
}

extern "C" {
    pub fn gst_audio_pack_flags_get_type() -> GType;
}

bitflags! {
    #[repr(C)]
    pub struct GstAudioPackFlags: c_uint {
        const GST_AUDIO_PACK_FLAG_NONE = 0;
        const GST_AUDIO_PACK_FLAG_TRUNCATE_RANGE = 1;
    }
}

extern "C" {
    pub fn gst_audio_quantize_flags_get_type() -> GType;
}

bitflags! {
    #[repr(C)]
    pub struct GstAudioQuantizeFlags: c_uint {
        const GST_AUDIO_QUANTIZE_FLAG_NONE = 0;
        const GST_AUDIO_QUANTIZE_FLAG_NON_INTERLEAVED = 1;
    }
}

extern "C" {
    pub fn gst_audio_resampler_flags_get_type() -> GType;
}

bitflags! {
    #[repr(C)]
    pub struct GstAudioResamplerFlags: c_uint {
        const GST_AUDIO_RESAMPLER_FLAG_NONE = 0;
        const GST_AUDIO_RESAMPLER_FLAG_NON_INTERLEAVED_IN = 1;
        const GST_AUDIO_RESAMPLER_FLAG_NON_INTERLEAVED_OUT = 2;
        const GST_AUDIO_RESAMPLER_FLAG_VARIABLE_RATE = 4;
    }
}

// Callbacks
pub type GstAudioBaseSinkCustomSlavingCallback = Option<unsafe extern "C" fn(*mut GstAudioBaseSink, gst::GstClockTime, gst::GstClockTime, *mut gst::GstClockTimeDiff, GstAudioBaseSinkDiscontReason, gpointer)>;
pub type GstAudioClockGetTimeFunc = Option<unsafe extern "C" fn(*mut gst::GstClock, gpointer) -> gst::GstClockTime>;
pub type GstAudioFormatPack = Option<unsafe extern "C" fn(*const GstAudioFormatInfo, GstAudioPackFlags, gpointer, gpointer, c_int)>;
pub type GstAudioFormatUnpack = Option<unsafe extern "C" fn(*const GstAudioFormatInfo, GstAudioPackFlags, gpointer, gpointer, c_int)>;
pub type GstAudioRingBufferCallback = Option<unsafe extern "C" fn(*mut GstAudioRingBuffer, *mut u8, c_uint, gpointer)>;

// Records
#[repr(C)]
pub struct GstAudioBaseSinkClass {
    pub parent_class: gst_base::GstBaseSinkClass,
    pub create_ringbuffer: Option<unsafe extern "C" fn(*mut GstAudioBaseSink) -> *mut GstAudioRingBuffer>,
    pub payload: Option<unsafe extern "C" fn(*mut GstAudioBaseSink, *mut gst::GstBuffer) -> *mut gst::GstBuffer>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAudioBaseSinkPrivate(c_void);

#[repr(C)]
pub struct GstAudioBaseSrcClass {
    pub parent_class: gst_base::GstPushSrcClass,
    pub create_ringbuffer: Option<unsafe extern "C" fn(*mut GstAudioBaseSrc) -> *mut GstAudioRingBuffer>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAudioBaseSrcPrivate(c_void);

#[repr(C)]
pub struct GstAudioCdSrcClass {
    pub pushsrc_class: gst_base::GstPushSrcClass,
    pub open: Option<unsafe extern "C" fn(*mut GstAudioCdSrc, *const c_char) -> gboolean>,
    pub close: Option<unsafe extern "C" fn(*mut GstAudioCdSrc)>,
    pub read_sector: Option<unsafe extern "C" fn(*mut GstAudioCdSrc, c_int) -> *mut gst::GstBuffer>,
    pub _gst_reserved: [gpointer; 20],
}

#[repr(C)]
pub struct GstAudioCdSrcPrivate(c_void);

#[repr(C)]
pub struct GstAudioCdSrcTrack {
    pub is_audio: gboolean,
    pub num: c_uint,
    pub start: c_uint,
    pub end: c_uint,
    pub tags: *mut gst::GstTagList,
    pub _gst_reserved1: [c_uint; 2],
    pub _gst_reserved2: [gpointer; 2],
}

#[repr(C)]
pub struct GstAudioChannelMixer(c_void);

#[repr(C)]
pub struct GstAudioClippingMeta {
    pub meta: gst::GstMeta,
    pub format: gst::GstFormat,
    pub start: u64,
    pub end: u64,
}

#[repr(C)]
pub struct GstAudioClockClass {
    pub parent_class: gst::GstSystemClockClass,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAudioConverter(c_void);

#[repr(C)]
pub struct GstAudioDecoderClass {
    pub element_class: gst::GstElementClass,
    pub start: Option<unsafe extern "C" fn(*mut GstAudioDecoder) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstAudioDecoder) -> gboolean>,
    pub set_format: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstCaps) -> gboolean>,
    pub parse: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst_base::GstAdapter, *mut c_int, *mut c_int) -> gst::GstFlowReturn>,
    pub handle_frame: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub flush: Option<unsafe extern "C" fn(*mut GstAudioDecoder, gboolean)>,
    pub pre_push: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub sink_event: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstEvent) -> gboolean>,
    pub src_event: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstEvent) -> gboolean>,
    pub open: Option<unsafe extern "C" fn(*mut GstAudioDecoder) -> gboolean>,
    pub close: Option<unsafe extern "C" fn(*mut GstAudioDecoder) -> gboolean>,
    pub negotiate: Option<unsafe extern "C" fn(*mut GstAudioDecoder) -> gboolean>,
    pub decide_allocation: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstQuery) -> gboolean>,
    pub propose_allocation: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstQuery) -> gboolean>,
    pub sink_query: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstQuery) -> gboolean>,
    pub src_query: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstQuery) -> gboolean>,
    pub getcaps: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstCaps) -> *mut gst::GstCaps>,
    pub transform_meta: Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstBuffer, *mut gst::GstMeta, *mut gst::GstBuffer) -> gboolean>,
    pub _gst_reserved: [gpointer; 16],
}

#[repr(C)]
pub struct GstAudioDecoderPrivate(c_void);

#[repr(C)]
pub struct GstAudioDownmixMeta {
    pub meta: gst::GstMeta,
    pub from_position: *mut GstAudioChannelPosition,
    pub to_position: *mut GstAudioChannelPosition,
    pub from_channels: c_int,
    pub to_channels: c_int,
    pub matrix: *mut *mut c_float,
}

#[repr(C)]
pub struct GstAudioEncoderClass {
    pub element_class: gst::GstElementClass,
    pub start: Option<unsafe extern "C" fn(*mut GstAudioEncoder) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstAudioEncoder) -> gboolean>,
    pub set_format: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut GstAudioInfo) -> gboolean>,
    pub handle_frame: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub flush: Option<unsafe extern "C" fn(*mut GstAudioEncoder)>,
    pub pre_push: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub sink_event: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstEvent) -> gboolean>,
    pub src_event: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstEvent) -> gboolean>,
    pub getcaps: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstCaps) -> *mut gst::GstCaps>,
    pub open: Option<unsafe extern "C" fn(*mut GstAudioEncoder) -> gboolean>,
    pub close: Option<unsafe extern "C" fn(*mut GstAudioEncoder) -> gboolean>,
    pub negotiate: Option<unsafe extern "C" fn(*mut GstAudioEncoder) -> gboolean>,
    pub decide_allocation: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstQuery) -> gboolean>,
    pub propose_allocation: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstQuery) -> gboolean>,
    pub transform_meta: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstBuffer, *mut gst::GstMeta, *mut gst::GstBuffer) -> gboolean>,
    pub sink_query: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstQuery) -> gboolean>,
    pub src_query: Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstQuery) -> gboolean>,
    pub _gst_reserved: [gpointer; 17],
}

#[repr(C)]
pub struct GstAudioEncoderPrivate(c_void);

#[repr(C)]
pub struct GstAudioFilterClass {
    pub basetransformclass: gst_base::GstBaseTransformClass,
    pub setup: Option<unsafe extern "C" fn(*mut GstAudioFilter, *const GstAudioInfo) -> gboolean>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAudioFormatInfo {
    pub format: GstAudioFormat,
    pub name: *const c_char,
    pub description: *const c_char,
    pub flags: GstAudioFormatFlags,
    pub endianness: c_int,
    pub width: c_int,
    pub depth: c_int,
    pub silence: [u8; 8],
    pub unpack_format: GstAudioFormat,
    pub unpack_func: GstAudioFormatUnpack,
    pub pack_func: GstAudioFormatPack,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAudioInfo {
    pub finfo: *const GstAudioFormatInfo,
    pub flags: GstAudioFlags,
    pub layout: GstAudioLayout,
    pub rate: c_int,
    pub channels: c_int,
    pub bpf: c_int,
    pub position: [GstAudioChannelPosition; 64],
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAudioQuantize(c_void);

#[repr(C)]
pub struct GstAudioResampler(c_void);

#[repr(C)]
pub struct GstAudioRingBufferClass {
    pub parent_class: gst::GstObjectClass,
    pub open_device: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub acquire: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer, *mut GstAudioRingBufferSpec) -> gboolean>,
    pub release: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub close_device: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub start: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub pause: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub resume: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub delay: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> c_uint>,
    pub activate: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer, gboolean) -> gboolean>,
    pub commit: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer, *mut u64, *mut u8, c_int, c_int, *mut c_int) -> c_uint>,
    pub clear_all: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer)>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAudioRingBufferSpec {
    pub caps: *mut gst::GstCaps,
    pub type_: GstAudioRingBufferFormatType,
    pub info: GstAudioInfo,
    pub latency_time: u64,
    pub buffer_time: u64,
    pub segsize: c_int,
    pub segtotal: c_int,
    pub seglatency: c_int,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAudioSinkClass {
    pub parent_class: GstAudioBaseSinkClass,
    pub open: Option<unsafe extern "C" fn(*mut GstAudioSink) -> gboolean>,
    pub prepare: Option<unsafe extern "C" fn(*mut GstAudioSink, *mut GstAudioRingBufferSpec) -> gboolean>,
    pub unprepare: Option<unsafe extern "C" fn(*mut GstAudioSink) -> gboolean>,
    pub close: Option<unsafe extern "C" fn(*mut GstAudioSink) -> gboolean>,
    pub write: Option<unsafe extern "C" fn(*mut GstAudioSink, gpointer, c_uint) -> c_int>,
    pub delay: Option<unsafe extern "C" fn(*mut GstAudioSink) -> c_uint>,
    pub reset: Option<unsafe extern "C" fn(*mut GstAudioSink)>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAudioSrcClass {
    pub parent_class: GstAudioBaseSrcClass,
    pub open: Option<unsafe extern "C" fn(*mut GstAudioSrc) -> gboolean>,
    pub prepare: Option<unsafe extern "C" fn(*mut GstAudioSrc, *mut GstAudioRingBufferSpec) -> gboolean>,
    pub unprepare: Option<unsafe extern "C" fn(*mut GstAudioSrc) -> gboolean>,
    pub close: Option<unsafe extern "C" fn(*mut GstAudioSrc) -> gboolean>,
    pub read: Option<unsafe extern "C" fn(*mut GstAudioSrc, gpointer, c_uint, *mut gst::GstClockTime) -> c_uint>,
    pub delay: Option<unsafe extern "C" fn(*mut GstAudioSrc) -> c_uint>,
    pub reset: Option<unsafe extern "C" fn(*mut GstAudioSrc)>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstStreamVolumeInterface {
    pub iface: gobject::GTypeInterface,
}

// Classes
#[repr(C)]
pub struct GstAudioBaseSink {
    pub element: gst_base::GstBaseSink,
    pub ringbuffer: *mut GstAudioRingBuffer,
    pub buffer_time: u64,
    pub latency_time: u64,
    pub next_sample: u64,
    pub provided_clock: *mut gst::GstClock,
    pub eos_rendering: gboolean,
    pub priv_: *mut GstAudioBaseSinkPrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAudioBaseSrc {
    pub element: gst_base::GstPushSrc,
    pub ringbuffer: *mut GstAudioRingBuffer,
    pub buffer_time: gst::GstClockTime,
    pub latency_time: gst::GstClockTime,
    pub next_sample: u64,
    pub clock: *mut gst::GstClock,
    pub priv_: *mut GstAudioBaseSrcPrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAudioCdSrc {
    pub pushsrc: gst_base::GstPushSrc,
    pub tags: *mut gst::GstTagList,
    pub priv_: *mut GstAudioCdSrcPrivate,
    pub _gst_reserved1: [c_uint; 2],
    pub _gst_reserved2: [gpointer; 2],
}

#[repr(C)]
pub struct GstAudioClock {
    pub clock: gst::GstSystemClock,
    pub func: GstAudioClockGetTimeFunc,
    pub user_data: gpointer,
    pub destroy_notify: glib::GDestroyNotify,
    pub last_time: gst::GstClockTime,
    pub time_offset: gst::GstClockTimeDiff,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAudioDecoder {
    pub element: gst::GstElement,
    pub sinkpad: *mut gst::GstPad,
    pub srcpad: *mut gst::GstPad,
    pub stream_lock: glib::GRecMutex,
    pub input_segment: gst::GstSegment,
    pub output_segment: gst::GstSegment,
    pub priv_: *mut GstAudioDecoderPrivate,
    pub _gst_reserved: [gpointer; 20],
}

#[repr(C)]
pub struct GstAudioEncoder {
    pub element: gst::GstElement,
    pub sinkpad: *mut gst::GstPad,
    pub srcpad: *mut gst::GstPad,
    pub stream_lock: glib::GRecMutex,
    pub input_segment: gst::GstSegment,
    pub output_segment: gst::GstSegment,
    pub priv_: *mut GstAudioEncoderPrivate,
    pub _gst_reserved: [gpointer; 20],
}

#[repr(C)]
pub struct GstAudioFilter {
    pub basetransform: gst_base::GstBaseTransform,
    pub info: GstAudioInfo,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAudioRingBuffer {
    pub object: gst::GstObject,
    pub cond: glib::GCond,
    pub open: gboolean,
    pub acquired: gboolean,
    pub memory: *mut u8,
    pub size: size_t,
    pub timestamps: *mut gst::GstClockTime,
    pub spec: GstAudioRingBufferSpec,
    pub samples_per_seg: c_int,
    pub empty_seg: *mut u8,
    pub state: c_int,
    pub segdone: c_int,
    pub segbase: c_int,
    pub waiting: c_int,
    pub callback: GstAudioRingBufferCallback,
    pub cb_data: gpointer,
    pub need_reorder: gboolean,
    pub channel_reorder_map: [c_int; 64],
    pub flushing: gboolean,
    pub may_start: c_int,
    pub active: gboolean,
    pub cb_data_notify: glib::GDestroyNotify,
    pub _gst_reserved: [gpointer; 3],
}

#[repr(C)]
pub struct GstAudioSink {
    pub element: GstAudioBaseSink,
    pub thread: *mut glib::GThread,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAudioSrc {
    pub element: GstAudioBaseSrc,
    pub thread: *mut glib::GThread,
    pub _gst_reserved: [gpointer; 4],
}

// Interfaces
#[repr(C)]
pub struct GstStreamVolume(c_void);

extern "C" {

    //=========================================================================
    // GstAudioFormat
    //=========================================================================
    pub fn gst_audio_format_build_integer(sign: gboolean, endianness: c_int, width: c_int, depth: c_int) -> GstAudioFormat;
    pub fn gst_audio_format_fill_silence(info: *const GstAudioFormatInfo, dest: gpointer, length: size_t);
    pub fn gst_audio_format_from_string(format: *const c_char) -> GstAudioFormat;
    pub fn gst_audio_format_get_info(format: GstAudioFormat) -> *const GstAudioFormatInfo;
    pub fn gst_audio_format_to_string(format: GstAudioFormat) -> *const c_char;

    //=========================================================================
    // GstAudioChannelMixer
    //=========================================================================
    pub fn gst_audio_channel_mixer_free(mix: *mut GstAudioChannelMixer);
    pub fn gst_audio_channel_mixer_is_passthrough(mix: *mut GstAudioChannelMixer) -> gboolean;
    pub fn gst_audio_channel_mixer_samples(mix: *mut GstAudioChannelMixer, in_: gpointer, out: gpointer, samples: c_int);
    pub fn gst_audio_channel_mixer_new(flags: GstAudioChannelMixerFlags, format: GstAudioFormat, in_channels: c_int, in_position: *mut GstAudioChannelPosition, out_channels: c_int, out_position: *mut GstAudioChannelPosition) -> *mut GstAudioChannelMixer;

    //=========================================================================
    // GstAudioClippingMeta
    //=========================================================================
    pub fn gst_audio_clipping_meta_get_info() -> *const gst::GstMetaInfo;

    //=========================================================================
    // GstAudioConverter
    //=========================================================================
    pub fn gst_audio_converter_free(convert: *mut GstAudioConverter);
    pub fn gst_audio_converter_get_config(convert: *mut GstAudioConverter, in_rate: *mut c_int, out_rate: *mut c_int) -> *const gst::GstStructure;
    pub fn gst_audio_converter_get_in_frames(convert: *mut GstAudioConverter, out_frames: size_t) -> size_t;
    pub fn gst_audio_converter_get_max_latency(convert: *mut GstAudioConverter) -> size_t;
    pub fn gst_audio_converter_get_out_frames(convert: *mut GstAudioConverter, in_frames: size_t) -> size_t;
    pub fn gst_audio_converter_reset(convert: *mut GstAudioConverter);
    pub fn gst_audio_converter_samples(convert: *mut GstAudioConverter, flags: GstAudioConverterFlags, in_: gpointer, in_frames: size_t, out: gpointer, out_frames: size_t) -> gboolean;
    pub fn gst_audio_converter_supports_inplace(convert: *mut GstAudioConverter) -> gboolean;
    pub fn gst_audio_converter_update_config(convert: *mut GstAudioConverter, in_rate: c_int, out_rate: c_int, config: *mut gst::GstStructure) -> gboolean;
    pub fn gst_audio_converter_new(flags: GstAudioConverterFlags, in_info: *mut GstAudioInfo, out_info: *mut GstAudioInfo, config: *mut gst::GstStructure) -> *mut GstAudioConverter;

    //=========================================================================
    // GstAudioDownmixMeta
    //=========================================================================
    pub fn gst_audio_downmix_meta_get_info() -> *const gst::GstMetaInfo;

    //=========================================================================
    // GstAudioFilterClass
    //=========================================================================
    pub fn gst_audio_filter_class_add_pad_templates(klass: *mut GstAudioFilterClass, allowed_caps: *mut gst::GstCaps);

    //=========================================================================
    // GstAudioInfo
    //=========================================================================
    pub fn gst_audio_info_get_type() -> GType;
    pub fn gst_audio_info_new() -> *mut GstAudioInfo;
    pub fn gst_audio_info_convert(info: *const GstAudioInfo, src_fmt: gst::GstFormat, src_val: i64, dest_fmt: gst::GstFormat, dest_val: *mut i64) -> gboolean;
    pub fn gst_audio_info_copy(info: *const GstAudioInfo) -> *mut GstAudioInfo;
    pub fn gst_audio_info_free(info: *mut GstAudioInfo);
    pub fn gst_audio_info_from_caps(info: *mut GstAudioInfo, caps: *const gst::GstCaps) -> gboolean;
    pub fn gst_audio_info_init(info: *mut GstAudioInfo);
    #[cfg(feature = "v1_2")]
    pub fn gst_audio_info_is_equal(info: *const GstAudioInfo, other: *const GstAudioInfo) -> gboolean;
    pub fn gst_audio_info_set_format(info: *mut GstAudioInfo, format: GstAudioFormat, rate: c_int, channels: c_int, position: *const GstAudioChannelPosition);
    pub fn gst_audio_info_to_caps(info: *const GstAudioInfo) -> *mut gst::GstCaps;

    //=========================================================================
    // GstAudioQuantize
    //=========================================================================
    pub fn gst_audio_quantize_free(quant: *mut GstAudioQuantize);
    pub fn gst_audio_quantize_reset(quant: *mut GstAudioQuantize);
    pub fn gst_audio_quantize_samples(quant: *mut GstAudioQuantize, in_: gpointer, out: gpointer, samples: c_uint);
    pub fn gst_audio_quantize_new(dither: GstAudioDitherMethod, ns: GstAudioNoiseShapingMethod, flags: GstAudioQuantizeFlags, format: GstAudioFormat, channels: c_uint, quantizer: c_uint) -> *mut GstAudioQuantize;

    //=========================================================================
    // GstAudioResampler
    //=========================================================================
    #[cfg(feature = "v1_6")]
    pub fn gst_audio_resampler_free(resampler: *mut GstAudioResampler);
    pub fn gst_audio_resampler_get_in_frames(resampler: *mut GstAudioResampler, out_frames: size_t) -> size_t;
    pub fn gst_audio_resampler_get_max_latency(resampler: *mut GstAudioResampler) -> size_t;
    pub fn gst_audio_resampler_get_out_frames(resampler: *mut GstAudioResampler, in_frames: size_t) -> size_t;
    pub fn gst_audio_resampler_resample(resampler: *mut GstAudioResampler, in_: gpointer, in_frames: size_t, out: gpointer, out_frames: size_t);
    pub fn gst_audio_resampler_reset(resampler: *mut GstAudioResampler);
    pub fn gst_audio_resampler_update(resampler: *mut GstAudioResampler, in_rate: c_int, out_rate: c_int, options: *mut gst::GstStructure) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_audio_resampler_new(method: GstAudioResamplerMethod, flags: GstAudioResamplerFlags, format: GstAudioFormat, channels: c_int, in_rate: c_int, out_rate: c_int, options: *mut gst::GstStructure) -> *mut GstAudioResampler;
    #[cfg(feature = "v1_6")]
    pub fn gst_audio_resampler_options_set_quality(method: GstAudioResamplerMethod, quality: c_uint, in_rate: c_int, out_rate: c_int, options: *mut gst::GstStructure);

    //=========================================================================
    // GstAudioBaseSink
    //=========================================================================
    pub fn gst_audio_base_sink_get_type() -> GType;
    pub fn gst_audio_base_sink_create_ringbuffer(sink: *mut GstAudioBaseSink) -> *mut GstAudioRingBuffer;
    pub fn gst_audio_base_sink_get_alignment_threshold(sink: *mut GstAudioBaseSink) -> gst::GstClockTime;
    pub fn gst_audio_base_sink_get_discont_wait(sink: *mut GstAudioBaseSink) -> gst::GstClockTime;
    pub fn gst_audio_base_sink_get_drift_tolerance(sink: *mut GstAudioBaseSink) -> i64;
    pub fn gst_audio_base_sink_get_provide_clock(sink: *mut GstAudioBaseSink) -> gboolean;
    pub fn gst_audio_base_sink_get_slave_method(sink: *mut GstAudioBaseSink) -> GstAudioBaseSinkSlaveMethod;
    #[cfg(feature = "v1_6")]
    pub fn gst_audio_base_sink_report_device_failure(sink: *mut GstAudioBaseSink);
    pub fn gst_audio_base_sink_set_alignment_threshold(sink: *mut GstAudioBaseSink, alignment_threshold: gst::GstClockTime);
    #[cfg(feature = "v1_6")]
    pub fn gst_audio_base_sink_set_custom_slaving_callback(sink: *mut GstAudioBaseSink, callback: GstAudioBaseSinkCustomSlavingCallback, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_audio_base_sink_set_discont_wait(sink: *mut GstAudioBaseSink, discont_wait: gst::GstClockTime);
    pub fn gst_audio_base_sink_set_drift_tolerance(sink: *mut GstAudioBaseSink, drift_tolerance: i64);
    pub fn gst_audio_base_sink_set_provide_clock(sink: *mut GstAudioBaseSink, provide: gboolean);
    pub fn gst_audio_base_sink_set_slave_method(sink: *mut GstAudioBaseSink, method: GstAudioBaseSinkSlaveMethod);

    //=========================================================================
    // GstAudioBaseSrc
    //=========================================================================
    pub fn gst_audio_base_src_get_type() -> GType;
    pub fn gst_audio_base_src_create_ringbuffer(src: *mut GstAudioBaseSrc) -> *mut GstAudioRingBuffer;
    pub fn gst_audio_base_src_get_provide_clock(src: *mut GstAudioBaseSrc) -> gboolean;
    pub fn gst_audio_base_src_get_slave_method(src: *mut GstAudioBaseSrc) -> GstAudioBaseSrcSlaveMethod;
    pub fn gst_audio_base_src_set_provide_clock(src: *mut GstAudioBaseSrc, provide: gboolean);
    pub fn gst_audio_base_src_set_slave_method(src: *mut GstAudioBaseSrc, method: GstAudioBaseSrcSlaveMethod);

    //=========================================================================
    // GstAudioCdSrc
    //=========================================================================
    pub fn gst_audio_cd_src_get_type() -> GType;
    pub fn gst_audio_cd_src_add_track(src: *mut GstAudioCdSrc, track: *mut GstAudioCdSrcTrack) -> gboolean;

    //=========================================================================
    // GstAudioClock
    //=========================================================================
    pub fn gst_audio_clock_get_type() -> GType;
    pub fn gst_audio_clock_new(name: *const c_char, func: GstAudioClockGetTimeFunc, user_data: gpointer, destroy_notify: glib::GDestroyNotify) -> *mut gst::GstClock;
    pub fn gst_audio_clock_adjust(clock: *mut GstAudioClock, time: gst::GstClockTime) -> gst::GstClockTime;
    pub fn gst_audio_clock_get_time(clock: *mut GstAudioClock) -> gst::GstClockTime;
    pub fn gst_audio_clock_invalidate(clock: *mut GstAudioClock);
    pub fn gst_audio_clock_reset(clock: *mut GstAudioClock, time: gst::GstClockTime);

    //=========================================================================
    // GstAudioDecoder
    //=========================================================================
    pub fn gst_audio_decoder_get_type() -> GType;
    pub fn gst_audio_decoder_allocate_output_buffer(dec: *mut GstAudioDecoder, size: size_t) -> *mut gst::GstBuffer;
    pub fn gst_audio_decoder_finish_frame(dec: *mut GstAudioDecoder, buf: *mut gst::GstBuffer, frames: c_int) -> gst::GstFlowReturn;
    pub fn gst_audio_decoder_get_allocator(dec: *mut GstAudioDecoder, allocator: *mut *mut gst::GstAllocator, params: *mut gst::GstAllocationParams);
    pub fn gst_audio_decoder_get_audio_info(dec: *mut GstAudioDecoder) -> *mut GstAudioInfo;
    pub fn gst_audio_decoder_get_delay(dec: *mut GstAudioDecoder) -> c_int;
    pub fn gst_audio_decoder_get_drainable(dec: *mut GstAudioDecoder) -> gboolean;
    pub fn gst_audio_decoder_get_estimate_rate(dec: *mut GstAudioDecoder) -> c_int;
    pub fn gst_audio_decoder_get_latency(dec: *mut GstAudioDecoder, min: *mut gst::GstClockTime, max: *mut gst::GstClockTime);
    pub fn gst_audio_decoder_get_max_errors(dec: *mut GstAudioDecoder) -> c_int;
    pub fn gst_audio_decoder_get_min_latency(dec: *mut GstAudioDecoder) -> gst::GstClockTime;
    pub fn gst_audio_decoder_get_needs_format(dec: *mut GstAudioDecoder) -> gboolean;
    pub fn gst_audio_decoder_get_parse_state(dec: *mut GstAudioDecoder, sync: *mut gboolean, eos: *mut gboolean);
    pub fn gst_audio_decoder_get_plc(dec: *mut GstAudioDecoder) -> gboolean;
    pub fn gst_audio_decoder_get_plc_aware(dec: *mut GstAudioDecoder) -> c_int;
    pub fn gst_audio_decoder_get_tolerance(dec: *mut GstAudioDecoder) -> gst::GstClockTime;
    pub fn gst_audio_decoder_merge_tags(dec: *mut GstAudioDecoder, tags: *const gst::GstTagList, mode: gst::GstTagMergeMode);
    pub fn gst_audio_decoder_negotiate(dec: *mut GstAudioDecoder) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_audio_decoder_proxy_getcaps(decoder: *mut GstAudioDecoder, caps: *mut gst::GstCaps, filter: *mut gst::GstCaps) -> *mut gst::GstCaps;
    #[cfg(feature = "v1_10")]
    pub fn gst_audio_decoder_set_allocation_caps(dec: *mut GstAudioDecoder, allocation_caps: *mut gst::GstCaps);
    pub fn gst_audio_decoder_set_drainable(dec: *mut GstAudioDecoder, enabled: gboolean);
    pub fn gst_audio_decoder_set_estimate_rate(dec: *mut GstAudioDecoder, enabled: gboolean);
    pub fn gst_audio_decoder_set_latency(dec: *mut GstAudioDecoder, min: gst::GstClockTime, max: gst::GstClockTime);
    pub fn gst_audio_decoder_set_max_errors(dec: *mut GstAudioDecoder, num: c_int);
    pub fn gst_audio_decoder_set_min_latency(dec: *mut GstAudioDecoder, num: gst::GstClockTime);
    pub fn gst_audio_decoder_set_needs_format(dec: *mut GstAudioDecoder, enabled: gboolean);
    pub fn gst_audio_decoder_set_output_format(dec: *mut GstAudioDecoder, info: *const GstAudioInfo) -> gboolean;
    pub fn gst_audio_decoder_set_plc(dec: *mut GstAudioDecoder, enabled: gboolean);
    pub fn gst_audio_decoder_set_plc_aware(dec: *mut GstAudioDecoder, plc: gboolean);
    pub fn gst_audio_decoder_set_tolerance(dec: *mut GstAudioDecoder, tolerance: gst::GstClockTime);
    #[cfg(feature = "v1_6")]
    pub fn gst_audio_decoder_set_use_default_pad_acceptcaps(decoder: *mut GstAudioDecoder, use_: gboolean);

    //=========================================================================
    // GstAudioEncoder
    //=========================================================================
    pub fn gst_audio_encoder_get_type() -> GType;
    pub fn gst_audio_encoder_allocate_output_buffer(enc: *mut GstAudioEncoder, size: size_t) -> *mut gst::GstBuffer;
    pub fn gst_audio_encoder_finish_frame(enc: *mut GstAudioEncoder, buffer: *mut gst::GstBuffer, samples: c_int) -> gst::GstFlowReturn;
    pub fn gst_audio_encoder_get_allocator(enc: *mut GstAudioEncoder, allocator: *mut *mut gst::GstAllocator, params: *mut gst::GstAllocationParams);
    pub fn gst_audio_encoder_get_audio_info(enc: *mut GstAudioEncoder) -> *mut GstAudioInfo;
    pub fn gst_audio_encoder_get_drainable(enc: *mut GstAudioEncoder) -> gboolean;
    pub fn gst_audio_encoder_get_frame_max(enc: *mut GstAudioEncoder) -> c_int;
    pub fn gst_audio_encoder_get_frame_samples_max(enc: *mut GstAudioEncoder) -> c_int;
    pub fn gst_audio_encoder_get_frame_samples_min(enc: *mut GstAudioEncoder) -> c_int;
    pub fn gst_audio_encoder_get_hard_min(enc: *mut GstAudioEncoder) -> gboolean;
    pub fn gst_audio_encoder_get_hard_resync(enc: *mut GstAudioEncoder) -> gboolean;
    pub fn gst_audio_encoder_get_latency(enc: *mut GstAudioEncoder, min: *mut gst::GstClockTime, max: *mut gst::GstClockTime);
    pub fn gst_audio_encoder_get_lookahead(enc: *mut GstAudioEncoder) -> c_int;
    pub fn gst_audio_encoder_get_mark_granule(enc: *mut GstAudioEncoder) -> gboolean;
    pub fn gst_audio_encoder_get_perfect_timestamp(enc: *mut GstAudioEncoder) -> gboolean;
    pub fn gst_audio_encoder_get_tolerance(enc: *mut GstAudioEncoder) -> gst::GstClockTime;
    pub fn gst_audio_encoder_merge_tags(enc: *mut GstAudioEncoder, tags: *const gst::GstTagList, mode: gst::GstTagMergeMode);
    pub fn gst_audio_encoder_negotiate(enc: *mut GstAudioEncoder) -> gboolean;
    pub fn gst_audio_encoder_proxy_getcaps(enc: *mut GstAudioEncoder, caps: *mut gst::GstCaps, filter: *mut gst::GstCaps) -> *mut gst::GstCaps;
    #[cfg(feature = "v1_10")]
    pub fn gst_audio_encoder_set_allocation_caps(enc: *mut GstAudioEncoder, allocation_caps: *mut gst::GstCaps);
    pub fn gst_audio_encoder_set_drainable(enc: *mut GstAudioEncoder, enabled: gboolean);
    pub fn gst_audio_encoder_set_frame_max(enc: *mut GstAudioEncoder, num: c_int);
    pub fn gst_audio_encoder_set_frame_samples_max(enc: *mut GstAudioEncoder, num: c_int);
    pub fn gst_audio_encoder_set_frame_samples_min(enc: *mut GstAudioEncoder, num: c_int);
    pub fn gst_audio_encoder_set_hard_min(enc: *mut GstAudioEncoder, enabled: gboolean);
    pub fn gst_audio_encoder_set_hard_resync(enc: *mut GstAudioEncoder, enabled: gboolean);
    pub fn gst_audio_encoder_set_headers(enc: *mut GstAudioEncoder, headers: *mut glib::GList);
    pub fn gst_audio_encoder_set_latency(enc: *mut GstAudioEncoder, min: gst::GstClockTime, max: gst::GstClockTime);
    pub fn gst_audio_encoder_set_lookahead(enc: *mut GstAudioEncoder, num: c_int);
    pub fn gst_audio_encoder_set_mark_granule(enc: *mut GstAudioEncoder, enabled: gboolean);
    pub fn gst_audio_encoder_set_output_format(enc: *mut GstAudioEncoder, caps: *mut gst::GstCaps) -> gboolean;
    pub fn gst_audio_encoder_set_perfect_timestamp(enc: *mut GstAudioEncoder, enabled: gboolean);
    pub fn gst_audio_encoder_set_tolerance(enc: *mut GstAudioEncoder, tolerance: gst::GstClockTime);

    //=========================================================================
    // GstAudioFilter
    //=========================================================================
    pub fn gst_audio_filter_get_type() -> GType;

    //=========================================================================
    // GstAudioRingBuffer
    //=========================================================================
    pub fn gst_audio_ring_buffer_get_type() -> GType;
    pub fn gst_audio_ring_buffer_debug_spec_buff(spec: *mut GstAudioRingBufferSpec);
    pub fn gst_audio_ring_buffer_debug_spec_caps(spec: *mut GstAudioRingBufferSpec);
    pub fn gst_audio_ring_buffer_parse_caps(spec: *mut GstAudioRingBufferSpec, caps: *mut gst::GstCaps) -> gboolean;
    pub fn gst_audio_ring_buffer_acquire(buf: *mut GstAudioRingBuffer, spec: *mut GstAudioRingBufferSpec) -> gboolean;
    pub fn gst_audio_ring_buffer_activate(buf: *mut GstAudioRingBuffer, active: gboolean) -> gboolean;
    pub fn gst_audio_ring_buffer_advance(buf: *mut GstAudioRingBuffer, advance: c_uint);
    pub fn gst_audio_ring_buffer_clear(buf: *mut GstAudioRingBuffer, segment: c_int);
    pub fn gst_audio_ring_buffer_clear_all(buf: *mut GstAudioRingBuffer);
    pub fn gst_audio_ring_buffer_close_device(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_commit(buf: *mut GstAudioRingBuffer, sample: *mut u64, data: *mut u8, in_samples: c_int, out_samples: c_int, accum: *mut c_int) -> c_uint;
    pub fn gst_audio_ring_buffer_convert(buf: *mut GstAudioRingBuffer, src_fmt: gst::GstFormat, src_val: i64, dest_fmt: gst::GstFormat, dest_val: *mut i64) -> gboolean;
    pub fn gst_audio_ring_buffer_delay(buf: *mut GstAudioRingBuffer) -> c_uint;
    pub fn gst_audio_ring_buffer_device_is_open(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_is_acquired(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_is_active(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_is_flushing(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_may_start(buf: *mut GstAudioRingBuffer, allowed: gboolean);
    pub fn gst_audio_ring_buffer_open_device(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_pause(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_prepare_read(buf: *mut GstAudioRingBuffer, segment: *mut c_int, readptr: *mut *mut u8, len: *mut c_int) -> gboolean;
    pub fn gst_audio_ring_buffer_read(buf: *mut GstAudioRingBuffer, sample: u64, data: *mut u8, len: c_uint, timestamp: *mut gst::GstClockTime) -> c_uint;
    pub fn gst_audio_ring_buffer_release(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_samples_done(buf: *mut GstAudioRingBuffer) -> u64;
    pub fn gst_audio_ring_buffer_set_callback(buf: *mut GstAudioRingBuffer, cb: GstAudioRingBufferCallback, user_data: gpointer);
    #[cfg(feature = "v1_12")]
    pub fn gst_audio_ring_buffer_set_callback_full(buf: *mut GstAudioRingBuffer, cb: GstAudioRingBufferCallback, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_audio_ring_buffer_set_channel_positions(buf: *mut GstAudioRingBuffer, position: *const GstAudioChannelPosition);
    pub fn gst_audio_ring_buffer_set_flushing(buf: *mut GstAudioRingBuffer, flushing: gboolean);
    pub fn gst_audio_ring_buffer_set_sample(buf: *mut GstAudioRingBuffer, sample: u64);
    pub fn gst_audio_ring_buffer_set_timestamp(buf: *mut GstAudioRingBuffer, readseg: c_int, timestamp: gst::GstClockTime);
    pub fn gst_audio_ring_buffer_start(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_stop(buf: *mut GstAudioRingBuffer) -> gboolean;

    //=========================================================================
    // GstAudioSink
    //=========================================================================
    pub fn gst_audio_sink_get_type() -> GType;

    //=========================================================================
    // GstAudioSrc
    //=========================================================================
    pub fn gst_audio_src_get_type() -> GType;

    //=========================================================================
    // GstStreamVolume
    //=========================================================================
    pub fn gst_stream_volume_get_type() -> GType;
    pub fn gst_stream_volume_convert_volume(from: GstStreamVolumeFormat, to: GstStreamVolumeFormat, val: c_double) -> c_double;
    pub fn gst_stream_volume_get_mute(volume: *mut GstStreamVolume) -> gboolean;
    pub fn gst_stream_volume_get_volume(volume: *mut GstStreamVolume, format: GstStreamVolumeFormat) -> c_double;
    pub fn gst_stream_volume_set_mute(volume: *mut GstStreamVolume, mute: gboolean);
    pub fn gst_stream_volume_set_volume(volume: *mut GstStreamVolume, format: GstStreamVolumeFormat, val: c_double);

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn gst_audio_buffer_clip(buffer: *mut gst::GstBuffer, segment: *const gst::GstSegment, rate: c_int, bpf: c_int) -> *mut gst::GstBuffer;
    pub fn gst_audio_buffer_reorder_channels(buffer: *mut gst::GstBuffer, format: GstAudioFormat, channels: c_int, from: *mut GstAudioChannelPosition, to: *mut GstAudioChannelPosition) -> gboolean;
    #[cfg(feature = "v1_8")]
    pub fn gst_audio_channel_get_fallback_mask(channels: c_int) -> u64;
    pub fn gst_audio_channel_positions_from_mask(channels: c_int, channel_mask: u64, position: *mut GstAudioChannelPosition) -> gboolean;
    pub fn gst_audio_channel_positions_to_mask(position: *mut GstAudioChannelPosition, channels: c_int, force_order: gboolean, channel_mask: *mut u64) -> gboolean;
    pub fn gst_audio_channel_positions_to_string(position: *mut GstAudioChannelPosition, channels: c_int) -> *mut c_char;
    pub fn gst_audio_channel_positions_to_valid_order(position: *mut GstAudioChannelPosition, channels: c_int) -> gboolean;
    pub fn gst_audio_check_valid_channel_positions(position: *mut GstAudioChannelPosition, channels: c_int, force_order: gboolean) -> gboolean;
    pub fn gst_audio_clipping_meta_api_get_type() -> GType;
    pub fn gst_audio_downmix_meta_api_get_type() -> GType;
    pub fn gst_audio_format_info_get_type() -> GType;
    pub fn gst_audio_get_channel_reorder_map(channels: c_int, from: *mut GstAudioChannelPosition, to: *mut GstAudioChannelPosition, reorder_map: *mut c_int) -> gboolean;
    pub fn gst_audio_iec61937_frame_size(spec: *const GstAudioRingBufferSpec) -> c_uint;
    pub fn gst_audio_iec61937_payload(src: *mut u8, src_n: c_uint, dst: *mut u8, dst_n: c_uint, spec: *const GstAudioRingBufferSpec, endianness: c_int) -> gboolean;
    pub fn gst_audio_reorder_channels(data: gpointer, size: size_t, format: GstAudioFormat, channels: c_int, from: *mut GstAudioChannelPosition, to: *mut GstAudioChannelPosition) -> gboolean;
    #[cfg(feature = "v1_8")]
    pub fn gst_buffer_add_audio_clipping_meta(buffer: *mut gst::GstBuffer, format: gst::GstFormat, start: u64, end: u64) -> *mut GstAudioClippingMeta;
    pub fn gst_buffer_add_audio_downmix_meta(buffer: *mut gst::GstBuffer, from_position: *mut GstAudioChannelPosition, from_channels: c_int, to_position: *mut GstAudioChannelPosition, to_channels: c_int, matrix: *mut *const c_float) -> *mut GstAudioDownmixMeta;
    pub fn gst_buffer_get_audio_downmix_meta_for_channels(buffer: *mut gst::GstBuffer, to_position: *mut GstAudioChannelPosition, to_channels: c_int) -> *mut GstAudioDownmixMeta;

}
