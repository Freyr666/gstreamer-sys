// This file was generated by gir (f493ea3) from gir-files (???)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals)]

extern crate libc;
#[macro_use] extern crate bitflags;
extern crate glib_sys as glib;
extern crate gobject_sys as gobject;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType, Volatile};

// Aliases
pub type GstClockID = gpointer;
pub type GstClockTime = u64;
pub type GstClockTimeDiff = i64;
pub type GstElementFactoryListType = u64;

// Enums
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstBufferingMode {
    Stream = 0,
    Download = 1,
    Timeshift = 2,
    Live = 3,
}
pub const GST_BUFFERING_STREAM: GstBufferingMode = GstBufferingMode::Stream;
pub const GST_BUFFERING_DOWNLOAD: GstBufferingMode = GstBufferingMode::Download;
pub const GST_BUFFERING_TIMESHIFT: GstBufferingMode = GstBufferingMode::Timeshift;
pub const GST_BUFFERING_LIVE: GstBufferingMode = GstBufferingMode::Live;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstBusSyncReply {
    Drop = 0,
    Pass = 1,
    Async = 2,
}
pub const GST_BUS_DROP: GstBusSyncReply = GstBusSyncReply::Drop;
pub const GST_BUS_PASS: GstBusSyncReply = GstBusSyncReply::Pass;
pub const GST_BUS_ASYNC: GstBusSyncReply = GstBusSyncReply::Async;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstCapsIntersectMode {
    ZigZag = 0,
    First = 1,
}
pub const GST_CAPS_INTERSECT_ZIG_ZAG: GstCapsIntersectMode = GstCapsIntersectMode::ZigZag;
pub const GST_CAPS_INTERSECT_FIRST: GstCapsIntersectMode = GstCapsIntersectMode::First;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstClockEntryType {
    Single = 0,
    Periodic = 1,
}
pub const GST_CLOCK_ENTRY_SINGLE: GstClockEntryType = GstClockEntryType::Single;
pub const GST_CLOCK_ENTRY_PERIODIC: GstClockEntryType = GstClockEntryType::Periodic;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstClockReturn {
    Ok = 0,
    Early = 1,
    Unscheduled = 2,
    Busy = 3,
    Badtime = 4,
    Error = 5,
    Unsupported = 6,
    Done = 7,
}
pub const GST_CLOCK_OK: GstClockReturn = GstClockReturn::Ok;
pub const GST_CLOCK_EARLY: GstClockReturn = GstClockReturn::Early;
pub const GST_CLOCK_UNSCHEDULED: GstClockReturn = GstClockReturn::Unscheduled;
pub const GST_CLOCK_BUSY: GstClockReturn = GstClockReturn::Busy;
pub const GST_CLOCK_BADTIME: GstClockReturn = GstClockReturn::Badtime;
pub const GST_CLOCK_ERROR: GstClockReturn = GstClockReturn::Error;
pub const GST_CLOCK_UNSUPPORTED: GstClockReturn = GstClockReturn::Unsupported;
pub const GST_CLOCK_DONE: GstClockReturn = GstClockReturn::Done;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstClockType {
    Realtime = 0,
    Monotonic = 1,
    Other = 2,
}
pub const GST_CLOCK_TYPE_REALTIME: GstClockType = GstClockType::Realtime;
pub const GST_CLOCK_TYPE_MONOTONIC: GstClockType = GstClockType::Monotonic;
pub const GST_CLOCK_TYPE_OTHER: GstClockType = GstClockType::Other;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstCoreError {
    Failed = 1,
    TooLazy = 2,
    NotImplemented = 3,
    StateChange = 4,
    Pad = 5,
    Thread = 6,
    Negotiation = 7,
    Event = 8,
    Seek = 9,
    Caps = 10,
    Tag = 11,
    MissingPlugin = 12,
    Clock = 13,
    Disabled = 14,
    NumErrors = 15,
}
pub const GST_CORE_ERROR_FAILED: GstCoreError = GstCoreError::Failed;
pub const GST_CORE_ERROR_TOO_LAZY: GstCoreError = GstCoreError::TooLazy;
pub const GST_CORE_ERROR_NOT_IMPLEMENTED: GstCoreError = GstCoreError::NotImplemented;
pub const GST_CORE_ERROR_STATE_CHANGE: GstCoreError = GstCoreError::StateChange;
pub const GST_CORE_ERROR_PAD: GstCoreError = GstCoreError::Pad;
pub const GST_CORE_ERROR_THREAD: GstCoreError = GstCoreError::Thread;
pub const GST_CORE_ERROR_NEGOTIATION: GstCoreError = GstCoreError::Negotiation;
pub const GST_CORE_ERROR_EVENT: GstCoreError = GstCoreError::Event;
pub const GST_CORE_ERROR_SEEK: GstCoreError = GstCoreError::Seek;
pub const GST_CORE_ERROR_CAPS: GstCoreError = GstCoreError::Caps;
pub const GST_CORE_ERROR_TAG: GstCoreError = GstCoreError::Tag;
pub const GST_CORE_ERROR_MISSING_PLUGIN: GstCoreError = GstCoreError::MissingPlugin;
pub const GST_CORE_ERROR_CLOCK: GstCoreError = GstCoreError::Clock;
pub const GST_CORE_ERROR_DISABLED: GstCoreError = GstCoreError::Disabled;
pub const GST_CORE_ERROR_NUM_ERRORS: GstCoreError = GstCoreError::NumErrors;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstDebugColorFlags {
    FgBlack = 0,
    FgRed = 1,
    FgGreen = 2,
    FgYellow = 3,
    FgBlue = 4,
    FgMagenta = 5,
    FgCyan = 6,
    FgWhite = 7,
    BgRed = 16,
    BgGreen = 32,
    BgYellow = 48,
    BgBlue = 64,
    BgMagenta = 80,
    BgCyan = 96,
    BgWhite = 112,
    Bold = 256,
    Underline = 512,
}
pub const GST_DEBUG_FG_BLACK: GstDebugColorFlags = GstDebugColorFlags::FgBlack;
pub const GST_DEBUG_FG_RED: GstDebugColorFlags = GstDebugColorFlags::FgRed;
pub const GST_DEBUG_FG_GREEN: GstDebugColorFlags = GstDebugColorFlags::FgGreen;
pub const GST_DEBUG_FG_YELLOW: GstDebugColorFlags = GstDebugColorFlags::FgYellow;
pub const GST_DEBUG_FG_BLUE: GstDebugColorFlags = GstDebugColorFlags::FgBlue;
pub const GST_DEBUG_FG_MAGENTA: GstDebugColorFlags = GstDebugColorFlags::FgMagenta;
pub const GST_DEBUG_FG_CYAN: GstDebugColorFlags = GstDebugColorFlags::FgCyan;
pub const GST_DEBUG_FG_WHITE: GstDebugColorFlags = GstDebugColorFlags::FgWhite;
pub const GST_DEBUG_BG_BLACK: GstDebugColorFlags = GstDebugColorFlags::FgBlack;
pub const GST_DEBUG_BG_RED: GstDebugColorFlags = GstDebugColorFlags::BgRed;
pub const GST_DEBUG_BG_GREEN: GstDebugColorFlags = GstDebugColorFlags::BgGreen;
pub const GST_DEBUG_BG_YELLOW: GstDebugColorFlags = GstDebugColorFlags::BgYellow;
pub const GST_DEBUG_BG_BLUE: GstDebugColorFlags = GstDebugColorFlags::BgBlue;
pub const GST_DEBUG_BG_MAGENTA: GstDebugColorFlags = GstDebugColorFlags::BgMagenta;
pub const GST_DEBUG_BG_CYAN: GstDebugColorFlags = GstDebugColorFlags::BgCyan;
pub const GST_DEBUG_BG_WHITE: GstDebugColorFlags = GstDebugColorFlags::BgWhite;
pub const GST_DEBUG_BOLD: GstDebugColorFlags = GstDebugColorFlags::Bold;
pub const GST_DEBUG_UNDERLINE: GstDebugColorFlags = GstDebugColorFlags::Underline;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstDebugColorMode {
    Off = 0,
    On = 1,
    Unix = 2,
}
pub const GST_DEBUG_COLOR_MODE_OFF: GstDebugColorMode = GstDebugColorMode::Off;
pub const GST_DEBUG_COLOR_MODE_ON: GstDebugColorMode = GstDebugColorMode::On;
pub const GST_DEBUG_COLOR_MODE_UNIX: GstDebugColorMode = GstDebugColorMode::Unix;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstDebugLevel {
    None = 0,
    Error = 1,
    Warning = 2,
    Fixme = 3,
    Info = 4,
    Debug = 5,
    Log = 6,
    Trace = 7,
    Memdump = 9,
    Count = 10,
}
pub const GST_LEVEL_NONE: GstDebugLevel = GstDebugLevel::None;
pub const GST_LEVEL_ERROR: GstDebugLevel = GstDebugLevel::Error;
pub const GST_LEVEL_WARNING: GstDebugLevel = GstDebugLevel::Warning;
pub const GST_LEVEL_FIXME: GstDebugLevel = GstDebugLevel::Fixme;
pub const GST_LEVEL_INFO: GstDebugLevel = GstDebugLevel::Info;
pub const GST_LEVEL_DEBUG: GstDebugLevel = GstDebugLevel::Debug;
pub const GST_LEVEL_LOG: GstDebugLevel = GstDebugLevel::Log;
pub const GST_LEVEL_TRACE: GstDebugLevel = GstDebugLevel::Trace;
pub const GST_LEVEL_MEMDUMP: GstDebugLevel = GstDebugLevel::Memdump;
pub const GST_LEVEL_COUNT: GstDebugLevel = GstDebugLevel::Count;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstEventType {
    Unknown = 0,
    FlushStart = 2563,
    FlushStop = 5127,
    StreamStart = 10254,
    Caps = 12814,
    Segment = 17934,
    StreamCollection = 19230,
    Tag = 20510,
    Buffersize = 23054,
    SinkMessage = 25630,
    StreamGroupDone = 26894,
    Eos = 28174,
    Toc = 30750,
    Protection = 33310,
    SegmentDone = 38406,
    Gap = 40966,
    Qos = 48641,
    Seek = 51201,
    Navigation = 53761,
    Latency = 56321,
    Step = 58881,
    Reconfigure = 61441,
    TocSelect = 64001,
    SelectStreams = 66561,
    CustomUpstream = 69121,
    CustomDownstream = 71686,
    CustomDownstreamOob = 74242,
    CustomDownstreamSticky = 76830,
    CustomBoth = 79367,
    CustomBothOob = 81923,
}
pub const GST_EVENT_UNKNOWN: GstEventType = GstEventType::Unknown;
pub const GST_EVENT_FLUSH_START: GstEventType = GstEventType::FlushStart;
pub const GST_EVENT_FLUSH_STOP: GstEventType = GstEventType::FlushStop;
pub const GST_EVENT_STREAM_START: GstEventType = GstEventType::StreamStart;
pub const GST_EVENT_CAPS: GstEventType = GstEventType::Caps;
pub const GST_EVENT_SEGMENT: GstEventType = GstEventType::Segment;
pub const GST_EVENT_STREAM_COLLECTION: GstEventType = GstEventType::StreamCollection;
pub const GST_EVENT_TAG: GstEventType = GstEventType::Tag;
pub const GST_EVENT_BUFFERSIZE: GstEventType = GstEventType::Buffersize;
pub const GST_EVENT_SINK_MESSAGE: GstEventType = GstEventType::SinkMessage;
pub const GST_EVENT_STREAM_GROUP_DONE: GstEventType = GstEventType::StreamGroupDone;
pub const GST_EVENT_EOS: GstEventType = GstEventType::Eos;
pub const GST_EVENT_TOC: GstEventType = GstEventType::Toc;
pub const GST_EVENT_PROTECTION: GstEventType = GstEventType::Protection;
pub const GST_EVENT_SEGMENT_DONE: GstEventType = GstEventType::SegmentDone;
pub const GST_EVENT_GAP: GstEventType = GstEventType::Gap;
pub const GST_EVENT_QOS: GstEventType = GstEventType::Qos;
pub const GST_EVENT_SEEK: GstEventType = GstEventType::Seek;
pub const GST_EVENT_NAVIGATION: GstEventType = GstEventType::Navigation;
pub const GST_EVENT_LATENCY: GstEventType = GstEventType::Latency;
pub const GST_EVENT_STEP: GstEventType = GstEventType::Step;
pub const GST_EVENT_RECONFIGURE: GstEventType = GstEventType::Reconfigure;
pub const GST_EVENT_TOC_SELECT: GstEventType = GstEventType::TocSelect;
pub const GST_EVENT_SELECT_STREAMS: GstEventType = GstEventType::SelectStreams;
pub const GST_EVENT_CUSTOM_UPSTREAM: GstEventType = GstEventType::CustomUpstream;
pub const GST_EVENT_CUSTOM_DOWNSTREAM: GstEventType = GstEventType::CustomDownstream;
pub const GST_EVENT_CUSTOM_DOWNSTREAM_OOB: GstEventType = GstEventType::CustomDownstreamOob;
pub const GST_EVENT_CUSTOM_DOWNSTREAM_STICKY: GstEventType = GstEventType::CustomDownstreamSticky;
pub const GST_EVENT_CUSTOM_BOTH: GstEventType = GstEventType::CustomBoth;
pub const GST_EVENT_CUSTOM_BOTH_OOB: GstEventType = GstEventType::CustomBothOob;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstFlowReturn {
    CustomSuccess2 = 102,
    CustomSuccess1 = 101,
    CustomSuccess = 100,
    Ok = 0,
    NotLinked = -1,
    Flushing = -2,
    Eos = -3,
    NotNegotiated = -4,
    Error = -5,
    NotSupported = -6,
    CustomError = -100,
    CustomError1 = -101,
    CustomError2 = -102,
}
pub const GST_FLOW_CUSTOM_SUCCESS_2: GstFlowReturn = GstFlowReturn::CustomSuccess2;
pub const GST_FLOW_CUSTOM_SUCCESS_1: GstFlowReturn = GstFlowReturn::CustomSuccess1;
pub const GST_FLOW_CUSTOM_SUCCESS: GstFlowReturn = GstFlowReturn::CustomSuccess;
pub const GST_FLOW_OK: GstFlowReturn = GstFlowReturn::Ok;
pub const GST_FLOW_NOT_LINKED: GstFlowReturn = GstFlowReturn::NotLinked;
pub const GST_FLOW_FLUSHING: GstFlowReturn = GstFlowReturn::Flushing;
pub const GST_FLOW_EOS: GstFlowReturn = GstFlowReturn::Eos;
pub const GST_FLOW_NOT_NEGOTIATED: GstFlowReturn = GstFlowReturn::NotNegotiated;
pub const GST_FLOW_ERROR: GstFlowReturn = GstFlowReturn::Error;
pub const GST_FLOW_NOT_SUPPORTED: GstFlowReturn = GstFlowReturn::NotSupported;
pub const GST_FLOW_CUSTOM_ERROR: GstFlowReturn = GstFlowReturn::CustomError;
pub const GST_FLOW_CUSTOM_ERROR_1: GstFlowReturn = GstFlowReturn::CustomError1;
pub const GST_FLOW_CUSTOM_ERROR_2: GstFlowReturn = GstFlowReturn::CustomError2;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstFormat {
    Undefined = 0,
    Default = 1,
    Bytes = 2,
    Time = 3,
    Buffers = 4,
    Percent = 5,
}
pub const GST_FORMAT_UNDEFINED: GstFormat = GstFormat::Undefined;
pub const GST_FORMAT_DEFAULT: GstFormat = GstFormat::Default;
pub const GST_FORMAT_BYTES: GstFormat = GstFormat::Bytes;
pub const GST_FORMAT_TIME: GstFormat = GstFormat::Time;
pub const GST_FORMAT_BUFFERS: GstFormat = GstFormat::Buffers;
pub const GST_FORMAT_PERCENT: GstFormat = GstFormat::Percent;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstIteratorItem {
    Skip = 0,
    Pass = 1,
    End = 2,
}
pub const GST_ITERATOR_ITEM_SKIP: GstIteratorItem = GstIteratorItem::Skip;
pub const GST_ITERATOR_ITEM_PASS: GstIteratorItem = GstIteratorItem::Pass;
pub const GST_ITERATOR_ITEM_END: GstIteratorItem = GstIteratorItem::End;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstIteratorResult {
    Done = 0,
    Ok = 1,
    Resync = 2,
    Error = 3,
}
pub const GST_ITERATOR_DONE: GstIteratorResult = GstIteratorResult::Done;
pub const GST_ITERATOR_OK: GstIteratorResult = GstIteratorResult::Ok;
pub const GST_ITERATOR_RESYNC: GstIteratorResult = GstIteratorResult::Resync;
pub const GST_ITERATOR_ERROR: GstIteratorResult = GstIteratorResult::Error;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstLibraryError {
    Failed = 1,
    TooLazy = 2,
    Init = 3,
    Shutdown = 4,
    Settings = 5,
    Encode = 6,
    NumErrors = 7,
}
pub const GST_LIBRARY_ERROR_FAILED: GstLibraryError = GstLibraryError::Failed;
pub const GST_LIBRARY_ERROR_TOO_LAZY: GstLibraryError = GstLibraryError::TooLazy;
pub const GST_LIBRARY_ERROR_INIT: GstLibraryError = GstLibraryError::Init;
pub const GST_LIBRARY_ERROR_SHUTDOWN: GstLibraryError = GstLibraryError::Shutdown;
pub const GST_LIBRARY_ERROR_SETTINGS: GstLibraryError = GstLibraryError::Settings;
pub const GST_LIBRARY_ERROR_ENCODE: GstLibraryError = GstLibraryError::Encode;
pub const GST_LIBRARY_ERROR_NUM_ERRORS: GstLibraryError = GstLibraryError::NumErrors;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstPadDirection {
    Unknown = 0,
    Src = 1,
    Sink = 2,
}
pub const GST_PAD_UNKNOWN: GstPadDirection = GstPadDirection::Unknown;
pub const GST_PAD_SRC: GstPadDirection = GstPadDirection::Src;
pub const GST_PAD_SINK: GstPadDirection = GstPadDirection::Sink;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstPadLinkReturn {
    Ok = 0,
    WrongHierarchy = -1,
    WasLinked = -2,
    WrongDirection = -3,
    Noformat = -4,
    Nosched = -5,
    Refused = -6,
}
pub const GST_PAD_LINK_OK: GstPadLinkReturn = GstPadLinkReturn::Ok;
pub const GST_PAD_LINK_WRONG_HIERARCHY: GstPadLinkReturn = GstPadLinkReturn::WrongHierarchy;
pub const GST_PAD_LINK_WAS_LINKED: GstPadLinkReturn = GstPadLinkReturn::WasLinked;
pub const GST_PAD_LINK_WRONG_DIRECTION: GstPadLinkReturn = GstPadLinkReturn::WrongDirection;
pub const GST_PAD_LINK_NOFORMAT: GstPadLinkReturn = GstPadLinkReturn::Noformat;
pub const GST_PAD_LINK_NOSCHED: GstPadLinkReturn = GstPadLinkReturn::Nosched;
pub const GST_PAD_LINK_REFUSED: GstPadLinkReturn = GstPadLinkReturn::Refused;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstPadMode {
    None = 0,
    Push = 1,
    Pull = 2,
}
pub const GST_PAD_MODE_NONE: GstPadMode = GstPadMode::None;
pub const GST_PAD_MODE_PUSH: GstPadMode = GstPadMode::Push;
pub const GST_PAD_MODE_PULL: GstPadMode = GstPadMode::Pull;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstPadPresence {
    Always = 0,
    Sometimes = 1,
    Request = 2,
}
pub const GST_PAD_ALWAYS: GstPadPresence = GstPadPresence::Always;
pub const GST_PAD_SOMETIMES: GstPadPresence = GstPadPresence::Sometimes;
pub const GST_PAD_REQUEST: GstPadPresence = GstPadPresence::Request;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstPadProbeReturn {
    Drop = 0,
    Ok = 1,
    Remove = 2,
    Pass = 3,
    Handled = 4,
}
pub const GST_PAD_PROBE_DROP: GstPadProbeReturn = GstPadProbeReturn::Drop;
pub const GST_PAD_PROBE_OK: GstPadProbeReturn = GstPadProbeReturn::Ok;
pub const GST_PAD_PROBE_REMOVE: GstPadProbeReturn = GstPadProbeReturn::Remove;
pub const GST_PAD_PROBE_PASS: GstPadProbeReturn = GstPadProbeReturn::Pass;
pub const GST_PAD_PROBE_HANDLED: GstPadProbeReturn = GstPadProbeReturn::Handled;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstParseError {
    Syntax = 0,
    NoSuchElement = 1,
    NoSuchProperty = 2,
    Link = 3,
    CouldNotSetProperty = 4,
    EmptyBin = 5,
    Empty = 6,
    DelayedLink = 7,
}
pub const GST_PARSE_ERROR_SYNTAX: GstParseError = GstParseError::Syntax;
pub const GST_PARSE_ERROR_NO_SUCH_ELEMENT: GstParseError = GstParseError::NoSuchElement;
pub const GST_PARSE_ERROR_NO_SUCH_PROPERTY: GstParseError = GstParseError::NoSuchProperty;
pub const GST_PARSE_ERROR_LINK: GstParseError = GstParseError::Link;
pub const GST_PARSE_ERROR_COULD_NOT_SET_PROPERTY: GstParseError = GstParseError::CouldNotSetProperty;
pub const GST_PARSE_ERROR_EMPTY_BIN: GstParseError = GstParseError::EmptyBin;
pub const GST_PARSE_ERROR_EMPTY: GstParseError = GstParseError::Empty;
pub const GST_PARSE_ERROR_DELAYED_LINK: GstParseError = GstParseError::DelayedLink;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstPluginError {
    Module = 0,
    Dependencies = 1,
    NameMismatch = 2,
}
pub const GST_PLUGIN_ERROR_MODULE: GstPluginError = GstPluginError::Module;
pub const GST_PLUGIN_ERROR_DEPENDENCIES: GstPluginError = GstPluginError::Dependencies;
pub const GST_PLUGIN_ERROR_NAME_MISMATCH: GstPluginError = GstPluginError::NameMismatch;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstProgressType {
    Start = 0,
    Continue = 1,
    Complete = 2,
    Canceled = 3,
    Error = 4,
}
pub const GST_PROGRESS_TYPE_START: GstProgressType = GstProgressType::Start;
pub const GST_PROGRESS_TYPE_CONTINUE: GstProgressType = GstProgressType::Continue;
pub const GST_PROGRESS_TYPE_COMPLETE: GstProgressType = GstProgressType::Complete;
pub const GST_PROGRESS_TYPE_CANCELED: GstProgressType = GstProgressType::Canceled;
pub const GST_PROGRESS_TYPE_ERROR: GstProgressType = GstProgressType::Error;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstQOSType {
    Overflow = 0,
    Underflow = 1,
    Throttle = 2,
}
pub const GST_QOS_TYPE_OVERFLOW: GstQOSType = GstQOSType::Overflow;
pub const GST_QOS_TYPE_UNDERFLOW: GstQOSType = GstQOSType::Underflow;
pub const GST_QOS_TYPE_THROTTLE: GstQOSType = GstQOSType::Throttle;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstQueryType {
    Unknown = 0,
    Position = 2563,
    Duration = 5123,
    Latency = 7683,
    Jitter = 10243,
    Rate = 12803,
    Seeking = 15363,
    Segment = 17923,
    Convert = 20483,
    Formats = 23043,
    Buffering = 28163,
    Custom = 30723,
    Uri = 33283,
    Allocation = 35846,
    Scheduling = 38401,
    AcceptCaps = 40963,
    Caps = 43523,
    Drain = 46086,
    Context = 48643,
}
pub const GST_QUERY_UNKNOWN: GstQueryType = GstQueryType::Unknown;
pub const GST_QUERY_POSITION: GstQueryType = GstQueryType::Position;
pub const GST_QUERY_DURATION: GstQueryType = GstQueryType::Duration;
pub const GST_QUERY_LATENCY: GstQueryType = GstQueryType::Latency;
pub const GST_QUERY_JITTER: GstQueryType = GstQueryType::Jitter;
pub const GST_QUERY_RATE: GstQueryType = GstQueryType::Rate;
pub const GST_QUERY_SEEKING: GstQueryType = GstQueryType::Seeking;
pub const GST_QUERY_SEGMENT: GstQueryType = GstQueryType::Segment;
pub const GST_QUERY_CONVERT: GstQueryType = GstQueryType::Convert;
pub const GST_QUERY_FORMATS: GstQueryType = GstQueryType::Formats;
pub const GST_QUERY_BUFFERING: GstQueryType = GstQueryType::Buffering;
pub const GST_QUERY_CUSTOM: GstQueryType = GstQueryType::Custom;
pub const GST_QUERY_URI: GstQueryType = GstQueryType::Uri;
pub const GST_QUERY_ALLOCATION: GstQueryType = GstQueryType::Allocation;
pub const GST_QUERY_SCHEDULING: GstQueryType = GstQueryType::Scheduling;
pub const GST_QUERY_ACCEPT_CAPS: GstQueryType = GstQueryType::AcceptCaps;
pub const GST_QUERY_CAPS: GstQueryType = GstQueryType::Caps;
pub const GST_QUERY_DRAIN: GstQueryType = GstQueryType::Drain;
pub const GST_QUERY_CONTEXT: GstQueryType = GstQueryType::Context;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstRank {
    None = 0,
    Marginal = 64,
    Secondary = 128,
    Primary = 256,
}
pub const GST_RANK_NONE: GstRank = GstRank::None;
pub const GST_RANK_MARGINAL: GstRank = GstRank::Marginal;
pub const GST_RANK_SECONDARY: GstRank = GstRank::Secondary;
pub const GST_RANK_PRIMARY: GstRank = GstRank::Primary;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstResourceError {
    Failed = 1,
    TooLazy = 2,
    NotFound = 3,
    Busy = 4,
    OpenRead = 5,
    OpenWrite = 6,
    OpenReadWrite = 7,
    Close = 8,
    Read = 9,
    Write = 10,
    Seek = 11,
    Sync = 12,
    Settings = 13,
    NoSpaceLeft = 14,
    NotAuthorized = 15,
    NumErrors = 16,
}
pub const GST_RESOURCE_ERROR_FAILED: GstResourceError = GstResourceError::Failed;
pub const GST_RESOURCE_ERROR_TOO_LAZY: GstResourceError = GstResourceError::TooLazy;
pub const GST_RESOURCE_ERROR_NOT_FOUND: GstResourceError = GstResourceError::NotFound;
pub const GST_RESOURCE_ERROR_BUSY: GstResourceError = GstResourceError::Busy;
pub const GST_RESOURCE_ERROR_OPEN_READ: GstResourceError = GstResourceError::OpenRead;
pub const GST_RESOURCE_ERROR_OPEN_WRITE: GstResourceError = GstResourceError::OpenWrite;
pub const GST_RESOURCE_ERROR_OPEN_READ_WRITE: GstResourceError = GstResourceError::OpenReadWrite;
pub const GST_RESOURCE_ERROR_CLOSE: GstResourceError = GstResourceError::Close;
pub const GST_RESOURCE_ERROR_READ: GstResourceError = GstResourceError::Read;
pub const GST_RESOURCE_ERROR_WRITE: GstResourceError = GstResourceError::Write;
pub const GST_RESOURCE_ERROR_SEEK: GstResourceError = GstResourceError::Seek;
pub const GST_RESOURCE_ERROR_SYNC: GstResourceError = GstResourceError::Sync;
pub const GST_RESOURCE_ERROR_SETTINGS: GstResourceError = GstResourceError::Settings;
pub const GST_RESOURCE_ERROR_NO_SPACE_LEFT: GstResourceError = GstResourceError::NoSpaceLeft;
pub const GST_RESOURCE_ERROR_NOT_AUTHORIZED: GstResourceError = GstResourceError::NotAuthorized;
pub const GST_RESOURCE_ERROR_NUM_ERRORS: GstResourceError = GstResourceError::NumErrors;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstSearchMode {
    Exact = 0,
    Before = 1,
    After = 2,
}
pub const GST_SEARCH_MODE_EXACT: GstSearchMode = GstSearchMode::Exact;
pub const GST_SEARCH_MODE_BEFORE: GstSearchMode = GstSearchMode::Before;
pub const GST_SEARCH_MODE_AFTER: GstSearchMode = GstSearchMode::After;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstSeekType {
    None = 0,
    Set = 1,
    End = 2,
}
pub const GST_SEEK_TYPE_NONE: GstSeekType = GstSeekType::None;
pub const GST_SEEK_TYPE_SET: GstSeekType = GstSeekType::Set;
pub const GST_SEEK_TYPE_END: GstSeekType = GstSeekType::End;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstState {
    VoidPending = 0,
    Null = 1,
    Ready = 2,
    Paused = 3,
    Playing = 4,
}
pub const GST_STATE_VOID_PENDING: GstState = GstState::VoidPending;
pub const GST_STATE_NULL: GstState = GstState::Null;
pub const GST_STATE_READY: GstState = GstState::Ready;
pub const GST_STATE_PAUSED: GstState = GstState::Paused;
pub const GST_STATE_PLAYING: GstState = GstState::Playing;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstStateChange {
    NullToReady = 10,
    ReadyToPaused = 19,
    PausedToPlaying = 28,
    PlayingToPaused = 35,
    PausedToReady = 26,
    ReadyToNull = 17,
}
pub const GST_STATE_CHANGE_NULL_TO_READY: GstStateChange = GstStateChange::NullToReady;
pub const GST_STATE_CHANGE_READY_TO_PAUSED: GstStateChange = GstStateChange::ReadyToPaused;
pub const GST_STATE_CHANGE_PAUSED_TO_PLAYING: GstStateChange = GstStateChange::PausedToPlaying;
pub const GST_STATE_CHANGE_PLAYING_TO_PAUSED: GstStateChange = GstStateChange::PlayingToPaused;
pub const GST_STATE_CHANGE_PAUSED_TO_READY: GstStateChange = GstStateChange::PausedToReady;
pub const GST_STATE_CHANGE_READY_TO_NULL: GstStateChange = GstStateChange::ReadyToNull;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstStateChangeReturn {
    Failure = 0,
    Success = 1,
    Async = 2,
    NoPreroll = 3,
}
pub const GST_STATE_CHANGE_FAILURE: GstStateChangeReturn = GstStateChangeReturn::Failure;
pub const GST_STATE_CHANGE_SUCCESS: GstStateChangeReturn = GstStateChangeReturn::Success;
pub const GST_STATE_CHANGE_ASYNC: GstStateChangeReturn = GstStateChangeReturn::Async;
pub const GST_STATE_CHANGE_NO_PREROLL: GstStateChangeReturn = GstStateChangeReturn::NoPreroll;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstStreamError {
    Failed = 1,
    TooLazy = 2,
    NotImplemented = 3,
    TypeNotFound = 4,
    WrongType = 5,
    CodecNotFound = 6,
    Decode = 7,
    Encode = 8,
    Demux = 9,
    Mux = 10,
    Format = 11,
    Decrypt = 12,
    DecryptNokey = 13,
    NumErrors = 14,
}
pub const GST_STREAM_ERROR_FAILED: GstStreamError = GstStreamError::Failed;
pub const GST_STREAM_ERROR_TOO_LAZY: GstStreamError = GstStreamError::TooLazy;
pub const GST_STREAM_ERROR_NOT_IMPLEMENTED: GstStreamError = GstStreamError::NotImplemented;
pub const GST_STREAM_ERROR_TYPE_NOT_FOUND: GstStreamError = GstStreamError::TypeNotFound;
pub const GST_STREAM_ERROR_WRONG_TYPE: GstStreamError = GstStreamError::WrongType;
pub const GST_STREAM_ERROR_CODEC_NOT_FOUND: GstStreamError = GstStreamError::CodecNotFound;
pub const GST_STREAM_ERROR_DECODE: GstStreamError = GstStreamError::Decode;
pub const GST_STREAM_ERROR_ENCODE: GstStreamError = GstStreamError::Encode;
pub const GST_STREAM_ERROR_DEMUX: GstStreamError = GstStreamError::Demux;
pub const GST_STREAM_ERROR_MUX: GstStreamError = GstStreamError::Mux;
pub const GST_STREAM_ERROR_FORMAT: GstStreamError = GstStreamError::Format;
pub const GST_STREAM_ERROR_DECRYPT: GstStreamError = GstStreamError::Decrypt;
pub const GST_STREAM_ERROR_DECRYPT_NOKEY: GstStreamError = GstStreamError::DecryptNokey;
pub const GST_STREAM_ERROR_NUM_ERRORS: GstStreamError = GstStreamError::NumErrors;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstStreamStatusType {
    Create = 0,
    Enter = 1,
    Leave = 2,
    Destroy = 3,
    Start = 8,
    Pause = 9,
    Stop = 10,
}
pub const GST_STREAM_STATUS_TYPE_CREATE: GstStreamStatusType = GstStreamStatusType::Create;
pub const GST_STREAM_STATUS_TYPE_ENTER: GstStreamStatusType = GstStreamStatusType::Enter;
pub const GST_STREAM_STATUS_TYPE_LEAVE: GstStreamStatusType = GstStreamStatusType::Leave;
pub const GST_STREAM_STATUS_TYPE_DESTROY: GstStreamStatusType = GstStreamStatusType::Destroy;
pub const GST_STREAM_STATUS_TYPE_START: GstStreamStatusType = GstStreamStatusType::Start;
pub const GST_STREAM_STATUS_TYPE_PAUSE: GstStreamStatusType = GstStreamStatusType::Pause;
pub const GST_STREAM_STATUS_TYPE_STOP: GstStreamStatusType = GstStreamStatusType::Stop;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstStructureChangeType {
    Link = 0,
    Unlink = 1,
}
pub const GST_STRUCTURE_CHANGE_TYPE_PAD_LINK: GstStructureChangeType = GstStructureChangeType::Link;
pub const GST_STRUCTURE_CHANGE_TYPE_PAD_UNLINK: GstStructureChangeType = GstStructureChangeType::Unlink;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstTagFlag {
    Undefined = 0,
    Meta = 1,
    Encoded = 2,
    Decoded = 3,
    Count = 4,
}
pub const GST_TAG_FLAG_UNDEFINED: GstTagFlag = GstTagFlag::Undefined;
pub const GST_TAG_FLAG_META: GstTagFlag = GstTagFlag::Meta;
pub const GST_TAG_FLAG_ENCODED: GstTagFlag = GstTagFlag::Encoded;
pub const GST_TAG_FLAG_DECODED: GstTagFlag = GstTagFlag::Decoded;
pub const GST_TAG_FLAG_COUNT: GstTagFlag = GstTagFlag::Count;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstTagMergeMode {
    Undefined = 0,
    ReplaceAll = 1,
    Replace = 2,
    Append = 3,
    Prepend = 4,
    Keep = 5,
    KeepAll = 6,
    Count = 7,
}
pub const GST_TAG_MERGE_UNDEFINED: GstTagMergeMode = GstTagMergeMode::Undefined;
pub const GST_TAG_MERGE_REPLACE_ALL: GstTagMergeMode = GstTagMergeMode::ReplaceAll;
pub const GST_TAG_MERGE_REPLACE: GstTagMergeMode = GstTagMergeMode::Replace;
pub const GST_TAG_MERGE_APPEND: GstTagMergeMode = GstTagMergeMode::Append;
pub const GST_TAG_MERGE_PREPEND: GstTagMergeMode = GstTagMergeMode::Prepend;
pub const GST_TAG_MERGE_KEEP: GstTagMergeMode = GstTagMergeMode::Keep;
pub const GST_TAG_MERGE_KEEP_ALL: GstTagMergeMode = GstTagMergeMode::KeepAll;
pub const GST_TAG_MERGE_COUNT: GstTagMergeMode = GstTagMergeMode::Count;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstTagScope {
    Stream = 0,
    Global = 1,
}
pub const GST_TAG_SCOPE_STREAM: GstTagScope = GstTagScope::Stream;
pub const GST_TAG_SCOPE_GLOBAL: GstTagScope = GstTagScope::Global;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstTaskState {
    Started = 0,
    Stopped = 1,
    Paused = 2,
}
pub const GST_TASK_STARTED: GstTaskState = GstTaskState::Started;
pub const GST_TASK_STOPPED: GstTaskState = GstTaskState::Stopped;
pub const GST_TASK_PAUSED: GstTaskState = GstTaskState::Paused;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstTocEntryType {
    Angle = -3,
    Version = -2,
    Edition = -1,
    Invalid = 0,
    Title = 1,
    Track = 2,
    Chapter = 3,
}
pub const GST_TOC_ENTRY_TYPE_ANGLE: GstTocEntryType = GstTocEntryType::Angle;
pub const GST_TOC_ENTRY_TYPE_VERSION: GstTocEntryType = GstTocEntryType::Version;
pub const GST_TOC_ENTRY_TYPE_EDITION: GstTocEntryType = GstTocEntryType::Edition;
pub const GST_TOC_ENTRY_TYPE_INVALID: GstTocEntryType = GstTocEntryType::Invalid;
pub const GST_TOC_ENTRY_TYPE_TITLE: GstTocEntryType = GstTocEntryType::Title;
pub const GST_TOC_ENTRY_TYPE_TRACK: GstTocEntryType = GstTocEntryType::Track;
pub const GST_TOC_ENTRY_TYPE_CHAPTER: GstTocEntryType = GstTocEntryType::Chapter;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstTocLoopType {
    None = 0,
    Forward = 1,
    Reverse = 2,
    PingPong = 3,
}
pub const GST_TOC_LOOP_NONE: GstTocLoopType = GstTocLoopType::None;
pub const GST_TOC_LOOP_FORWARD: GstTocLoopType = GstTocLoopType::Forward;
pub const GST_TOC_LOOP_REVERSE: GstTocLoopType = GstTocLoopType::Reverse;
pub const GST_TOC_LOOP_PING_PONG: GstTocLoopType = GstTocLoopType::PingPong;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstTocScope {
    Global = 1,
    Current = 2,
}
pub const GST_TOC_SCOPE_GLOBAL: GstTocScope = GstTocScope::Global;
pub const GST_TOC_SCOPE_CURRENT: GstTocScope = GstTocScope::Current;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstTracerValueScope {
    Process = 0,
    Thread = 1,
    Element = 2,
    Pad = 3,
}
pub const GST_TRACER_VALUE_SCOPE_PROCESS: GstTracerValueScope = GstTracerValueScope::Process;
pub const GST_TRACER_VALUE_SCOPE_THREAD: GstTracerValueScope = GstTracerValueScope::Thread;
pub const GST_TRACER_VALUE_SCOPE_ELEMENT: GstTracerValueScope = GstTracerValueScope::Element;
pub const GST_TRACER_VALUE_SCOPE_PAD: GstTracerValueScope = GstTracerValueScope::Pad;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstTypeFindProbability {
    None = 0,
    Minimum = 1,
    Possible = 50,
    Likely = 80,
    NearlyCertain = 99,
    Maximum = 100,
}
pub const GST_TYPE_FIND_NONE: GstTypeFindProbability = GstTypeFindProbability::None;
pub const GST_TYPE_FIND_MINIMUM: GstTypeFindProbability = GstTypeFindProbability::Minimum;
pub const GST_TYPE_FIND_POSSIBLE: GstTypeFindProbability = GstTypeFindProbability::Possible;
pub const GST_TYPE_FIND_LIKELY: GstTypeFindProbability = GstTypeFindProbability::Likely;
pub const GST_TYPE_FIND_NEARLY_CERTAIN: GstTypeFindProbability = GstTypeFindProbability::NearlyCertain;
pub const GST_TYPE_FIND_MAXIMUM: GstTypeFindProbability = GstTypeFindProbability::Maximum;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstURIError {
    UnsupportedProtocol = 0,
    BadUri = 1,
    BadState = 2,
    BadReference = 3,
}
pub const GST_URI_ERROR_UNSUPPORTED_PROTOCOL: GstURIError = GstURIError::UnsupportedProtocol;
pub const GST_URI_ERROR_BAD_URI: GstURIError = GstURIError::BadUri;
pub const GST_URI_ERROR_BAD_STATE: GstURIError = GstURIError::BadState;
pub const GST_URI_ERROR_BAD_REFERENCE: GstURIError = GstURIError::BadReference;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstURIType {
    Unknown = 0,
    Sink = 1,
    Src = 2,
}
pub const GST_URI_UNKNOWN: GstURIType = GstURIType::Unknown;
pub const GST_URI_SINK: GstURIType = GstURIType::Sink;
pub const GST_URI_SRC: GstURIType = GstURIType::Src;

// Constants
pub const GST_ALLOCATOR_SYSMEM: *const c_char = b"SystemMemory\0" as *const u8 as *const c_char;
pub const GST_BUFFER_COPY_ALL: GstBufferCopyFlags = GstBufferCopyFlags { bits: 15 };
pub const GST_BUFFER_COPY_METADATA: GstBufferCopyFlags = GstBufferCopyFlags { bits: 7 };
pub const GST_BUFFER_OFFSET_NONE: u64 = 18446744073709551615;
pub const GST_CAN_INLINE: c_int = 1;
pub const GST_CAPS_FEATURE_MEMORY_SYSTEM_MEMORY: *const c_char = b"memory:SystemMemory\0" as *const u8 as *const c_char;
pub const GST_CLOCK_TIME_NONE: GstClockTime = 18446744073709551615;
pub const GST_DEBUG_BG_MASK: c_int = 240;
pub const GST_DEBUG_FG_MASK: c_int = 15;
pub const GST_DEBUG_FORMAT_MASK: c_int = 65280;
pub const GST_ELEMENT_FACTORY_KLASS_DECODER: *const c_char = b"Decoder\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_DECRYPTOR: *const c_char = b"Decryptor\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_DEMUXER: *const c_char = b"Demuxer\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_DEPAYLOADER: *const c_char = b"Depayloader\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_ENCODER: *const c_char = b"Encoder\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_ENCRYPTOR: *const c_char = b"Encryptor\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_FORMATTER: *const c_char = b"Formatter\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_AUDIO: *const c_char = b"Audio\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_IMAGE: *const c_char = b"Image\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_METADATA: *const c_char = b"Metadata\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_SUBTITLE: *const c_char = b"Subtitle\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_VIDEO: *const c_char = b"Video\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_MUXER: *const c_char = b"Muxer\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_PARSER: *const c_char = b"Parser\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_PAYLOADER: *const c_char = b"Payloader\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_SINK: *const c_char = b"Sink\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_SRC: *const c_char = b"Source\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_TYPE_ANY: GstElementFactoryListType = 562949953421311;
pub const GST_ELEMENT_FACTORY_TYPE_AUDIOVIDEO_SINKS: GstElementFactoryListType = 3940649673949188;
pub const GST_ELEMENT_FACTORY_TYPE_AUDIO_ENCODER: GstElementFactoryListType = 1125899906842626;
pub const GST_ELEMENT_FACTORY_TYPE_DECODABLE: GstElementFactoryListType = 353;
pub const GST_ELEMENT_FACTORY_TYPE_DECODER: GstElementFactoryListType = 1;
pub const GST_ELEMENT_FACTORY_TYPE_DECRYPTOR: GstElementFactoryListType = 1024;
pub const GST_ELEMENT_FACTORY_TYPE_DEMUXER: GstElementFactoryListType = 32;
pub const GST_ELEMENT_FACTORY_TYPE_DEPAYLOADER: GstElementFactoryListType = 256;
pub const GST_ELEMENT_FACTORY_TYPE_ENCODER: GstElementFactoryListType = 2;
pub const GST_ELEMENT_FACTORY_TYPE_ENCRYPTOR: GstElementFactoryListType = 2048;
pub const GST_ELEMENT_FACTORY_TYPE_FORMATTER: GstElementFactoryListType = 512;
pub const GST_ELEMENT_FACTORY_TYPE_MAX_ELEMENTS: GstElementFactoryListType = 281474976710656;
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_ANY: GstElementFactoryListType = 18446462598732840960;
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO: GstElementFactoryListType = 1125899906842624;
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE: GstElementFactoryListType = 2251799813685248;
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_METADATA: GstElementFactoryListType = 9007199254740992;
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_SUBTITLE: GstElementFactoryListType = 4503599627370496;
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO: GstElementFactoryListType = 562949953421312;
pub const GST_ELEMENT_FACTORY_TYPE_MUXER: GstElementFactoryListType = 16;
pub const GST_ELEMENT_FACTORY_TYPE_PARSER: GstElementFactoryListType = 64;
pub const GST_ELEMENT_FACTORY_TYPE_PAYLOADER: GstElementFactoryListType = 128;
pub const GST_ELEMENT_FACTORY_TYPE_SINK: GstElementFactoryListType = 4;
pub const GST_ELEMENT_FACTORY_TYPE_SRC: GstElementFactoryListType = 8;
pub const GST_ELEMENT_FACTORY_TYPE_VIDEO_ENCODER: GstElementFactoryListType = 2814749767106562;
pub const GST_ELEMENT_METADATA_AUTHOR: *const c_char = b"author\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_METADATA_DESCRIPTION: *const c_char = b"description\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_METADATA_DOC_URI: *const c_char = b"doc-uri\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_METADATA_ICON_NAME: *const c_char = b"icon-name\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_METADATA_KLASS: *const c_char = b"klass\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_METADATA_LONGNAME: *const c_char = b"long-name\0" as *const u8 as *const c_char;
pub const GST_ERROR_SYSTEM: *const c_char = b"system error: %s\0" as *const u8 as *const c_char;
pub const GST_EVENT_NUM_SHIFT: c_int = 8;
pub const GST_EVENT_TYPE_BOTH: GstEventTypeFlags = GstEventTypeFlags { bits: 3 };
pub const GST_FLAG_SET_MASK_EXACT: c_uint = 4294967295;
pub const GST_FORMAT_PERCENT_MAX: i64 = 1000000;
pub const GST_FORMAT_PERCENT_SCALE: i64 = 10000;
pub const GST_FOURCC_FORMAT: *const c_char = b"c%c%c%c\0" as *const u8 as *const c_char;
pub const GST_LICENSE_UNKNOWN: *const c_char = b"unknown\0" as *const u8 as *const c_char;
pub const GST_LOCK_FLAG_READWRITE: GstLockFlags = GstLockFlags { bits: 3 };
pub const GST_MAP_READWRITE: GstMapFlags = GstMapFlags { bits: 3 };
pub const GST_META_TAG_MEMORY_STR: *const c_char = b"memory\0" as *const u8 as *const c_char;
pub const GST_MSECOND: GstClockTimeDiff = 1000000;
pub const GST_NSECOND: GstClockTimeDiff = 1;
pub const GST_PARAM_CONTROLLABLE: c_int = 2;
pub const GST_PARAM_MUTABLE_PAUSED: c_int = 8;
pub const GST_PARAM_MUTABLE_PLAYING: c_int = 16;
pub const GST_PARAM_MUTABLE_READY: c_int = 4;
pub const GST_PARAM_USER_SHIFT: c_int = 256;
pub const GST_PROTECTION_SYSTEM_ID_CAPS_FIELD: *const c_char = b"protection-system\0" as *const u8 as *const c_char;
pub const GST_PTR_FORMAT: *const c_char = b"paA\0" as *const u8 as *const c_char;
pub const GST_QUERY_NUM_SHIFT: c_int = 8;
pub const GST_QUERY_TYPE_BOTH: GstQueryTypeFlags = GstQueryTypeFlags { bits: 3 };
pub const GST_SECOND: GstClockTimeDiff = 1000000000;
pub const GST_SEGMENT_FORMAT: *const c_char = b"paB\0" as *const u8 as *const c_char;
pub const GST_STIME_FORMAT: *const c_char = b"c%\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM: *const c_char = b"album\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_ARTIST: *const c_char = b"album-artist\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_ARTIST_SORTNAME: *const c_char = b"album-artist-sortname\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_GAIN: *const c_char = b"replaygain-album-gain\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_PEAK: *const c_char = b"replaygain-album-peak\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_SORTNAME: *const c_char = b"album-sortname\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_VOLUME_COUNT: *const c_char = b"album-disc-count\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_VOLUME_NUMBER: *const c_char = b"album-disc-number\0" as *const u8 as *const c_char;
pub const GST_TAG_APPLICATION_DATA: *const c_char = b"application-data\0" as *const u8 as *const c_char;
pub const GST_TAG_APPLICATION_NAME: *const c_char = b"application-name\0" as *const u8 as *const c_char;
pub const GST_TAG_ARTIST: *const c_char = b"artist\0" as *const u8 as *const c_char;
pub const GST_TAG_ARTIST_SORTNAME: *const c_char = b"artist-sortname\0" as *const u8 as *const c_char;
pub const GST_TAG_ATTACHMENT: *const c_char = b"attachment\0" as *const u8 as *const c_char;
pub const GST_TAG_AUDIO_CODEC: *const c_char = b"audio-codec\0" as *const u8 as *const c_char;
pub const GST_TAG_BEATS_PER_MINUTE: *const c_char = b"beats-per-minute\0" as *const u8 as *const c_char;
pub const GST_TAG_BITRATE: *const c_char = b"bitrate\0" as *const u8 as *const c_char;
pub const GST_TAG_CODEC: *const c_char = b"codec\0" as *const u8 as *const c_char;
pub const GST_TAG_COMMENT: *const c_char = b"comment\0" as *const u8 as *const c_char;
pub const GST_TAG_COMPOSER: *const c_char = b"composer\0" as *const u8 as *const c_char;
pub const GST_TAG_COMPOSER_SORTNAME: *const c_char = b"composer-sortname\0" as *const u8 as *const c_char;
pub const GST_TAG_CONDUCTOR: *const c_char = b"conductor\0" as *const u8 as *const c_char;
pub const GST_TAG_CONTACT: *const c_char = b"contact\0" as *const u8 as *const c_char;
pub const GST_TAG_CONTAINER_FORMAT: *const c_char = b"container-format\0" as *const u8 as *const c_char;
pub const GST_TAG_COPYRIGHT: *const c_char = b"copyright\0" as *const u8 as *const c_char;
pub const GST_TAG_COPYRIGHT_URI: *const c_char = b"copyright-uri\0" as *const u8 as *const c_char;
pub const GST_TAG_DATE: *const c_char = b"date\0" as *const u8 as *const c_char;
pub const GST_TAG_DATE_TIME: *const c_char = b"datetime\0" as *const u8 as *const c_char;
pub const GST_TAG_DESCRIPTION: *const c_char = b"description\0" as *const u8 as *const c_char;
pub const GST_TAG_DEVICE_MANUFACTURER: *const c_char = b"device-manufacturer\0" as *const u8 as *const c_char;
pub const GST_TAG_DEVICE_MODEL: *const c_char = b"device-model\0" as *const u8 as *const c_char;
pub const GST_TAG_DURATION: *const c_char = b"duration\0" as *const u8 as *const c_char;
pub const GST_TAG_ENCODED_BY: *const c_char = b"encoded-by\0" as *const u8 as *const c_char;
pub const GST_TAG_ENCODER: *const c_char = b"encoder\0" as *const u8 as *const c_char;
pub const GST_TAG_ENCODER_VERSION: *const c_char = b"encoder-version\0" as *const u8 as *const c_char;
pub const GST_TAG_EXTENDED_COMMENT: *const c_char = b"extended-comment\0" as *const u8 as *const c_char;
pub const GST_TAG_GENRE: *const c_char = b"genre\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_CAPTURE_DIRECTION: *const c_char = b"geo-location-capture-direction\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_CITY: *const c_char = b"geo-location-city\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_COUNTRY: *const c_char = b"geo-location-country\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_ELEVATION: *const c_char = b"geo-location-elevation\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_HORIZONTAL_ERROR: *const c_char = b"geo-location-horizontal-error\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_LATITUDE: *const c_char = b"geo-location-latitude\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_LONGITUDE: *const c_char = b"geo-location-longitude\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_MOVEMENT_DIRECTION: *const c_char = b"geo-location-movement-direction\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_MOVEMENT_SPEED: *const c_char = b"geo-location-movement-speed\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_NAME: *const c_char = b"geo-location-name\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_SUBLOCATION: *const c_char = b"geo-location-sublocation\0" as *const u8 as *const c_char;
pub const GST_TAG_GROUPING: *const c_char = b"grouping\0" as *const u8 as *const c_char;
pub const GST_TAG_HOMEPAGE: *const c_char = b"homepage\0" as *const u8 as *const c_char;
pub const GST_TAG_IMAGE: *const c_char = b"image\0" as *const u8 as *const c_char;
pub const GST_TAG_IMAGE_ORIENTATION: *const c_char = b"image-orientation\0" as *const u8 as *const c_char;
pub const GST_TAG_INTERPRETED_BY: *const c_char = b"interpreted-by\0" as *const u8 as *const c_char;
pub const GST_TAG_ISRC: *const c_char = b"isrc\0" as *const u8 as *const c_char;
pub const GST_TAG_KEYWORDS: *const c_char = b"keywords\0" as *const u8 as *const c_char;
pub const GST_TAG_LANGUAGE_CODE: *const c_char = b"language-code\0" as *const u8 as *const c_char;
pub const GST_TAG_LANGUAGE_NAME: *const c_char = b"language-name\0" as *const u8 as *const c_char;
pub const GST_TAG_LICENSE: *const c_char = b"license\0" as *const u8 as *const c_char;
pub const GST_TAG_LICENSE_URI: *const c_char = b"license-uri\0" as *const u8 as *const c_char;
pub const GST_TAG_LOCATION: *const c_char = b"location\0" as *const u8 as *const c_char;
pub const GST_TAG_LYRICS: *const c_char = b"lyrics\0" as *const u8 as *const c_char;
pub const GST_TAG_MAXIMUM_BITRATE: *const c_char = b"maximum-bitrate\0" as *const u8 as *const c_char;
pub const GST_TAG_MIDI_BASE_NOTE: *const c_char = b"midi-base-note\0" as *const u8 as *const c_char;
pub const GST_TAG_MINIMUM_BITRATE: *const c_char = b"minimum-bitrate\0" as *const u8 as *const c_char;
pub const GST_TAG_NOMINAL_BITRATE: *const c_char = b"nominal-bitrate\0" as *const u8 as *const c_char;
pub const GST_TAG_ORGANIZATION: *const c_char = b"organization\0" as *const u8 as *const c_char;
pub const GST_TAG_PERFORMER: *const c_char = b"performer\0" as *const u8 as *const c_char;
pub const GST_TAG_PREVIEW_IMAGE: *const c_char = b"preview-image\0" as *const u8 as *const c_char;
pub const GST_TAG_PRIVATE_DATA: *const c_char = b"private-data\0" as *const u8 as *const c_char;
pub const GST_TAG_PUBLISHER: *const c_char = b"publisher\0" as *const u8 as *const c_char;
pub const GST_TAG_REFERENCE_LEVEL: *const c_char = b"replaygain-reference-level\0" as *const u8 as *const c_char;
pub const GST_TAG_SERIAL: *const c_char = b"serial\0" as *const u8 as *const c_char;
pub const GST_TAG_SHOW_EPISODE_NUMBER: *const c_char = b"show-episode-number\0" as *const u8 as *const c_char;
pub const GST_TAG_SHOW_NAME: *const c_char = b"show-name\0" as *const u8 as *const c_char;
pub const GST_TAG_SHOW_SEASON_NUMBER: *const c_char = b"show-season-number\0" as *const u8 as *const c_char;
pub const GST_TAG_SHOW_SORTNAME: *const c_char = b"show-sortname\0" as *const u8 as *const c_char;
pub const GST_TAG_SUBTITLE_CODEC: *const c_char = b"subtitle-codec\0" as *const u8 as *const c_char;
pub const GST_TAG_TITLE: *const c_char = b"title\0" as *const u8 as *const c_char;
pub const GST_TAG_TITLE_SORTNAME: *const c_char = b"title-sortname\0" as *const u8 as *const c_char;
pub const GST_TAG_TRACK_COUNT: *const c_char = b"track-count\0" as *const u8 as *const c_char;
pub const GST_TAG_TRACK_GAIN: *const c_char = b"replaygain-track-gain\0" as *const u8 as *const c_char;
pub const GST_TAG_TRACK_NUMBER: *const c_char = b"track-number\0" as *const u8 as *const c_char;
pub const GST_TAG_TRACK_PEAK: *const c_char = b"replaygain-track-peak\0" as *const u8 as *const c_char;
pub const GST_TAG_USER_RATING: *const c_char = b"user-rating\0" as *const u8 as *const c_char;
pub const GST_TAG_VERSION: *const c_char = b"version\0" as *const u8 as *const c_char;
pub const GST_TAG_VIDEO_CODEC: *const c_char = b"video-codec\0" as *const u8 as *const c_char;
pub const GST_TIME_FORMAT: *const c_char = b"u:%02u:%02u.%09u\0" as *const u8 as *const c_char;
pub const GST_TOC_REPEAT_COUNT_INFINITE: c_int = -1;
pub const GST_URI_NO_PORT: c_int = 0;
pub const GST_USECOND: GstClockTimeDiff = 1000;
pub const GST_VALUE_EQUAL: c_int = 0;
pub const GST_VALUE_GREATER_THAN: c_int = 1;
pub const GST_VALUE_LESS_THAN: c_int = -1;
pub const GST_VALUE_UNORDERED: c_int = 2;
pub const GST_VERSION_MAJOR: c_int = 1;
pub const GST_VERSION_MICRO: c_int = 0;
pub const GST_VERSION_MINOR: c_int = 12;
pub const GST_VERSION_NANO: c_int = 0;

// Flags
bitflags! {
    #[repr(C)]
    pub flags GstAllocatorFlags: c_uint {
        const GST_ALLOCATOR_FLAG_CUSTOM_ALLOC = 16,
        const GST_ALLOCATOR_FLAG_LAST = 1048576,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstBinFlags: c_uint {
        const GST_BIN_FLAG_NO_RESYNC = 16384,
        const GST_BIN_FLAG_STREAMS_AWARE = 32768,
        const GST_BIN_FLAG_LAST = 524288,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstBufferCopyFlags: c_uint {
        const GST_BUFFER_COPY_NONE = 0,
        const GST_BUFFER_COPY_FLAGS = 1,
        const GST_BUFFER_COPY_TIMESTAMPS = 2,
        const GST_BUFFER_COPY_META = 4,
        const GST_BUFFER_COPY_MEMORY = 8,
        const GST_BUFFER_COPY_MERGE = 16,
        const GST_BUFFER_COPY_DEEP = 32,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstBufferFlags: c_uint {
        const GST_BUFFER_FLAG_LIVE = 16,
        const GST_BUFFER_FLAG_DECODE_ONLY = 32,
        const GST_BUFFER_FLAG_DISCONT = 64,
        const GST_BUFFER_FLAG_RESYNC = 128,
        const GST_BUFFER_FLAG_CORRUPTED = 256,
        const GST_BUFFER_FLAG_MARKER = 512,
        const GST_BUFFER_FLAG_HEADER = 1024,
        const GST_BUFFER_FLAG_GAP = 2048,
        const GST_BUFFER_FLAG_DROPPABLE = 4096,
        const GST_BUFFER_FLAG_DELTA_UNIT = 8192,
        const GST_BUFFER_FLAG_TAG_MEMORY = 16384,
        const GST_BUFFER_FLAG_SYNC_AFTER = 32768,
        const GST_BUFFER_FLAG_LAST = 1048576,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstBufferPoolAcquireFlags: c_uint {
        const GST_BUFFER_POOL_ACQUIRE_FLAG_NONE = 0,
        const GST_BUFFER_POOL_ACQUIRE_FLAG_KEY_UNIT = 1,
        const GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT = 2,
        const GST_BUFFER_POOL_ACQUIRE_FLAG_DISCONT = 4,
        const GST_BUFFER_POOL_ACQUIRE_FLAG_LAST = 65536,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstBusFlags: c_uint {
        const GST_BUS_FLUSHING = 16,
        const GST_BUS_FLAG_LAST = 32,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstCapsFlags: c_uint {
        const GST_CAPS_FLAG_ANY = 16,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstClockFlags: c_uint {
        const GST_CLOCK_FLAG_CAN_DO_SINGLE_SYNC = 16,
        const GST_CLOCK_FLAG_CAN_DO_SINGLE_ASYNC = 32,
        const GST_CLOCK_FLAG_CAN_DO_PERIODIC_SYNC = 64,
        const GST_CLOCK_FLAG_CAN_DO_PERIODIC_ASYNC = 128,
        const GST_CLOCK_FLAG_CAN_SET_RESOLUTION = 256,
        const GST_CLOCK_FLAG_CAN_SET_MASTER = 512,
        const GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC = 1024,
        const GST_CLOCK_FLAG_LAST = 4096,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstDebugGraphDetails: c_uint {
        const GST_DEBUG_GRAPH_SHOW_MEDIA_TYPE = 1,
        const GST_DEBUG_GRAPH_SHOW_CAPS_DETAILS = 2,
        const GST_DEBUG_GRAPH_SHOW_NON_DEFAULT_PARAMS = 4,
        const GST_DEBUG_GRAPH_SHOW_STATES = 8,
        const GST_DEBUG_GRAPH_SHOW_FULL_PARAMS = 16,
        const GST_DEBUG_GRAPH_SHOW_ALL = 15,
        const GST_DEBUG_GRAPH_SHOW_VERBOSE = 4294967295,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstElementFlags: c_uint {
        const GST_ELEMENT_FLAG_LOCKED_STATE = 16,
        const GST_ELEMENT_FLAG_SINK = 32,
        const GST_ELEMENT_FLAG_SOURCE = 64,
        const GST_ELEMENT_FLAG_PROVIDE_CLOCK = 128,
        const GST_ELEMENT_FLAG_REQUIRE_CLOCK = 256,
        const GST_ELEMENT_FLAG_INDEXABLE = 512,
        const GST_ELEMENT_FLAG_LAST = 16384,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstEventTypeFlags: c_uint {
        const GST_EVENT_TYPE_UPSTREAM = 1,
        const GST_EVENT_TYPE_DOWNSTREAM = 2,
        const GST_EVENT_TYPE_SERIALIZED = 4,
        const GST_EVENT_TYPE_STICKY = 8,
        const GST_EVENT_TYPE_STICKY_MULTI = 16,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstLockFlags: c_uint {
        const GST_LOCK_FLAG_READ = 1,
        const GST_LOCK_FLAG_WRITE = 2,
        const GST_LOCK_FLAG_EXCLUSIVE = 4,
        const GST_LOCK_FLAG_LAST = 256,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstMapFlags: c_uint {
        const GST_MAP_READ = 1,
        const GST_MAP_WRITE = 2,
        const GST_MAP_FLAG_LAST = 65536,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstMemoryFlags: c_uint {
        const GST_MEMORY_FLAG_READONLY = 2,
        const GST_MEMORY_FLAG_NO_SHARE = 16,
        const GST_MEMORY_FLAG_ZERO_PREFIXED = 32,
        const GST_MEMORY_FLAG_ZERO_PADDED = 64,
        const GST_MEMORY_FLAG_PHYSICALLY_CONTIGUOUS = 128,
        const GST_MEMORY_FLAG_NOT_MAPPABLE = 256,
        const GST_MEMORY_FLAG_LAST = 1048576,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstMessageType: c_uint {
        const GST_MESSAGE_UNKNOWN = 0,
        const GST_MESSAGE_EOS = 1,
        const GST_MESSAGE_ERROR = 2,
        const GST_MESSAGE_WARNING = 4,
        const GST_MESSAGE_INFO = 8,
        const GST_MESSAGE_TAG = 16,
        const GST_MESSAGE_BUFFERING = 32,
        const GST_MESSAGE_STATE_CHANGED = 64,
        const GST_MESSAGE_STATE_DIRTY = 128,
        const GST_MESSAGE_STEP_DONE = 256,
        const GST_MESSAGE_CLOCK_PROVIDE = 512,
        const GST_MESSAGE_CLOCK_LOST = 1024,
        const GST_MESSAGE_NEW_CLOCK = 2048,
        const GST_MESSAGE_STRUCTURE_CHANGE = 4096,
        const GST_MESSAGE_STREAM_STATUS = 8192,
        const GST_MESSAGE_APPLICATION = 16384,
        const GST_MESSAGE_ELEMENT = 32768,
        const GST_MESSAGE_SEGMENT_START = 65536,
        const GST_MESSAGE_SEGMENT_DONE = 131072,
        const GST_MESSAGE_DURATION_CHANGED = 262144,
        const GST_MESSAGE_LATENCY = 524288,
        const GST_MESSAGE_ASYNC_START = 1048576,
        const GST_MESSAGE_ASYNC_DONE = 2097152,
        const GST_MESSAGE_REQUEST_STATE = 4194304,
        const GST_MESSAGE_STEP_START = 8388608,
        const GST_MESSAGE_QOS = 16777216,
        const GST_MESSAGE_PROGRESS = 33554432,
        const GST_MESSAGE_TOC = 67108864,
        const GST_MESSAGE_RESET_TIME = 134217728,
        const GST_MESSAGE_STREAM_START = 268435456,
        const GST_MESSAGE_NEED_CONTEXT = 536870912,
        const GST_MESSAGE_HAVE_CONTEXT = 1073741824,
        const GST_MESSAGE_EXTENDED = 2147483648,
        const GST_MESSAGE_DEVICE_ADDED = 2147483649,
        const GST_MESSAGE_DEVICE_REMOVED = 2147483650,
        const GST_MESSAGE_PROPERTY_NOTIFY = 2147483651,
        const GST_MESSAGE_STREAM_COLLECTION = 2147483652,
        const GST_MESSAGE_STREAMS_SELECTED = 2147483653,
        const GST_MESSAGE_REDIRECT = 2147483654,
        const GST_MESSAGE_ANY = 4294967295,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstMetaFlags: c_uint {
        const GST_META_FLAG_NONE = 0,
        const GST_META_FLAG_READONLY = 1,
        const GST_META_FLAG_POOLED = 2,
        const GST_META_FLAG_LOCKED = 4,
        const GST_META_FLAG_LAST = 65536,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstMiniObjectFlags: c_uint {
        const GST_MINI_OBJECT_FLAG_LOCKABLE = 1,
        const GST_MINI_OBJECT_FLAG_LOCK_READONLY = 2,
        const GST_MINI_OBJECT_FLAG_MAY_BE_LEAKED = 4,
        const GST_MINI_OBJECT_FLAG_LAST = 16,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstObjectFlags: c_uint {
        const GST_OBJECT_FLAG_MAY_BE_LEAKED = 1,
        const GST_OBJECT_FLAG_LAST = 16,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstPadFlags: c_uint {
        const GST_PAD_FLAG_BLOCKED = 16,
        const GST_PAD_FLAG_FLUSHING = 32,
        const GST_PAD_FLAG_EOS = 64,
        const GST_PAD_FLAG_BLOCKING = 128,
        const GST_PAD_FLAG_NEED_PARENT = 256,
        const GST_PAD_FLAG_NEED_RECONFIGURE = 512,
        const GST_PAD_FLAG_PENDING_EVENTS = 1024,
        const GST_PAD_FLAG_FIXED_CAPS = 2048,
        const GST_PAD_FLAG_PROXY_CAPS = 4096,
        const GST_PAD_FLAG_PROXY_ALLOCATION = 8192,
        const GST_PAD_FLAG_PROXY_SCHEDULING = 16384,
        const GST_PAD_FLAG_ACCEPT_INTERSECT = 32768,
        const GST_PAD_FLAG_ACCEPT_TEMPLATE = 65536,
        const GST_PAD_FLAG_LAST = 1048576,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstPadLinkCheck: c_uint {
        const GST_PAD_LINK_CHECK_NOTHING = 0,
        const GST_PAD_LINK_CHECK_HIERARCHY = 1,
        const GST_PAD_LINK_CHECK_TEMPLATE_CAPS = 2,
        const GST_PAD_LINK_CHECK_CAPS = 4,
        const GST_PAD_LINK_CHECK_NO_RECONFIGURE = 8,
        const GST_PAD_LINK_CHECK_DEFAULT = 5,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstPadProbeType: c_uint {
        const GST_PAD_PROBE_TYPE_INVALID = 0,
        const GST_PAD_PROBE_TYPE_IDLE = 1,
        const GST_PAD_PROBE_TYPE_BLOCK = 2,
        const GST_PAD_PROBE_TYPE_BUFFER = 16,
        const GST_PAD_PROBE_TYPE_BUFFER_LIST = 32,
        const GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM = 64,
        const GST_PAD_PROBE_TYPE_EVENT_UPSTREAM = 128,
        const GST_PAD_PROBE_TYPE_EVENT_FLUSH = 256,
        const GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM = 512,
        const GST_PAD_PROBE_TYPE_QUERY_UPSTREAM = 1024,
        const GST_PAD_PROBE_TYPE_PUSH = 4096,
        const GST_PAD_PROBE_TYPE_PULL = 8192,
        const GST_PAD_PROBE_TYPE_BLOCKING = 3,
        const GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM = 112,
        const GST_PAD_PROBE_TYPE_DATA_UPSTREAM = 128,
        const GST_PAD_PROBE_TYPE_DATA_BOTH = 240,
        const GST_PAD_PROBE_TYPE_BLOCK_DOWNSTREAM = 114,
        const GST_PAD_PROBE_TYPE_BLOCK_UPSTREAM = 130,
        const GST_PAD_PROBE_TYPE_EVENT_BOTH = 192,
        const GST_PAD_PROBE_TYPE_QUERY_BOTH = 1536,
        const GST_PAD_PROBE_TYPE_ALL_BOTH = 1776,
        const GST_PAD_PROBE_TYPE_SCHEDULING = 12288,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstPadTemplateFlags: c_uint {
        const GST_PAD_TEMPLATE_FLAG_LAST = 256,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstParseFlags: c_uint {
        const GST_PARSE_FLAG_NONE = 0,
        const GST_PARSE_FLAG_FATAL_ERRORS = 1,
        const GST_PARSE_FLAG_NO_SINGLE_ELEMENT_BINS = 2,
        const GST_PARSE_FLAG_PLACE_IN_BIN = 4,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstPipelineFlags: c_uint {
        const GST_PIPELINE_FLAG_FIXED_CLOCK = 524288,
        const GST_PIPELINE_FLAG_LAST = 8388608,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstPluginDependencyFlags: c_uint {
        const GST_PLUGIN_DEPENDENCY_FLAG_NONE = 0,
        const GST_PLUGIN_DEPENDENCY_FLAG_RECURSE = 1,
        const GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_DEFAULT_ONLY = 2,
        const GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_SUFFIX = 4,
        const GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_PREFIX = 8,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstPluginFlags: c_uint {
        const GST_PLUGIN_FLAG_CACHED = 16,
        const GST_PLUGIN_FLAG_BLACKLISTED = 32,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstQueryTypeFlags: c_uint {
        const GST_QUERY_TYPE_UPSTREAM = 1,
        const GST_QUERY_TYPE_DOWNSTREAM = 2,
        const GST_QUERY_TYPE_SERIALIZED = 4,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstSchedulingFlags: c_uint {
        const GST_SCHEDULING_FLAG_SEEKABLE = 1,
        const GST_SCHEDULING_FLAG_SEQUENTIAL = 2,
        const GST_SCHEDULING_FLAG_BANDWIDTH_LIMITED = 4,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstSeekFlags: c_uint {
        const GST_SEEK_FLAG_NONE = 0,
        const GST_SEEK_FLAG_FLUSH = 1,
        const GST_SEEK_FLAG_ACCURATE = 2,
        const GST_SEEK_FLAG_KEY_UNIT = 4,
        const GST_SEEK_FLAG_SEGMENT = 8,
        const GST_SEEK_FLAG_TRICKMODE = 16,
        const GST_SEEK_FLAG_SKIP = 16,
        const GST_SEEK_FLAG_SNAP_BEFORE = 32,
        const GST_SEEK_FLAG_SNAP_AFTER = 64,
        const GST_SEEK_FLAG_SNAP_NEAREST = 96,
        const GST_SEEK_FLAG_TRICKMODE_KEY_UNITS = 128,
        const GST_SEEK_FLAG_TRICKMODE_NO_AUDIO = 256,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstSegmentFlags: c_uint {
        const GST_SEGMENT_FLAG_NONE = 0,
        const GST_SEGMENT_FLAG_RESET = 1,
        const GST_SEGMENT_FLAG_TRICKMODE = 16,
        const GST_SEGMENT_FLAG_SKIP = 16,
        const GST_SEGMENT_FLAG_SEGMENT = 8,
        const GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS = 128,
        const GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO = 256,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstStackTraceFlags: c_uint {
        const GST_STACK_TRACE_SHOW_FULL = 1,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstStreamFlags: c_uint {
        const GST_STREAM_FLAG_NONE = 0,
        const GST_STREAM_FLAG_SPARSE = 1,
        const GST_STREAM_FLAG_SELECT = 2,
        const GST_STREAM_FLAG_UNSELECT = 4,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstStreamType: c_uint {
        const GST_STREAM_TYPE_UNKNOWN = 1,
        const GST_STREAM_TYPE_AUDIO = 2,
        const GST_STREAM_TYPE_VIDEO = 4,
        const GST_STREAM_TYPE_CONTAINER = 8,
        const GST_STREAM_TYPE_TEXT = 16,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstTracerValueFlags: c_uint {
        const GST_TRACER_VALUE_FLAGS_NONE = 0,
        const GST_TRACER_VALUE_FLAGS_OPTIONAL = 1,
        const GST_TRACER_VALUE_FLAGS_AGGREGATED = 2,
    }
}

// Callbacks
pub type GstBufferForeachMetaFunc = Option<unsafe extern "C" fn(*mut GstBuffer, *mut *mut GstMeta, gpointer) -> gboolean>;
pub type GstBufferListFunc = Option<unsafe extern "C" fn(*mut *mut GstBuffer, c_uint, gpointer) -> gboolean>;
pub type GstBusFunc = Option<unsafe extern "C" fn(*mut GstBus, *mut GstMessage, gpointer) -> gboolean>;
pub type GstBusSyncHandler = Option<unsafe extern "C" fn(*mut GstBus, *mut GstMessage, gpointer) -> GstBusSyncReply>;
pub type GstCapsFilterMapFunc = Option<unsafe extern "C" fn(*mut GstCapsFeatures, *mut GstStructure, gpointer) -> gboolean>;
pub type GstCapsForeachFunc = Option<unsafe extern "C" fn(*mut GstCapsFeatures, *mut GstStructure, gpointer) -> gboolean>;
pub type GstCapsMapFunc = Option<unsafe extern "C" fn(*mut GstCapsFeatures, *mut GstStructure, gpointer) -> gboolean>;
pub type GstClockCallback = Option<unsafe extern "C" fn(*mut GstClock, GstClockTime, GstClockID, gpointer) -> gboolean>;
pub type GstControlBindingConvert = Option<unsafe extern "C" fn(*mut GstControlBinding, c_double, *mut gobject::GValue)>;
pub type GstControlSourceGetValue = Option<unsafe extern "C" fn(*mut GstControlSource, GstClockTime, *mut c_double) -> gboolean>;
pub type GstControlSourceGetValueArray = Option<unsafe extern "C" fn(*mut GstControlSource, GstClockTime, GstClockTime, c_uint, *mut c_double) -> gboolean>;
pub type GstDebugFuncPtr = Option<unsafe extern "C" fn()>;
pub type GstElementCallAsyncFunc = Option<unsafe extern "C" fn(*mut GstElement, gpointer)>;
pub type GstIteratorCopyFunction = Option<unsafe extern "C" fn(*const GstIterator, *mut GstIterator)>;
pub type GstIteratorFoldFunction = Option<unsafe extern "C" fn(*const gobject::GValue, *mut gobject::GValue, gpointer) -> gboolean>;
pub type GstIteratorForeachFunction = Option<unsafe extern "C" fn(*const gobject::GValue, gpointer)>;
pub type GstIteratorFreeFunction = Option<unsafe extern "C" fn(*mut GstIterator)>;
pub type GstIteratorItemFunction = Option<unsafe extern "C" fn(*mut GstIterator, *const gobject::GValue) -> GstIteratorItem>;
pub type GstIteratorNextFunction = Option<unsafe extern "C" fn(*mut GstIterator, *mut gobject::GValue) -> GstIteratorResult>;
pub type GstIteratorResyncFunction = Option<unsafe extern "C" fn(*mut GstIterator)>;
pub type GstLogFunction = Option<unsafe extern "C" fn(*mut GstDebugCategory, GstDebugLevel, *const c_char, *const c_char, c_int, *mut gobject::GObject, *mut GstDebugMessage, gpointer)>;
pub type GstMemoryCopyFunction = Option<unsafe extern "C" fn(*mut GstMemory, ssize_t, ssize_t) -> *mut GstMemory>;
pub type GstMemoryIsSpanFunction = Option<unsafe extern "C" fn(*mut GstMemory, *mut GstMemory, *mut size_t) -> gboolean>;
pub type GstMemoryMapFullFunction = Option<unsafe extern "C" fn(*mut GstMemory, *mut GstMapInfo, size_t) -> gpointer>;
pub type GstMemoryMapFunction = Option<unsafe extern "C" fn(*mut GstMemory, size_t, GstMapFlags) -> gpointer>;
pub type GstMemoryShareFunction = Option<unsafe extern "C" fn(*mut GstMemory, ssize_t, ssize_t) -> *mut GstMemory>;
pub type GstMemoryUnmapFullFunction = Option<unsafe extern "C" fn(*mut GstMemory, *mut GstMapInfo)>;
pub type GstMemoryUnmapFunction = Option<unsafe extern "C" fn(*mut GstMemory)>;
pub type GstMetaFreeFunction = Option<unsafe extern "C" fn(*mut GstMeta, *mut GstBuffer)>;
pub type GstMetaInitFunction = Option<unsafe extern "C" fn(*mut GstMeta, gpointer, *mut GstBuffer) -> gboolean>;
pub type GstMetaTransformFunction = Option<unsafe extern "C" fn(*mut GstBuffer, *mut GstMeta, *mut GstBuffer, glib::GQuark, gpointer) -> gboolean>;
pub type GstMiniObjectCopyFunction = Option<unsafe extern "C" fn(*const GstMiniObject) -> *mut GstMiniObject>;
pub type GstMiniObjectDisposeFunction = Option<unsafe extern "C" fn(*mut GstMiniObject) -> gboolean>;
pub type GstMiniObjectFreeFunction = Option<unsafe extern "C" fn(*mut GstMiniObject)>;
pub type GstMiniObjectNotify = Option<unsafe extern "C" fn(gpointer, *mut GstMiniObject)>;
pub type GstPadActivateFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject) -> gboolean>;
pub type GstPadActivateModeFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, GstPadMode, gboolean) -> gboolean>;
pub type GstPadChainFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, *mut GstBuffer) -> GstFlowReturn>;
pub type GstPadChainListFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, *mut GstBufferList) -> GstFlowReturn>;
pub type GstPadEventFullFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, *mut GstEvent) -> GstFlowReturn>;
pub type GstPadEventFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, *mut GstEvent) -> gboolean>;
pub type GstPadForwardFunction = Option<unsafe extern "C" fn(*mut GstPad, gpointer) -> gboolean>;
pub type GstPadGetRangeFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, u64, c_uint, *mut *mut GstBuffer) -> GstFlowReturn>;
pub type GstPadIterIntLinkFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject) -> *mut GstIterator>;
pub type GstPadLinkFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, *mut GstPad) -> GstPadLinkReturn>;
pub type GstPadProbeCallback = Option<unsafe extern "C" fn(*mut GstPad, *mut GstPadProbeInfo, gpointer) -> GstPadProbeReturn>;
pub type GstPadQueryFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, *mut GstQuery) -> gboolean>;
pub type GstPadStickyEventsForeachFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut *mut GstEvent, gpointer) -> gboolean>;
pub type GstPadUnlinkFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject)>;
pub type GstPluginFeatureFilter = Option<unsafe extern "C" fn(*mut GstPluginFeature, gpointer) -> gboolean>;
pub type GstPluginFilter = Option<unsafe extern "C" fn(*mut GstPlugin, gpointer) -> gboolean>;
pub type GstPluginInitFullFunc = Option<unsafe extern "C" fn(*mut GstPlugin, gpointer) -> gboolean>;
pub type GstPluginInitFunc = Option<unsafe extern "C" fn(*mut GstPlugin) -> gboolean>;
pub type GstStructureFilterMapFunc = Option<unsafe extern "C" fn(glib::GQuark, *mut gobject::GValue, gpointer) -> gboolean>;
pub type GstStructureForeachFunc = Option<unsafe extern "C" fn(glib::GQuark, *const gobject::GValue, gpointer) -> gboolean>;
pub type GstStructureMapFunc = Option<unsafe extern "C" fn(glib::GQuark, *mut gobject::GValue, gpointer) -> gboolean>;
pub type GstTagForeachFunc = Option<unsafe extern "C" fn(*const GstTagList, *const c_char, gpointer)>;
pub type GstTagMergeFunc = Option<unsafe extern "C" fn(*mut gobject::GValue, *const gobject::GValue)>;
pub type GstTaskFunction = Option<unsafe extern "C" fn(gpointer)>;
pub type GstTaskPoolFunction = Option<unsafe extern "C" fn(*mut c_void)>;
pub type GstTaskThreadFunc = Option<unsafe extern "C" fn(*mut GstTask, *mut glib::GThread, gpointer)>;
pub type GstTypeFindFunction = Option<unsafe extern "C" fn(*mut GstTypeFind, gpointer)>;
pub type GstValueCompareFunc = Option<unsafe extern "C" fn(*const gobject::GValue, *const gobject::GValue) -> c_int>;
pub type GstValueDeserializeFunc = Option<unsafe extern "C" fn(*mut gobject::GValue, *const c_char) -> gboolean>;
pub type GstValueSerializeFunc = Option<unsafe extern "C" fn(*const gobject::GValue) -> *mut c_char>;

// Records
#[repr(C)]
pub struct GstAllocationParams {
    pub flags: GstMemoryFlags,
    pub align: size_t,
    pub prefix: size_t,
    pub padding: size_t,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAllocatorClass {
    pub object_class: GstObjectClass,
    pub alloc: Option<unsafe extern "C" fn(*mut GstAllocator, size_t, *mut GstAllocationParams) -> *mut GstMemory>,
    pub free: Option<unsafe extern "C" fn(*mut GstAllocator, *mut GstMemory)>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAllocatorPrivate(c_void);

#[repr(C)]
pub struct GstAtomicQueue(c_void);

#[repr(C)]
pub struct GstBinClass {
    pub parent_class: GstElementClass,
    pub pool: *mut glib::GThreadPool,
    pub element_added: Option<unsafe extern "C" fn(*mut GstBin, *mut GstElement)>,
    pub element_removed: Option<unsafe extern "C" fn(*mut GstBin, *mut GstElement)>,
    pub add_element: Option<unsafe extern "C" fn(*mut GstBin, *mut GstElement) -> gboolean>,
    pub remove_element: Option<unsafe extern "C" fn(*mut GstBin, *mut GstElement) -> gboolean>,
    pub handle_message: Option<unsafe extern "C" fn(*mut GstBin, *mut GstMessage)>,
    pub do_latency: Option<unsafe extern "C" fn(*mut GstBin) -> gboolean>,
    pub deep_element_added: Option<unsafe extern "C" fn(*mut GstBin, *mut GstBin, *mut GstElement)>,
    pub deep_element_removed: Option<unsafe extern "C" fn(*mut GstBin, *mut GstBin, *mut GstElement)>,
    pub _gst_reserved: [gpointer; 2],
}

#[repr(C)]
pub struct GstBinPrivate(c_void);

#[repr(C)]
pub struct GstBuffer {
    pub mini_object: GstMiniObject,
    pub pool: *mut GstBufferPool,
    pub pts: GstClockTime,
    pub dts: GstClockTime,
    pub duration: GstClockTime,
    pub offset: u64,
    pub offset_end: u64,
}

#[repr(C)]
pub struct GstBufferList(c_void);

#[repr(C)]
pub struct GstBufferPoolAcquireParams {
    pub format: GstFormat,
    pub start: i64,
    pub stop: i64,
    pub flags: GstBufferPoolAcquireFlags,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstBufferPoolClass {
    pub object_class: GstObjectClass,
    pub get_options: Option<unsafe extern "C" fn(*mut GstBufferPool) -> *mut *mut c_char>,
    pub set_config: Option<unsafe extern "C" fn(*mut GstBufferPool, *mut GstStructure) -> gboolean>,
    pub start: Option<unsafe extern "C" fn(*mut GstBufferPool) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstBufferPool) -> gboolean>,
    pub acquire_buffer: Option<unsafe extern "C" fn(*mut GstBufferPool, *mut *mut GstBuffer, *mut GstBufferPoolAcquireParams) -> GstFlowReturn>,
    pub alloc_buffer: Option<unsafe extern "C" fn(*mut GstBufferPool, *mut *mut GstBuffer, *mut GstBufferPoolAcquireParams) -> GstFlowReturn>,
    pub reset_buffer: Option<unsafe extern "C" fn(*mut GstBufferPool, *mut GstBuffer)>,
    pub release_buffer: Option<unsafe extern "C" fn(*mut GstBufferPool, *mut GstBuffer)>,
    pub free_buffer: Option<unsafe extern "C" fn(*mut GstBufferPool, *mut GstBuffer)>,
    pub flush_start: Option<unsafe extern "C" fn(*mut GstBufferPool)>,
    pub flush_stop: Option<unsafe extern "C" fn(*mut GstBufferPool)>,
    pub _gst_reserved: [gpointer; 2],
}

#[repr(C)]
pub struct GstBufferPoolPrivate(c_void);

#[repr(C)]
pub struct GstBusClass {
    pub parent_class: GstObjectClass,
    pub message: Option<unsafe extern "C" fn(*mut GstBus, *mut GstMessage)>,
    pub sync_message: Option<unsafe extern "C" fn(*mut GstBus, *mut GstMessage)>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstBusPrivate(c_void);

#[repr(C)]
pub struct GstCaps {
    pub mini_object: GstMiniObject,
}

#[repr(C)]
pub struct GstCapsFeatures(c_void);

#[repr(C)]
pub struct GstChildProxyInterface {
    pub parent: gobject::GTypeInterface,
    pub get_child_by_name: Option<unsafe extern "C" fn(*mut GstChildProxy, *const c_char) -> *mut gobject::GObject>,
    pub get_child_by_index: Option<unsafe extern "C" fn(*mut GstChildProxy, c_uint) -> *mut gobject::GObject>,
    pub get_children_count: Option<unsafe extern "C" fn(*mut GstChildProxy) -> c_uint>,
    pub child_added: Option<unsafe extern "C" fn(*mut GstChildProxy, *mut gobject::GObject, *const c_char)>,
    pub child_removed: Option<unsafe extern "C" fn(*mut GstChildProxy, *mut gobject::GObject, *const c_char)>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstClockClass {
    pub parent_class: GstObjectClass,
    pub change_resolution: Option<unsafe extern "C" fn(*mut GstClock, GstClockTime, GstClockTime) -> GstClockTime>,
    pub get_resolution: Option<unsafe extern "C" fn(*mut GstClock) -> GstClockTime>,
    pub get_internal_time: Option<unsafe extern "C" fn(*mut GstClock) -> GstClockTime>,
    pub wait: Option<unsafe extern "C" fn(*mut GstClock, *mut GstClockEntry, *mut GstClockTimeDiff) -> GstClockReturn>,
    pub wait_async: Option<unsafe extern "C" fn(*mut GstClock, *mut GstClockEntry) -> GstClockReturn>,
    pub unschedule: Option<unsafe extern "C" fn(*mut GstClock, *mut GstClockEntry)>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstClockEntry {
    pub refcount: c_int,
    pub clock: *mut GstClock,
    pub type_: GstClockEntryType,
    pub time: GstClockTime,
    pub interval: GstClockTime,
    pub status: GstClockReturn,
    pub func: GstClockCallback,
    pub user_data: gpointer,
    pub destroy_data: glib::GDestroyNotify,
    pub unscheduled: gboolean,
    pub woken_up: gboolean,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstClockPrivate(c_void);

#[repr(C)]
pub struct GstContext(c_void);

#[repr(C)]
pub struct GstControlBindingClass {
    pub parent_class: GstObjectClass,
    pub sync_values: Option<unsafe extern "C" fn(*mut GstControlBinding, *mut GstObject, GstClockTime, GstClockTime) -> gboolean>,
    pub get_value: Option<unsafe extern "C" fn(*mut GstControlBinding, GstClockTime) -> *mut gobject::GValue>,
    pub get_value_array: Option<unsafe extern "C" fn(*mut GstControlBinding, GstClockTime, GstClockTime, c_uint, gpointer) -> gboolean>,
    pub get_g_value_array: Option<unsafe extern "C" fn(*mut GstControlBinding, GstClockTime, GstClockTime, c_uint, *mut gobject::GValue) -> gboolean>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstControlBindingPrivate(c_void);

#[repr(C)]
pub struct GstControlSourceClass {
    pub parent_class: GstObjectClass,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstDateTime(c_void);

#[repr(C)]
pub struct GstDebugCategory {
    pub threshold: c_int,
    pub color: c_uint,
    pub name: *const c_char,
    pub description: *const c_char,
}

#[repr(C)]
pub struct GstDebugMessage(c_void);

#[repr(C)]
pub struct GstDeviceClass {
    pub parent_class: GstObjectClass,
    pub create_element: Option<unsafe extern "C" fn(*mut GstDevice, *const c_char) -> *mut GstElement>,
    pub reconfigure_element: Option<unsafe extern "C" fn(*mut GstDevice, *mut GstElement) -> gboolean>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstDeviceMonitorClass {
    pub parent_class: GstObjectClass,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstDeviceMonitorPrivate(c_void);

#[repr(C)]
pub struct GstDevicePrivate(c_void);

#[repr(C)]
pub struct GstDeviceProviderClass {
    pub parent_class: GstObjectClass,
    pub factory: *mut GstDeviceProviderFactory,
    pub probe: Option<unsafe extern "C" fn(*mut GstDeviceProvider) -> *mut glib::GList>,
    pub start: Option<unsafe extern "C" fn(*mut GstDeviceProvider) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstDeviceProvider)>,
    pub metadata: gpointer,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstDeviceProviderFactoryClass(c_void);

#[repr(C)]
pub struct GstDeviceProviderPrivate(c_void);

#[repr(C)]
pub struct GstDynamicTypeFactoryClass(c_void);

#[repr(C)]
pub struct GstElementClass {
    pub parent_class: GstObjectClass,
    pub metadata: gpointer,
    pub elementfactory: *mut GstElementFactory,
    pub padtemplates: *mut glib::GList,
    pub numpadtemplates: c_int,
    pub pad_templ_cookie: u32,
    pub pad_added: Option<unsafe extern "C" fn(*mut GstElement, *mut GstPad)>,
    pub pad_removed: Option<unsafe extern "C" fn(*mut GstElement, *mut GstPad)>,
    pub no_more_pads: Option<unsafe extern "C" fn(*mut GstElement)>,
    pub request_new_pad: Option<unsafe extern "C" fn(*mut GstElement, *mut GstPadTemplate, *const c_char, *const GstCaps) -> *mut GstPad>,
    pub release_pad: Option<unsafe extern "C" fn(*mut GstElement, *mut GstPad)>,
    pub get_state: Option<unsafe extern "C" fn(*mut GstElement, *mut GstState, *mut GstState, GstClockTime) -> GstStateChangeReturn>,
    pub set_state: Option<unsafe extern "C" fn(*mut GstElement, GstState) -> GstStateChangeReturn>,
    pub change_state: Option<unsafe extern "C" fn(*mut GstElement, GstStateChange) -> GstStateChangeReturn>,
    pub state_changed: Option<unsafe extern "C" fn(*mut GstElement, GstState, GstState, GstState)>,
    pub set_bus: Option<unsafe extern "C" fn(*mut GstElement, *mut GstBus)>,
    pub provide_clock: Option<unsafe extern "C" fn(*mut GstElement) -> *mut GstClock>,
    pub set_clock: Option<unsafe extern "C" fn(*mut GstElement, *mut GstClock) -> gboolean>,
    pub send_event: Option<unsafe extern "C" fn(*mut GstElement, *mut GstEvent) -> gboolean>,
    pub query: Option<unsafe extern "C" fn(*mut GstElement, *mut GstQuery) -> gboolean>,
    pub post_message: Option<unsafe extern "C" fn(*mut GstElement, *mut GstMessage) -> gboolean>,
    pub set_context: Option<unsafe extern "C" fn(*mut GstElement, *mut GstContext)>,
    pub _gst_reserved: [gpointer; 18],
}

#[repr(C)]
pub struct GstElementFactoryClass(c_void);

#[repr(C)]
pub struct GstEvent {
    pub mini_object: GstMiniObject,
    pub type_: GstEventType,
    pub timestamp: u64,
    pub seqnum: u32,
}

#[repr(C)]
pub struct GstFormatDefinition {
    pub value: GstFormat,
    pub nick: *const c_char,
    pub description: *const c_char,
    pub quark: glib::GQuark,
}

#[repr(C)]
pub struct GstGhostPadClass {
    pub parent_class: GstProxyPadClass,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstGhostPadPrivate(c_void);

#[repr(C)]
pub struct GstIterator {
    pub copy: GstIteratorCopyFunction,
    pub next: GstIteratorNextFunction,
    pub item: GstIteratorItemFunction,
    pub resync: GstIteratorResyncFunction,
    pub free: GstIteratorFreeFunction,
    pub pushed: *mut GstIterator,
    pub type_: GType,
    pub lock: *mut glib::GMutex,
    pub cookie: u32,
    pub master_cookie: *mut u32,
    pub size: c_uint,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstMapInfo {
    pub memory: *mut GstMemory,
    pub flags: GstMapFlags,
    pub data: *mut u8,
    pub size: size_t,
    pub maxsize: size_t,
    pub user_data: [gpointer; 4],
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstMemory {
    pub mini_object: GstMiniObject,
    pub allocator: *mut GstAllocator,
    pub parent: *mut GstMemory,
    pub maxsize: size_t,
    pub align: size_t,
    pub offset: size_t,
    pub size: size_t,
}

#[repr(C)]
pub struct GstMessage {
    pub mini_object: GstMiniObject,
    pub type_: GstMessageType,
    pub timestamp: u64,
    pub src: *mut GstObject,
    pub seqnum: u32,
    pub lock: glib::GMutex,
    pub cond: glib::GCond,
}

#[repr(C)]
pub struct GstMeta {
    pub flags: GstMetaFlags,
    pub info: *const GstMetaInfo,
}

#[repr(C)]
pub struct GstMetaInfo {
    pub api: GType,
    pub type_: GType,
    pub size: size_t,
    pub init_func: GstMetaInitFunction,
    pub free_func: GstMetaFreeFunction,
    pub transform_func: GstMetaTransformFunction,
}

#[repr(C)]
pub struct GstMetaTransformCopy {
    pub region: gboolean,
    pub offset: size_t,
    pub size: size_t,
}

#[repr(C)]
pub struct GstMiniObject {
    pub type_: GType,
    pub refcount: c_int,
    pub lockstate: c_int,
    pub flags: c_uint,
    pub copy: GstMiniObjectCopyFunction,
    pub dispose: GstMiniObjectDisposeFunction,
    pub free: GstMiniObjectFreeFunction,
    pub n_qdata: c_uint,
    pub qdata: gpointer,
}

#[repr(C)]
pub struct GstObjectClass {
    pub parent_class: gobject::GInitiallyUnownedClass,
    pub path_string_separator: *const c_char,
    pub deep_notify: Option<unsafe extern "C" fn(*mut GstObject, *mut GstObject, *mut gobject::GParamSpec)>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstPadClass {
    pub parent_class: GstObjectClass,
    pub linked: Option<unsafe extern "C" fn(*mut GstPad, *mut GstPad)>,
    pub unlinked: Option<unsafe extern "C" fn(*mut GstPad, *mut GstPad)>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstPadPrivate(c_void);

#[repr(C)]
pub struct GstPadProbeInfo {
    pub type_: GstPadProbeType,
    pub id: c_ulong,
    pub data: gpointer,
    pub offset: u64,
    pub size: c_uint,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstPadTemplateClass {
    pub parent_class: GstObjectClass,
    pub pad_created: Option<unsafe extern "C" fn(*mut GstPadTemplate, *mut GstPad)>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstParamSpecArray {
    pub parent_instance: gobject::GParamSpec,
    pub element_spec: *mut gobject::GParamSpec,
}

#[repr(C)]
pub struct GstParamSpecFraction {
    pub parent_instance: gobject::GParamSpec,
    pub min_num: c_int,
    pub min_den: c_int,
    pub max_num: c_int,
    pub max_den: c_int,
    pub def_num: c_int,
    pub def_den: c_int,
}

#[repr(C)]
pub struct GstParentBufferMeta {
    pub parent: GstMeta,
    pub buffer: *mut GstBuffer,
}

#[repr(C)]
pub struct GstParseContext(c_void);

#[repr(C)]
pub struct GstPipelineClass {
    pub parent_class: GstBinClass,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstPipelinePrivate(c_void);

#[repr(C)]
pub struct GstPluginClass(c_void);

#[repr(C)]
pub struct GstPluginDesc {
    pub major_version: c_int,
    pub minor_version: c_int,
    pub name: *const c_char,
    pub description: *const c_char,
    pub plugin_init: GstPluginInitFunc,
    pub version: *const c_char,
    pub license: *const c_char,
    pub source: *const c_char,
    pub package: *const c_char,
    pub origin: *const c_char,
    pub release_datetime: *const c_char,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstPluginFeatureClass(c_void);

#[repr(C)]
pub struct GstPoll(c_void);

#[repr(C)]
pub struct GstPollFD {
    pub fd: c_int,
    pub idx: c_int,
}

#[repr(C)]
pub struct GstPresetInterface {
    pub parent: gobject::GTypeInterface,
    pub get_preset_names: Option<unsafe extern "C" fn(*mut GstPreset) -> *mut *mut c_char>,
    pub get_property_names: Option<unsafe extern "C" fn(*mut GstPreset) -> *mut *mut c_char>,
    pub load_preset: Option<unsafe extern "C" fn(*mut GstPreset, *const c_char) -> gboolean>,
    pub save_preset: Option<unsafe extern "C" fn(*mut GstPreset, *const c_char) -> gboolean>,
    pub rename_preset: Option<unsafe extern "C" fn(*mut GstPreset, *const c_char, *const c_char) -> gboolean>,
    pub delete_preset: Option<unsafe extern "C" fn(*mut GstPreset, *const c_char) -> gboolean>,
    pub set_meta: Option<unsafe extern "C" fn(*mut GstPreset, *const c_char, *const c_char, *mut *mut c_char) -> gboolean>,
    pub get_meta: Option<unsafe extern "C" fn(*mut GstPreset, *const c_char, *const c_char, *mut *mut c_char) -> gboolean>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstProtectionMeta {
    pub meta: GstMeta,
    pub info: *mut GstStructure,
}

#[repr(C)]
pub struct GstProxyPadClass {
    pub parent_class: GstPadClass,
    pub _gst_reserved: [gpointer; 1],
}

#[repr(C)]
pub struct GstProxyPadPrivate(c_void);

#[repr(C)]
pub struct GstQuery {
    pub mini_object: GstMiniObject,
    pub type_: GstQueryType,
}

#[repr(C)]
pub struct GstRegistryClass {
    pub parent_class: GstObjectClass,
}

#[repr(C)]
pub struct GstRegistryPrivate(c_void);

#[repr(C)]
pub struct GstSample(c_void);

#[repr(C)]
pub struct GstSegment {
    pub flags: GstSegmentFlags,
    pub rate: c_double,
    pub applied_rate: c_double,
    pub format: GstFormat,
    pub base: u64,
    pub offset: u64,
    pub start: u64,
    pub stop: u64,
    pub time: u64,
    pub position: u64,
    pub duration: u64,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstStaticCaps {
    pub caps: *mut GstCaps,
    pub string: *const c_char,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstStaticPadTemplate {
    pub name_template: *const c_char,
    pub direction: GstPadDirection,
    pub presence: GstPadPresence,
    pub static_caps: GstStaticCaps,
}

#[repr(C)]
pub struct GstStreamClass {
    pub parent_class: GstObjectClass,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstStreamCollectionClass {
    pub parent_class: GstObjectClass,
    pub stream_notify: Option<unsafe extern "C" fn(*mut GstStreamCollection, *mut GstStream, *mut gobject::GParamSpec)>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstStreamCollectionPrivate(c_void);

#[repr(C)]
pub struct GstStreamPrivate(c_void);

#[repr(C)]
pub struct GstStructure {
    pub type_: GType,
    pub name: glib::GQuark,
}

#[repr(C)]
pub struct GstSystemClockClass {
    pub parent_class: GstClockClass,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstSystemClockPrivate(c_void);

#[repr(C)]
pub struct GstTagList {
    pub mini_object: GstMiniObject,
}

#[repr(C)]
pub struct GstTagSetterInterface {
    pub g_iface: gobject::GTypeInterface,
}

#[repr(C)]
pub struct GstTaskClass {
    pub parent_class: GstObjectClass,
    pub pool: *mut GstTaskPool,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstTaskPoolClass {
    pub parent_class: GstObjectClass,
    pub prepare: Option<unsafe extern "C" fn(*mut GstTaskPool, *mut *mut glib::GError)>,
    pub cleanup: Option<unsafe extern "C" fn(*mut GstTaskPool)>,
    pub push: Option<unsafe extern "C" fn(*mut GstTaskPool, GstTaskPoolFunction, gpointer, *mut *mut glib::GError) -> gpointer>,
    pub join: Option<unsafe extern "C" fn(*mut GstTaskPool, gpointer)>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstTaskPrivate(c_void);

#[repr(C)]
pub struct GstTimedValue {
    pub timestamp: GstClockTime,
    pub value: c_double,
}

#[repr(C)]
pub struct GstToc(c_void);

#[repr(C)]
pub struct GstTocEntry(c_void);

#[repr(C)]
pub struct GstTocSetterInterface {
    pub g_iface: gobject::GTypeInterface,
}

#[repr(C)]
pub struct GstTracerClass {
    pub parent_class: GstObjectClass,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstTracerFactoryClass(c_void);

#[repr(C)]
pub struct GstTracerPrivate(c_void);

#[repr(C)]
pub struct GstTracerRecordClass(c_void);

#[repr(C)]
pub struct GstTypeFind {
    pub peek: Option<unsafe extern "C" fn(gpointer, i64, c_uint) -> *const u8>,
    pub suggest: Option<unsafe extern "C" fn(gpointer, c_uint, *mut GstCaps)>,
    pub data: gpointer,
    pub get_length: Option<unsafe extern "C" fn(gpointer) -> u64>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstTypeFindFactoryClass(c_void);

#[repr(C)]
pub struct GstURIHandlerInterface {
    pub parent: gobject::GTypeInterface,
    pub get_type: Option<unsafe extern "C" fn(GType) -> GstURIType>,
    pub get_protocols: Option<unsafe extern "C" fn(GType) -> *const *const c_char>,
    pub get_uri: Option<unsafe extern "C" fn(*mut GstURIHandler) -> *mut c_char>,
    pub set_uri: Option<unsafe extern "C" fn(*mut GstURIHandler, *const c_char, *mut *mut glib::GError) -> gboolean>,
}

#[repr(C)]
pub struct GstUri(c_void);

#[repr(C)]
pub struct GstValueTable {
    pub type_: GType,
    pub compare: GstValueCompareFunc,
    pub serialize: GstValueSerializeFunc,
    pub deserialize: GstValueDeserializeFunc,
    pub _gst_reserved: [gpointer; 4],
}

// Classes
#[repr(C)]
pub struct GstAllocator {
    pub object: GstObject,
    pub mem_type: *const c_char,
    pub mem_map: GstMemoryMapFunction,
    pub mem_unmap: GstMemoryUnmapFunction,
    pub mem_copy: GstMemoryCopyFunction,
    pub mem_share: GstMemoryShareFunction,
    pub mem_is_span: GstMemoryIsSpanFunction,
    pub mem_map_full: GstMemoryMapFullFunction,
    pub mem_unmap_full: GstMemoryUnmapFullFunction,
    pub _gst_reserved: [gpointer; 2],
    pub priv_: *mut GstAllocatorPrivate,
}

#[repr(C)]
pub struct GstBin {
    pub element: GstElement,
    pub numchildren: c_int,
    pub children: *mut glib::GList,
    pub children_cookie: u32,
    pub child_bus: *mut GstBus,
    pub messages: *mut glib::GList,
    pub polling: gboolean,
    pub state_dirty: gboolean,
    pub clock_dirty: gboolean,
    pub provided_clock: *mut GstClock,
    pub clock_provider: *mut GstElement,
    pub priv_: *mut GstBinPrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstBitmask(c_void);

#[repr(C)]
pub struct GstBufferPool {
    pub object: GstObject,
    pub flushing: c_int,
    pub priv_: *mut GstBufferPoolPrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstBus {
    pub object: GstObject,
    pub priv_: *mut GstBusPrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstClock {
    pub object: GstObject,
    pub priv_: *mut GstClockPrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstControlBinding {
    pub parent: GstObject,
    pub name: *mut c_char,
    pub pspec: *mut gobject::GParamSpec,
    pub object: *mut GstObject,
    pub disabled: gboolean,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstControlSource {
    pub parent: GstObject,
    pub get_value: GstControlSourceGetValue,
    pub get_value_array: GstControlSourceGetValueArray,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstDevice {
    pub parent: GstObject,
    pub priv_: *mut GstDevicePrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstDeviceMonitor {
    pub parent: GstObject,
    pub priv_: *mut GstDeviceMonitorPrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstDeviceProvider {
    pub parent: GstObject,
    pub devices: *mut glib::GList,
    pub priv_: *mut GstDeviceProviderPrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstDeviceProviderFactory(c_void);

#[repr(C)]
pub struct GstDoubleRange(c_void);

#[repr(C)]
pub struct GstDynamicTypeFactory(c_void);

#[repr(C)]
pub struct GstElement {
    pub object: GstObject,
    pub state_lock: glib::GRecMutex,
    pub state_cond: glib::GCond,
    pub state_cookie: u32,
    pub target_state: GstState,
    pub current_state: GstState,
    pub next_state: GstState,
    pub pending_state: GstState,
    pub last_return: GstStateChangeReturn,
    pub bus: *mut GstBus,
    pub clock: *mut GstClock,
    pub base_time: GstClockTimeDiff,
    pub start_time: GstClockTime,
    pub numpads: u16,
    pub pads: *mut glib::GList,
    pub numsrcpads: u16,
    pub srcpads: *mut glib::GList,
    pub numsinkpads: u16,
    pub sinkpads: *mut glib::GList,
    pub pads_cookie: u32,
    pub contexts: *mut glib::GList,
    pub _gst_reserved: [gpointer; 3],
}

#[repr(C)]
pub struct GstElementFactory(c_void);

#[repr(C)]
pub struct GstFlagSet(c_void);

#[repr(C)]
pub struct GstFraction(c_void);

#[repr(C)]
pub struct GstFractionRange(c_void);

#[repr(C)]
pub struct GstGhostPad {
    pub pad: GstProxyPad,
    pub priv_: *mut GstGhostPadPrivate,
}

#[repr(C)]
pub struct GstInt64Range(c_void);

#[repr(C)]
pub struct GstIntRange(c_void);

#[repr(C)]
pub struct GstObject {
    pub object: gobject::GInitiallyUnowned,
    pub lock: glib::GMutex,
    pub name: *mut c_char,
    pub parent: *mut GstObject,
    pub flags: u32,
    pub control_bindings: *mut glib::GList,
    pub control_rate: u64,
    pub last_sync: u64,
    pub _gst_reserved: gpointer,
}

#[repr(C)]
pub struct GstPad {
    pub object: GstObject,
    pub element_private: gpointer,
    pub padtemplate: *mut GstPadTemplate,
    pub direction: GstPadDirection,
    pub stream_rec_lock: glib::GRecMutex,
    pub task: *mut GstTask,
    pub block_cond: glib::GCond,
    pub probes: glib::GHookList,
    pub mode: GstPadMode,
    pub activatefunc: GstPadActivateFunction,
    pub activatedata: gpointer,
    pub activatenotify: glib::GDestroyNotify,
    pub activatemodefunc: GstPadActivateModeFunction,
    pub activatemodedata: gpointer,
    pub activatemodenotify: glib::GDestroyNotify,
    pub peer: *mut GstPad,
    pub linkfunc: GstPadLinkFunction,
    pub linkdata: gpointer,
    pub linknotify: glib::GDestroyNotify,
    pub unlinkfunc: GstPadUnlinkFunction,
    pub unlinkdata: gpointer,
    pub unlinknotify: glib::GDestroyNotify,
    pub chainfunc: GstPadChainFunction,
    pub chaindata: gpointer,
    pub chainnotify: glib::GDestroyNotify,
    pub chainlistfunc: GstPadChainListFunction,
    pub chainlistdata: gpointer,
    pub chainlistnotify: glib::GDestroyNotify,
    pub getrangefunc: GstPadGetRangeFunction,
    pub getrangedata: gpointer,
    pub getrangenotify: glib::GDestroyNotify,
    pub eventfunc: GstPadEventFunction,
    pub eventdata: gpointer,
    pub eventnotify: glib::GDestroyNotify,
    pub offset: i64,
    pub queryfunc: GstPadQueryFunction,
    pub querydata: gpointer,
    pub querynotify: glib::GDestroyNotify,
    pub iterintlinkfunc: GstPadIterIntLinkFunction,
    pub iterintlinkdata: gpointer,
    pub iterintlinknotify: glib::GDestroyNotify,
    pub num_probes: c_int,
    pub num_blocked: c_int,
    pub priv_: *mut GstPadPrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstPadTemplate {
    pub object: GstObject,
    pub name_template: *mut c_char,
    pub direction: GstPadDirection,
    pub presence: GstPadPresence,
    pub caps: *mut GstCaps,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstParamArray(c_void);

#[repr(C)]
pub struct GstParamFraction(c_void);

#[repr(C)]
pub struct GstPipeline {
    pub bin: GstBin,
    pub fixed_clock: *mut GstClock,
    pub stream_time: GstClockTime,
    pub delay: GstClockTime,
    pub priv_: *mut GstPipelinePrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstPlugin(c_void);

#[repr(C)]
pub struct GstPluginFeature(c_void);

#[repr(C)]
pub struct GstProxyPad {
    pub pad: GstPad,
    pub priv_: *mut GstProxyPadPrivate,
}

#[repr(C)]
pub struct GstRegistry {
    pub object: GstObject,
    pub priv_: *mut GstRegistryPrivate,
}

#[repr(C)]
pub struct GstStream {
    pub object: GstObject,
    pub stream_id: *const c_char,
    pub priv_: *mut GstStreamPrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstStreamCollection {
    pub object: GstObject,
    pub upstream_id: *mut c_char,
    pub priv_: *mut GstStreamCollectionPrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstSystemClock {
    pub clock: GstClock,
    pub priv_: *mut GstSystemClockPrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstTask {
    pub object: GstObject,
    pub state: GstTaskState,
    pub cond: glib::GCond,
    pub lock: *mut glib::GRecMutex,
    pub func: GstTaskFunction,
    pub user_data: gpointer,
    pub notify: glib::GDestroyNotify,
    pub running: gboolean,
    pub thread: *mut glib::GThread,
    pub priv_: *mut GstTaskPrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstTaskPool {
    pub object: GstObject,
    pub pool: *mut glib::GThreadPool,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstTracer {
    pub parent: GstObject,
    pub priv_: *mut GstTracerPrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstTracerFactory(c_void);

#[repr(C)]
pub struct GstTracerRecord(c_void);

#[repr(C)]
pub struct GstTypeFindFactory(c_void);

#[repr(C)]
pub struct GstValueArray(c_void);

#[repr(C)]
pub struct GstValueList(c_void);

// Interfaces
#[repr(C)]
pub struct GstChildProxy(c_void);
#[repr(C)]
pub struct GstPreset(c_void);
#[repr(C)]
pub struct GstTagSetter(c_void);
#[repr(C)]
pub struct GstTocSetter(c_void);
#[repr(C)]
pub struct GstURIHandler(c_void);

extern "C" {

    //=========================================================================
    // GstCoreError
    //=========================================================================
    pub fn gst_core_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstDebugLevel
    //=========================================================================
    pub fn gst_debug_level_get_name(level: GstDebugLevel) -> *const c_char;

    //=========================================================================
    // GstEventType
    //=========================================================================
    pub fn gst_event_type_get_flags(type_: GstEventType) -> GstEventTypeFlags;
    pub fn gst_event_type_get_name(type_: GstEventType) -> *const c_char;
    pub fn gst_event_type_to_quark(type_: GstEventType) -> glib::GQuark;

    //=========================================================================
    // GstFormat
    //=========================================================================
    pub fn gst_format_get_by_nick(nick: *const c_char) -> GstFormat;
    pub fn gst_format_get_details(format: GstFormat) -> *const GstFormatDefinition;
    pub fn gst_format_get_name(format: GstFormat) -> *const c_char;
    pub fn gst_format_iterate_definitions() -> *mut GstIterator;
    pub fn gst_format_register(nick: *const c_char, description: *const c_char) -> GstFormat;
    pub fn gst_format_to_quark(format: GstFormat) -> glib::GQuark;

    //=========================================================================
    // GstLibraryError
    //=========================================================================
    pub fn gst_library_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstPadMode
    //=========================================================================
    pub fn gst_pad_mode_get_name(mode: GstPadMode) -> *const c_char;

    //=========================================================================
    // GstParseError
    //=========================================================================
    pub fn gst_parse_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstPluginError
    //=========================================================================
    pub fn gst_plugin_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstQueryType
    //=========================================================================
    pub fn gst_query_type_get_flags(type_: GstQueryType) -> GstQueryTypeFlags;
    pub fn gst_query_type_get_name(type_: GstQueryType) -> *const c_char;
    pub fn gst_query_type_to_quark(type_: GstQueryType) -> glib::GQuark;

    //=========================================================================
    // GstResourceError
    //=========================================================================
    pub fn gst_resource_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstStreamError
    //=========================================================================
    pub fn gst_stream_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstTocEntryType
    //=========================================================================
    pub fn gst_toc_entry_type_get_nick(type_: GstTocEntryType) -> *const c_char;

    //=========================================================================
    // GstURIError
    //=========================================================================
    pub fn gst_uri_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstMessageType
    //=========================================================================
    pub fn gst_message_type_get_name(type_: GstMessageType) -> *const c_char;
    pub fn gst_message_type_to_quark(type_: GstMessageType) -> glib::GQuark;

    //=========================================================================
    // GstStreamType
    //=========================================================================
    #[cfg(feature = "v1_10")]
    pub fn gst_stream_type_get_name(stype: GstStreamType) -> *const c_char;

    //=========================================================================
    // GstAllocationParams
    //=========================================================================
    pub fn gst_allocation_params_get_type() -> GType;
    pub fn gst_allocation_params_copy(params: *const GstAllocationParams) -> *mut GstAllocationParams;
    pub fn gst_allocation_params_free(params: *mut GstAllocationParams);
    pub fn gst_allocation_params_init(params: *mut GstAllocationParams);

    //=========================================================================
    // GstAtomicQueue
    //=========================================================================
    pub fn gst_atomic_queue_get_type() -> GType;
    pub fn gst_atomic_queue_new(initial_size: c_uint) -> *mut GstAtomicQueue;
    pub fn gst_atomic_queue_length(queue: *mut GstAtomicQueue) -> c_uint;
    pub fn gst_atomic_queue_peek(queue: *mut GstAtomicQueue) -> gpointer;
    pub fn gst_atomic_queue_pop(queue: *mut GstAtomicQueue) -> gpointer;
    pub fn gst_atomic_queue_push(queue: *mut GstAtomicQueue, data: gpointer);
    pub fn gst_atomic_queue_ref(queue: *mut GstAtomicQueue);
    pub fn gst_atomic_queue_unref(queue: *mut GstAtomicQueue);

    //=========================================================================
    // GstBuffer
    //=========================================================================
    pub fn gst_buffer_get_type() -> GType;
    pub fn gst_buffer_new() -> *mut GstBuffer;
    pub fn gst_buffer_new_allocate(allocator: *mut GstAllocator, size: size_t, params: *mut GstAllocationParams) -> *mut GstBuffer;
    pub fn gst_buffer_new_wrapped(data: gpointer, size: size_t) -> *mut GstBuffer;
    pub fn gst_buffer_new_wrapped_full(flags: GstMemoryFlags, data: gpointer, maxsize: size_t, offset: size_t, size: size_t, user_data: gpointer, notify: glib::GDestroyNotify) -> *mut GstBuffer;
    pub fn gst_buffer_add_meta(buffer: *mut GstBuffer, info: *const GstMetaInfo, params: gpointer) -> *mut GstMeta;
    #[cfg(feature = "v1_6")]
    pub fn gst_buffer_add_parent_buffer_meta(buffer: *mut GstBuffer, ref_: *mut GstBuffer) -> *mut GstParentBufferMeta;
    #[cfg(feature = "v1_6")]
    pub fn gst_buffer_add_protection_meta(buffer: *mut GstBuffer, info: *mut GstStructure) -> *mut GstProtectionMeta;
    pub fn gst_buffer_append(buf1: *mut GstBuffer, buf2: *mut GstBuffer) -> *mut GstBuffer;
    pub fn gst_buffer_append_memory(buffer: *mut GstBuffer, mem: *mut GstMemory);
    pub fn gst_buffer_append_region(buf1: *mut GstBuffer, buf2: *mut GstBuffer, offset: ssize_t, size: ssize_t) -> *mut GstBuffer;
    #[cfg(feature = "v1_6")]
    pub fn gst_buffer_copy_deep(buf: *const GstBuffer) -> *mut GstBuffer;
    pub fn gst_buffer_copy_into(dest: *mut GstBuffer, src: *mut GstBuffer, flags: GstBufferCopyFlags, offset: size_t, size: size_t) -> gboolean;
    pub fn gst_buffer_copy_region(parent: *mut GstBuffer, flags: GstBufferCopyFlags, offset: size_t, size: size_t) -> *mut GstBuffer;
    pub fn gst_buffer_extract(buffer: *mut GstBuffer, offset: size_t, dest: gpointer, size: size_t) -> size_t;
    #[cfg(feature = "v1_0_10")]
    pub fn gst_buffer_extract_dup(buffer: *mut GstBuffer, offset: size_t, size: size_t, dest: *mut u8, dest_size: *mut size_t);
    pub fn gst_buffer_fill(buffer: *mut GstBuffer, offset: size_t, src: gconstpointer, size: size_t) -> size_t;
    pub fn gst_buffer_find_memory(buffer: *mut GstBuffer, offset: size_t, size: size_t, idx: *mut c_uint, length: *mut c_uint, skip: *mut size_t) -> gboolean;
    pub fn gst_buffer_foreach_meta(buffer: *mut GstBuffer, func: GstBufferForeachMetaFunc, user_data: gpointer) -> gboolean;
    pub fn gst_buffer_get_all_memory(buffer: *mut GstBuffer) -> *mut GstMemory;
    #[cfg(feature = "v1_10")]
    pub fn gst_buffer_get_flags(buffer: *mut GstBuffer) -> GstBufferFlags;
    pub fn gst_buffer_get_memory(buffer: *mut GstBuffer, idx: c_uint) -> *mut GstMemory;
    pub fn gst_buffer_get_memory_range(buffer: *mut GstBuffer, idx: c_uint, length: c_int) -> *mut GstMemory;
    pub fn gst_buffer_get_meta(buffer: *mut GstBuffer, api: GType) -> *mut GstMeta;
    pub fn gst_buffer_get_size(buffer: *mut GstBuffer) -> size_t;
    pub fn gst_buffer_get_sizes(buffer: *mut GstBuffer, offset: *mut size_t, maxsize: *mut size_t) -> size_t;
    pub fn gst_buffer_get_sizes_range(buffer: *mut GstBuffer, idx: c_uint, length: c_int, offset: *mut size_t, maxsize: *mut size_t) -> size_t;
    pub fn gst_buffer_has_flags(buffer: *mut GstBuffer, flags: GstBufferFlags) -> gboolean;
    pub fn gst_buffer_insert_memory(buffer: *mut GstBuffer, idx: c_int, mem: *mut GstMemory);
    #[cfg(feature = "v1_4")]
    pub fn gst_buffer_is_all_memory_writable(buffer: *mut GstBuffer) -> gboolean;
    #[cfg(feature = "v1_4")]
    pub fn gst_buffer_is_memory_range_writable(buffer: *mut GstBuffer, idx: c_uint, length: c_int) -> gboolean;
    pub fn gst_buffer_iterate_meta(buffer: *mut GstBuffer, state: *mut gpointer) -> *mut GstMeta;
    #[cfg(feature = "v1_12")]
    pub fn gst_buffer_iterate_meta_filtered(buffer: *mut GstBuffer, state: *mut gpointer, meta_api_type: GType) -> *mut GstMeta;
    pub fn gst_buffer_map(buffer: *mut GstBuffer, info: *mut GstMapInfo, flags: GstMapFlags) -> gboolean;
    pub fn gst_buffer_map_range(buffer: *mut GstBuffer, idx: c_uint, length: c_int, info: *mut GstMapInfo, flags: GstMapFlags) -> gboolean;
    pub fn gst_buffer_memcmp(buffer: *mut GstBuffer, offset: size_t, mem: gconstpointer, size: size_t) -> c_int;
    pub fn gst_buffer_memset(buffer: *mut GstBuffer, offset: size_t, val: u8, size: size_t) -> size_t;
    pub fn gst_buffer_n_memory(buffer: *mut GstBuffer) -> c_uint;
    pub fn gst_buffer_peek_memory(buffer: *mut GstBuffer, idx: c_uint) -> *mut GstMemory;
    pub fn gst_buffer_prepend_memory(buffer: *mut GstBuffer, mem: *mut GstMemory);
    pub fn gst_buffer_remove_all_memory(buffer: *mut GstBuffer);
    pub fn gst_buffer_remove_memory(buffer: *mut GstBuffer, idx: c_uint);
    pub fn gst_buffer_remove_memory_range(buffer: *mut GstBuffer, idx: c_uint, length: c_int);
    pub fn gst_buffer_remove_meta(buffer: *mut GstBuffer, meta: *mut GstMeta) -> gboolean;
    pub fn gst_buffer_replace_all_memory(buffer: *mut GstBuffer, mem: *mut GstMemory);
    pub fn gst_buffer_replace_memory(buffer: *mut GstBuffer, idx: c_uint, mem: *mut GstMemory);
    pub fn gst_buffer_replace_memory_range(buffer: *mut GstBuffer, idx: c_uint, length: c_int, mem: *mut GstMemory);
    pub fn gst_buffer_resize(buffer: *mut GstBuffer, offset: ssize_t, size: ssize_t);
    pub fn gst_buffer_resize_range(buffer: *mut GstBuffer, idx: c_uint, length: c_int, offset: ssize_t, size: ssize_t) -> gboolean;
    #[cfg(feature = "v1_10")]
    pub fn gst_buffer_set_flags(buffer: *mut GstBuffer, flags: GstBufferFlags) -> gboolean;
    pub fn gst_buffer_set_size(buffer: *mut GstBuffer, size: ssize_t);
    pub fn gst_buffer_unmap(buffer: *mut GstBuffer, info: *mut GstMapInfo);
    #[cfg(feature = "v1_10")]
    pub fn gst_buffer_unset_flags(buffer: *mut GstBuffer, flags: GstBufferFlags) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_buffer_get_max_memory() -> c_uint;

    //=========================================================================
    // GstBufferList
    //=========================================================================
    pub fn gst_buffer_list_get_type() -> GType;
    pub fn gst_buffer_list_new() -> *mut GstBufferList;
    pub fn gst_buffer_list_new_sized(size: c_uint) -> *mut GstBufferList;
    #[cfg(feature = "v1_6")]
    pub fn gst_buffer_list_copy_deep(list: *const GstBufferList) -> *mut GstBufferList;
    pub fn gst_buffer_list_foreach(list: *mut GstBufferList, func: GstBufferListFunc, user_data: gpointer) -> gboolean;
    pub fn gst_buffer_list_get(list: *mut GstBufferList, idx: c_uint) -> *mut GstBuffer;
    pub fn gst_buffer_list_insert(list: *mut GstBufferList, idx: c_int, buffer: *mut GstBuffer);
    pub fn gst_buffer_list_length(list: *mut GstBufferList) -> c_uint;
    pub fn gst_buffer_list_remove(list: *mut GstBufferList, idx: c_uint, length: c_uint);

    //=========================================================================
    // GstCaps
    //=========================================================================
    pub fn gst_caps_get_type() -> GType;
    pub fn gst_caps_new_any() -> *mut GstCaps;
    pub fn gst_caps_new_empty() -> *mut GstCaps;
    pub fn gst_caps_new_empty_simple(media_type: *const c_char) -> *mut GstCaps;
    pub fn gst_caps_new_full(struct1: *mut GstStructure, ...) -> *mut GstCaps;
    //pub fn gst_caps_new_full_valist(structure: *mut GstStructure, var_args: /*Unimplemented*/va_list) -> *mut GstCaps;
    pub fn gst_caps_new_simple(media_type: *const c_char, fieldname: *const c_char, ...) -> *mut GstCaps;
    pub fn gst_caps_append(caps1: *mut GstCaps, caps2: *mut GstCaps);
    pub fn gst_caps_append_structure(caps: *mut GstCaps, structure: *mut GstStructure);
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_append_structure_full(caps: *mut GstCaps, structure: *mut GstStructure, features: *mut GstCapsFeatures);
    pub fn gst_caps_can_intersect(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
    pub fn gst_caps_copy_nth(caps: *const GstCaps, nth: c_uint) -> *mut GstCaps;
    #[cfg(feature = "v1_6")]
    pub fn gst_caps_filter_and_map_in_place(caps: *mut GstCaps, func: GstCapsFilterMapFunc, user_data: gpointer);
    pub fn gst_caps_fixate(caps: *mut GstCaps) -> *mut GstCaps;
    #[cfg(feature = "v1_6")]
    pub fn gst_caps_foreach(caps: *const GstCaps, func: GstCapsForeachFunc, user_data: gpointer) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_get_features(caps: *const GstCaps, index: c_uint) -> *mut GstCapsFeatures;
    pub fn gst_caps_get_size(caps: *const GstCaps) -> c_uint;
    pub fn gst_caps_get_structure(caps: *const GstCaps, index: c_uint) -> *mut GstStructure;
    pub fn gst_caps_intersect(caps1: *mut GstCaps, caps2: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_intersect_full(caps1: *mut GstCaps, caps2: *mut GstCaps, mode: GstCapsIntersectMode) -> *mut GstCaps;
    pub fn gst_caps_is_always_compatible(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_any(caps: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_empty(caps: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_equal(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_equal_fixed(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_fixed(caps: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_strictly_equal(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_subset(subset: *const GstCaps, superset: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_subset_structure(caps: *const GstCaps, structure: *const GstStructure) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_is_subset_structure_full(caps: *const GstCaps, structure: *const GstStructure, features: *const GstCapsFeatures) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_caps_map_in_place(caps: *mut GstCaps, func: GstCapsMapFunc, user_data: gpointer) -> gboolean;
    pub fn gst_caps_merge(caps1: *mut GstCaps, caps2: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_merge_structure(caps: *mut GstCaps, structure: *mut GstStructure) -> *mut GstCaps;
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_merge_structure_full(caps: *mut GstCaps, structure: *mut GstStructure, features: *mut GstCapsFeatures) -> *mut GstCaps;
    pub fn gst_caps_normalize(caps: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_remove_structure(caps: *mut GstCaps, idx: c_uint);
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_set_features(caps: *mut GstCaps, index: c_uint, features: *mut GstCapsFeatures);
    pub fn gst_caps_set_simple(caps: *mut GstCaps, field: *const c_char, ...);
    //pub fn gst_caps_set_simple_valist(caps: *mut GstCaps, field: *const c_char, varargs: /*Unimplemented*/va_list);
    pub fn gst_caps_set_value(caps: *mut GstCaps, field: *const c_char, value: *const gobject::GValue);
    pub fn gst_caps_simplify(caps: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_steal_structure(caps: *mut GstCaps, index: c_uint) -> *mut GstStructure;
    pub fn gst_caps_subtract(minuend: *mut GstCaps, subtrahend: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_to_string(caps: *const GstCaps) -> *mut c_char;
    pub fn gst_caps_truncate(caps: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_from_string(string: *const c_char) -> *mut GstCaps;

    //=========================================================================
    // GstCapsFeatures
    //=========================================================================
    pub fn gst_caps_features_get_type() -> GType;
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_new(feature1: *const c_char, ...) -> *mut GstCapsFeatures;
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_new_any() -> *mut GstCapsFeatures;
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_new_empty() -> *mut GstCapsFeatures;
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_new_id(feature1: glib::GQuark, ...) -> *mut GstCapsFeatures;
    //#[cfg(feature = "v1_2")]
    //pub fn gst_caps_features_new_id_valist(feature1: glib::GQuark, varargs: /*Unimplemented*/va_list) -> *mut GstCapsFeatures;
    //#[cfg(feature = "v1_2")]
    //pub fn gst_caps_features_new_valist(feature1: *const c_char, varargs: /*Unimplemented*/va_list) -> *mut GstCapsFeatures;
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_add(features: *mut GstCapsFeatures, feature: *const c_char);
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_add_id(features: *mut GstCapsFeatures, feature: glib::GQuark);
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_contains(features: *const GstCapsFeatures, feature: *const c_char) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_contains_id(features: *const GstCapsFeatures, feature: glib::GQuark) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_copy(features: *const GstCapsFeatures) -> *mut GstCapsFeatures;
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_free(features: *mut GstCapsFeatures);
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_get_nth(features: *const GstCapsFeatures, i: c_uint) -> *const c_char;
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_get_nth_id(features: *const GstCapsFeatures, i: c_uint) -> glib::GQuark;
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_get_size(features: *const GstCapsFeatures) -> c_uint;
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_is_any(features: *const GstCapsFeatures) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_is_equal(features1: *const GstCapsFeatures, features2: *const GstCapsFeatures) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_remove(features: *mut GstCapsFeatures, feature: *const c_char);
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_remove_id(features: *mut GstCapsFeatures, feature: glib::GQuark);
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_set_parent_refcount(features: *mut GstCapsFeatures, refcount: *mut c_int) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_to_string(features: *const GstCapsFeatures) -> *mut c_char;
    #[cfg(feature = "v1_2")]
    pub fn gst_caps_features_from_string(features: *const c_char) -> *mut GstCapsFeatures;

    //=========================================================================
    // GstContext
    //=========================================================================
    pub fn gst_context_get_type() -> GType;
    #[cfg(feature = "v1_2")]
    pub fn gst_context_new(context_type: *const c_char, persistent: gboolean) -> *mut GstContext;
    #[cfg(feature = "v1_2")]
    pub fn gst_context_get_context_type(context: *const GstContext) -> *const c_char;
    #[cfg(feature = "v1_2")]
    pub fn gst_context_get_structure(context: *const GstContext) -> *const GstStructure;
    #[cfg(feature = "v1_2")]
    pub fn gst_context_has_context_type(context: *const GstContext, context_type: *const c_char) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_context_is_persistent(context: *const GstContext) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_context_writable_structure(context: *mut GstContext) -> *mut GstStructure;

    //=========================================================================
    // GstDateTime
    //=========================================================================
    pub fn gst_date_time_get_type() -> GType;
    pub fn gst_date_time_new(tzoffset: c_float, year: c_int, month: c_int, day: c_int, hour: c_int, minute: c_int, seconds: c_double) -> *mut GstDateTime;
    pub fn gst_date_time_new_from_g_date_time(dt: *mut glib::GDateTime) -> *mut GstDateTime;
    pub fn gst_date_time_new_from_iso8601_string(string: *const c_char) -> *mut GstDateTime;
    pub fn gst_date_time_new_from_unix_epoch_local_time(secs: i64) -> *mut GstDateTime;
    pub fn gst_date_time_new_from_unix_epoch_utc(secs: i64) -> *mut GstDateTime;
    pub fn gst_date_time_new_local_time(year: c_int, month: c_int, day: c_int, hour: c_int, minute: c_int, seconds: c_double) -> *mut GstDateTime;
    pub fn gst_date_time_new_now_local_time() -> *mut GstDateTime;
    pub fn gst_date_time_new_now_utc() -> *mut GstDateTime;
    pub fn gst_date_time_new_y(year: c_int) -> *mut GstDateTime;
    pub fn gst_date_time_new_ym(year: c_int, month: c_int) -> *mut GstDateTime;
    pub fn gst_date_time_new_ymd(year: c_int, month: c_int, day: c_int) -> *mut GstDateTime;
    pub fn gst_date_time_get_day(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_get_hour(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_get_microsecond(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_get_minute(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_get_month(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_get_second(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_get_time_zone_offset(datetime: *const GstDateTime) -> c_float;
    pub fn gst_date_time_get_year(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_has_day(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_has_month(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_has_second(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_has_time(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_has_year(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_ref(datetime: *mut GstDateTime) -> *mut GstDateTime;
    pub fn gst_date_time_to_g_date_time(datetime: *mut GstDateTime) -> *mut glib::GDateTime;
    pub fn gst_date_time_to_iso8601_string(datetime: *mut GstDateTime) -> *mut c_char;
    pub fn gst_date_time_unref(datetime: *mut GstDateTime);

    //=========================================================================
    // GstDebugCategory
    //=========================================================================
    pub fn gst_debug_category_free(category: *mut GstDebugCategory);
    pub fn gst_debug_category_get_color(category: *mut GstDebugCategory) -> c_uint;
    pub fn gst_debug_category_get_description(category: *mut GstDebugCategory) -> *const c_char;
    pub fn gst_debug_category_get_name(category: *mut GstDebugCategory) -> *const c_char;
    pub fn gst_debug_category_get_threshold(category: *mut GstDebugCategory) -> GstDebugLevel;
    pub fn gst_debug_category_reset_threshold(category: *mut GstDebugCategory);
    pub fn gst_debug_category_set_threshold(category: *mut GstDebugCategory, level: GstDebugLevel);

    //=========================================================================
    // GstDebugMessage
    //=========================================================================
    pub fn gst_debug_message_get(message: *mut GstDebugMessage) -> *const c_char;

    //=========================================================================
    // GstDeviceProviderClass
    //=========================================================================
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_class_add_metadata(klass: *mut GstDeviceProviderClass, key: *const c_char, value: *const c_char);
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_class_add_static_metadata(klass: *mut GstDeviceProviderClass, key: *const c_char, value: *const c_char);
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_class_get_metadata(klass: *mut GstDeviceProviderClass, key: *const c_char) -> *const c_char;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_class_set_metadata(klass: *mut GstDeviceProviderClass, longname: *const c_char, classification: *const c_char, description: *const c_char, author: *const c_char);
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_class_set_static_metadata(klass: *mut GstDeviceProviderClass, longname: *const c_char, classification: *const c_char, description: *const c_char, author: *const c_char);

    //=========================================================================
    // GstElementClass
    //=========================================================================
    pub fn gst_element_class_add_metadata(klass: *mut GstElementClass, key: *const c_char, value: *const c_char);
    pub fn gst_element_class_add_pad_template(klass: *mut GstElementClass, templ: *mut GstPadTemplate);
    pub fn gst_element_class_add_static_metadata(klass: *mut GstElementClass, key: *const c_char, value: *const c_char);
    #[cfg(feature = "v1_8")]
    pub fn gst_element_class_add_static_pad_template(klass: *mut GstElementClass, static_templ: *mut GstStaticPadTemplate);
    pub fn gst_element_class_get_metadata(klass: *mut GstElementClass, key: *const c_char) -> *const c_char;
    pub fn gst_element_class_get_pad_template(element_class: *mut GstElementClass, name: *const c_char) -> *mut GstPadTemplate;
    pub fn gst_element_class_get_pad_template_list(element_class: *mut GstElementClass) -> *mut glib::GList;
    pub fn gst_element_class_set_metadata(klass: *mut GstElementClass, longname: *const c_char, classification: *const c_char, description: *const c_char, author: *const c_char);
    pub fn gst_element_class_set_static_metadata(klass: *mut GstElementClass, longname: *const c_char, classification: *const c_char, description: *const c_char, author: *const c_char);

    //=========================================================================
    // GstEvent
    //=========================================================================
    pub fn gst_event_get_type() -> GType;
    pub fn gst_event_new_buffer_size(format: GstFormat, minsize: i64, maxsize: i64, async: gboolean) -> *mut GstEvent;
    pub fn gst_event_new_caps(caps: *mut GstCaps) -> *mut GstEvent;
    pub fn gst_event_new_custom(type_: GstEventType, structure: *mut GstStructure) -> *mut GstEvent;
    pub fn gst_event_new_eos() -> *mut GstEvent;
    pub fn gst_event_new_flush_start() -> *mut GstEvent;
    pub fn gst_event_new_flush_stop(reset_time: gboolean) -> *mut GstEvent;
    pub fn gst_event_new_gap(timestamp: GstClockTime, duration: GstClockTime) -> *mut GstEvent;
    pub fn gst_event_new_latency(latency: GstClockTime) -> *mut GstEvent;
    pub fn gst_event_new_navigation(structure: *mut GstStructure) -> *mut GstEvent;
    #[cfg(feature = "v1_6")]
    pub fn gst_event_new_protection(system_id: *const c_char, data: *mut GstBuffer, origin: *const c_char) -> *mut GstEvent;
    pub fn gst_event_new_qos(type_: GstQOSType, proportion: c_double, diff: GstClockTimeDiff, timestamp: GstClockTime) -> *mut GstEvent;
    pub fn gst_event_new_reconfigure() -> *mut GstEvent;
    pub fn gst_event_new_seek(rate: c_double, format: GstFormat, flags: GstSeekFlags, start_type: GstSeekType, start: i64, stop_type: GstSeekType, stop: i64) -> *mut GstEvent;
    pub fn gst_event_new_segment(segment: *const GstSegment) -> *mut GstEvent;
    pub fn gst_event_new_segment_done(format: GstFormat, position: i64) -> *mut GstEvent;
    #[cfg(feature = "v1_10")]
    pub fn gst_event_new_select_streams(streams: *mut glib::GList) -> *mut GstEvent;
    pub fn gst_event_new_sink_message(name: *const c_char, msg: *mut GstMessage) -> *mut GstEvent;
    pub fn gst_event_new_step(format: GstFormat, amount: u64, rate: c_double, flush: gboolean, intermediate: gboolean) -> *mut GstEvent;
    #[cfg(feature = "v1_10")]
    pub fn gst_event_new_stream_collection(collection: *mut GstStreamCollection) -> *mut GstEvent;
    #[cfg(feature = "v1_10")]
    pub fn gst_event_new_stream_group_done(group_id: c_uint) -> *mut GstEvent;
    pub fn gst_event_new_stream_start(stream_id: *const c_char) -> *mut GstEvent;
    pub fn gst_event_new_tag(taglist: *mut GstTagList) -> *mut GstEvent;
    pub fn gst_event_new_toc(toc: *mut GstToc, updated: gboolean) -> *mut GstEvent;
    pub fn gst_event_new_toc_select(uid: *const c_char) -> *mut GstEvent;
    pub fn gst_event_copy_segment(event: *mut GstEvent, segment: *mut GstSegment);
    #[cfg(feature = "v1_4")]
    pub fn gst_event_get_running_time_offset(event: *mut GstEvent) -> i64;
    pub fn gst_event_get_seqnum(event: *mut GstEvent) -> u32;
    pub fn gst_event_get_structure(event: *mut GstEvent) -> *const GstStructure;
    pub fn gst_event_has_name(event: *mut GstEvent, name: *const c_char) -> gboolean;
    pub fn gst_event_parse_buffer_size(event: *mut GstEvent, format: *mut GstFormat, minsize: *mut i64, maxsize: *mut i64, async: *mut gboolean);
    pub fn gst_event_parse_caps(event: *mut GstEvent, caps: *mut *mut GstCaps);
    pub fn gst_event_parse_flush_stop(event: *mut GstEvent, reset_time: *mut gboolean);
    pub fn gst_event_parse_gap(event: *mut GstEvent, timestamp: *mut GstClockTime, duration: *mut GstClockTime);
    #[cfg(feature = "v1_2")]
    pub fn gst_event_parse_group_id(event: *mut GstEvent, group_id: *mut c_uint) -> gboolean;
    pub fn gst_event_parse_latency(event: *mut GstEvent, latency: *mut GstClockTime);
    #[cfg(feature = "v1_6")]
    pub fn gst_event_parse_protection(event: *mut GstEvent, system_id: *mut *const c_char, data: *mut *mut GstBuffer, origin: *mut *const c_char);
    pub fn gst_event_parse_qos(event: *mut GstEvent, type_: *mut GstQOSType, proportion: *mut c_double, diff: *mut GstClockTimeDiff, timestamp: *mut GstClockTime);
    pub fn gst_event_parse_seek(event: *mut GstEvent, rate: *mut c_double, format: *mut GstFormat, flags: *mut GstSeekFlags, start_type: *mut GstSeekType, start: *mut i64, stop_type: *mut GstSeekType, stop: *mut i64);
    pub fn gst_event_parse_segment(event: *mut GstEvent, segment: *mut *const GstSegment);
    pub fn gst_event_parse_segment_done(event: *mut GstEvent, format: *mut GstFormat, position: *mut i64);
    #[cfg(feature = "v1_10")]
    pub fn gst_event_parse_select_streams(event: *mut GstEvent, streams: *mut *mut glib::GList);
    pub fn gst_event_parse_sink_message(event: *mut GstEvent, msg: *mut *mut GstMessage);
    pub fn gst_event_parse_step(event: *mut GstEvent, format: *mut GstFormat, amount: *mut u64, rate: *mut c_double, flush: *mut gboolean, intermediate: *mut gboolean);
    #[cfg(feature = "v1_10")]
    pub fn gst_event_parse_stream(event: *mut GstEvent, stream: *mut *mut GstStream);
    #[cfg(feature = "v1_10")]
    pub fn gst_event_parse_stream_collection(event: *mut GstEvent, collection: *mut *mut GstStreamCollection);
    #[cfg(feature = "v1_2")]
    pub fn gst_event_parse_stream_flags(event: *mut GstEvent, flags: *mut GstStreamFlags);
    #[cfg(feature = "v1_10")]
    pub fn gst_event_parse_stream_group_done(event: *mut GstEvent, group_id: *mut c_uint);
    pub fn gst_event_parse_stream_start(event: *mut GstEvent, stream_id: *mut *const c_char);
    pub fn gst_event_parse_tag(event: *mut GstEvent, taglist: *mut *mut GstTagList);
    pub fn gst_event_parse_toc(event: *mut GstEvent, toc: *mut *mut GstToc, updated: *mut gboolean);
    pub fn gst_event_parse_toc_select(event: *mut GstEvent, uid: *mut *mut c_char);
    #[cfg(feature = "v1_2")]
    pub fn gst_event_set_group_id(event: *mut GstEvent, group_id: c_uint);
    #[cfg(feature = "v1_4")]
    pub fn gst_event_set_running_time_offset(event: *mut GstEvent, offset: i64);
    pub fn gst_event_set_seqnum(event: *mut GstEvent, seqnum: u32);
    #[cfg(feature = "v1_10")]
    pub fn gst_event_set_stream(event: *mut GstEvent, stream: *mut GstStream);
    #[cfg(feature = "v1_2")]
    pub fn gst_event_set_stream_flags(event: *mut GstEvent, flags: GstStreamFlags);
    pub fn gst_event_writable_structure(event: *mut GstEvent) -> *mut GstStructure;

    //=========================================================================
    // GstIterator
    //=========================================================================
    pub fn gst_iterator_get_type() -> GType;
    pub fn gst_iterator_new(size: c_uint, type_: GType, lock: *mut glib::GMutex, master_cookie: *mut u32, copy: GstIteratorCopyFunction, next: GstIteratorNextFunction, item: GstIteratorItemFunction, resync: GstIteratorResyncFunction, free: GstIteratorFreeFunction) -> *mut GstIterator;
    pub fn gst_iterator_new_list(type_: GType, lock: *mut glib::GMutex, master_cookie: *mut u32, list: *mut *mut glib::GList, owner: *mut gobject::GObject, item: GstIteratorItemFunction) -> *mut GstIterator;
    pub fn gst_iterator_new_single(type_: GType, object: *const gobject::GValue) -> *mut GstIterator;
    pub fn gst_iterator_copy(it: *const GstIterator) -> *mut GstIterator;
    pub fn gst_iterator_filter(it: *mut GstIterator, func: glib::GCompareFunc, user_data: *const gobject::GValue) -> *mut GstIterator;
    pub fn gst_iterator_find_custom(it: *mut GstIterator, func: glib::GCompareFunc, elem: *mut gobject::GValue, user_data: gpointer) -> gboolean;
    pub fn gst_iterator_fold(it: *mut GstIterator, func: GstIteratorFoldFunction, ret: *mut gobject::GValue, user_data: gpointer) -> GstIteratorResult;
    pub fn gst_iterator_foreach(it: *mut GstIterator, func: GstIteratorForeachFunction, user_data: gpointer) -> GstIteratorResult;
    pub fn gst_iterator_free(it: *mut GstIterator);
    pub fn gst_iterator_next(it: *mut GstIterator, elem: *mut gobject::GValue) -> GstIteratorResult;
    pub fn gst_iterator_push(it: *mut GstIterator, other: *mut GstIterator);
    pub fn gst_iterator_resync(it: *mut GstIterator);

    //=========================================================================
    // GstMemory
    //=========================================================================
    pub fn gst_memory_get_type() -> GType;
    pub fn gst_memory_new_wrapped(flags: GstMemoryFlags, data: gpointer, maxsize: size_t, offset: size_t, size: size_t, user_data: gpointer, notify: glib::GDestroyNotify) -> *mut GstMemory;
    pub fn gst_memory_copy(mem: *mut GstMemory, offset: ssize_t, size: ssize_t) -> *mut GstMemory;
    pub fn gst_memory_get_sizes(mem: *mut GstMemory, offset: *mut size_t, maxsize: *mut size_t) -> size_t;
    pub fn gst_memory_init(mem: *mut GstMemory, flags: GstMemoryFlags, allocator: *mut GstAllocator, parent: *mut GstMemory, maxsize: size_t, align: size_t, offset: size_t, size: size_t);
    pub fn gst_memory_is_span(mem1: *mut GstMemory, mem2: *mut GstMemory, offset: *mut size_t) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_memory_is_type(mem: *mut GstMemory, mem_type: *const c_char) -> gboolean;
    pub fn gst_memory_make_mapped(mem: *mut GstMemory, info: *mut GstMapInfo, flags: GstMapFlags) -> *mut GstMemory;
    pub fn gst_memory_map(mem: *mut GstMemory, info: *mut GstMapInfo, flags: GstMapFlags) -> gboolean;
    pub fn gst_memory_resize(mem: *mut GstMemory, offset: ssize_t, size: size_t);
    pub fn gst_memory_share(mem: *mut GstMemory, offset: ssize_t, size: ssize_t) -> *mut GstMemory;
    pub fn gst_memory_unmap(mem: *mut GstMemory, info: *mut GstMapInfo);

    //=========================================================================
    // GstMessage
    //=========================================================================
    pub fn gst_message_get_type() -> GType;
    pub fn gst_message_new_application(src: *mut GstObject, structure: *mut GstStructure) -> *mut GstMessage;
    pub fn gst_message_new_async_done(src: *mut GstObject, running_time: GstClockTime) -> *mut GstMessage;
    pub fn gst_message_new_async_start(src: *mut GstObject) -> *mut GstMessage;
    pub fn gst_message_new_buffering(src: *mut GstObject, percent: c_int) -> *mut GstMessage;
    pub fn gst_message_new_clock_lost(src: *mut GstObject, clock: *mut GstClock) -> *mut GstMessage;
    pub fn gst_message_new_clock_provide(src: *mut GstObject, clock: *mut GstClock, ready: gboolean) -> *mut GstMessage;
    pub fn gst_message_new_custom(type_: GstMessageType, src: *mut GstObject, structure: *mut GstStructure) -> *mut GstMessage;
    #[cfg(feature = "v1_4")]
    pub fn gst_message_new_device_added(src: *mut GstObject, device: *mut GstDevice) -> *mut GstMessage;
    #[cfg(feature = "v1_4")]
    pub fn gst_message_new_device_removed(src: *mut GstObject, device: *mut GstDevice) -> *mut GstMessage;
    pub fn gst_message_new_duration_changed(src: *mut GstObject) -> *mut GstMessage;
    pub fn gst_message_new_element(src: *mut GstObject, structure: *mut GstStructure) -> *mut GstMessage;
    pub fn gst_message_new_eos(src: *mut GstObject) -> *mut GstMessage;
    pub fn gst_message_new_error(src: *mut GstObject, error: *mut glib::GError, debug: *const c_char) -> *mut GstMessage;
    #[cfg(feature = "v1_10")]
    pub fn gst_message_new_error_with_details(src: *mut GstObject, error: *mut glib::GError, debug: *const c_char, details: *mut GstStructure) -> *mut GstMessage;
    #[cfg(feature = "v1_2")]
    pub fn gst_message_new_have_context(src: *mut GstObject, context: *mut GstContext) -> *mut GstMessage;
    pub fn gst_message_new_info(src: *mut GstObject, error: *mut glib::GError, debug: *const c_char) -> *mut GstMessage;
    #[cfg(feature = "v1_10")]
    pub fn gst_message_new_info_with_details(src: *mut GstObject, error: *mut glib::GError, debug: *const c_char, details: *mut GstStructure) -> *mut GstMessage;
    pub fn gst_message_new_latency(src: *mut GstObject) -> *mut GstMessage;
    #[cfg(feature = "v1_2")]
    pub fn gst_message_new_need_context(src: *mut GstObject, context_type: *const c_char) -> *mut GstMessage;
    pub fn gst_message_new_new_clock(src: *mut GstObject, clock: *mut GstClock) -> *mut GstMessage;
    pub fn gst_message_new_progress(src: *mut GstObject, type_: GstProgressType, code: *const c_char, text: *const c_char) -> *mut GstMessage;
    #[cfg(feature = "v1_10")]
    pub fn gst_message_new_property_notify(src: *mut GstObject, property_name: *const c_char, val: *mut gobject::GValue) -> *mut GstMessage;
    pub fn gst_message_new_qos(src: *mut GstObject, live: gboolean, running_time: u64, stream_time: u64, timestamp: u64, duration: u64) -> *mut GstMessage;
    #[cfg(feature = "v1_10")]
    pub fn gst_message_new_redirect(src: *mut GstObject, location: *const c_char, tag_list: *mut GstTagList, entry_struct: *const GstStructure) -> *mut GstMessage;
    pub fn gst_message_new_request_state(src: *mut GstObject, state: GstState) -> *mut GstMessage;
    pub fn gst_message_new_reset_time(src: *mut GstObject, running_time: GstClockTime) -> *mut GstMessage;
    pub fn gst_message_new_segment_done(src: *mut GstObject, format: GstFormat, position: i64) -> *mut GstMessage;
    pub fn gst_message_new_segment_start(src: *mut GstObject, format: GstFormat, position: i64) -> *mut GstMessage;
    pub fn gst_message_new_state_changed(src: *mut GstObject, oldstate: GstState, newstate: GstState, pending: GstState) -> *mut GstMessage;
    pub fn gst_message_new_state_dirty(src: *mut GstObject) -> *mut GstMessage;
    pub fn gst_message_new_step_done(src: *mut GstObject, format: GstFormat, amount: u64, rate: c_double, flush: gboolean, intermediate: gboolean, duration: u64, eos: gboolean) -> *mut GstMessage;
    pub fn gst_message_new_step_start(src: *mut GstObject, active: gboolean, format: GstFormat, amount: u64, rate: c_double, flush: gboolean, intermediate: gboolean) -> *mut GstMessage;
    #[cfg(feature = "v1_10")]
    pub fn gst_message_new_stream_collection(src: *mut GstObject, collection: *mut GstStreamCollection) -> *mut GstMessage;
    pub fn gst_message_new_stream_start(src: *mut GstObject) -> *mut GstMessage;
    pub fn gst_message_new_stream_status(src: *mut GstObject, type_: GstStreamStatusType, owner: *mut GstElement) -> *mut GstMessage;
    #[cfg(feature = "v1_10")]
    pub fn gst_message_new_streams_selected(src: *mut GstObject, collection: *mut GstStreamCollection) -> *mut GstMessage;
    pub fn gst_message_new_structure_change(src: *mut GstObject, type_: GstStructureChangeType, owner: *mut GstElement, busy: gboolean) -> *mut GstMessage;
    pub fn gst_message_new_tag(src: *mut GstObject, tag_list: *mut GstTagList) -> *mut GstMessage;
    pub fn gst_message_new_toc(src: *mut GstObject, toc: *mut GstToc, updated: gboolean) -> *mut GstMessage;
    pub fn gst_message_new_warning(src: *mut GstObject, error: *mut glib::GError, debug: *const c_char) -> *mut GstMessage;
    #[cfg(feature = "v1_10")]
    pub fn gst_message_new_warning_with_details(src: *mut GstObject, error: *mut glib::GError, debug: *const c_char, details: *mut GstStructure) -> *mut GstMessage;
    #[cfg(feature = "v1_10")]
    pub fn gst_message_add_redirect_entry(message: *mut GstMessage, location: *const c_char, tag_list: *mut GstTagList, entry_struct: *const GstStructure);
    #[cfg(feature = "v1_10")]
    pub fn gst_message_get_num_redirect_entries(message: *mut GstMessage) -> size_t;
    pub fn gst_message_get_seqnum(message: *mut GstMessage) -> u32;
    pub fn gst_message_get_stream_status_object(message: *mut GstMessage) -> *const gobject::GValue;
    pub fn gst_message_get_structure(message: *mut GstMessage) -> *const GstStructure;
    pub fn gst_message_has_name(message: *mut GstMessage, name: *const c_char) -> gboolean;
    pub fn gst_message_parse_async_done(message: *mut GstMessage, running_time: *mut GstClockTime);
    pub fn gst_message_parse_buffering(message: *mut GstMessage, percent: *mut c_int);
    pub fn gst_message_parse_buffering_stats(message: *mut GstMessage, mode: *mut GstBufferingMode, avg_in: *mut c_int, avg_out: *mut c_int, buffering_left: *mut i64);
    pub fn gst_message_parse_clock_lost(message: *mut GstMessage, clock: *mut *mut GstClock);
    pub fn gst_message_parse_clock_provide(message: *mut GstMessage, clock: *mut *mut GstClock, ready: *mut gboolean);
    #[cfg(feature = "v1_2")]
    pub fn gst_message_parse_context_type(message: *mut GstMessage, context_type: *mut *const c_char) -> gboolean;
    #[cfg(feature = "v1_4")]
    pub fn gst_message_parse_device_added(message: *mut GstMessage, device: *mut *mut GstDevice);
    #[cfg(feature = "v1_4")]
    pub fn gst_message_parse_device_removed(message: *mut GstMessage, device: *mut *mut GstDevice);
    pub fn gst_message_parse_error(message: *mut GstMessage, gerror: *mut *mut glib::GError, debug: *mut *mut c_char);
    #[cfg(feature = "v1_10")]
    pub fn gst_message_parse_error_details(message: *mut GstMessage, structure: *mut *const GstStructure);
    #[cfg(feature = "v1_2")]
    pub fn gst_message_parse_group_id(message: *mut GstMessage, group_id: *mut c_uint) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_message_parse_have_context(message: *mut GstMessage, context: *mut *mut GstContext);
    pub fn gst_message_parse_info(message: *mut GstMessage, gerror: *mut *mut glib::GError, debug: *mut *mut c_char);
    #[cfg(feature = "v1_10")]
    pub fn gst_message_parse_info_details(message: *mut GstMessage, structure: *mut *const GstStructure);
    pub fn gst_message_parse_new_clock(message: *mut GstMessage, clock: *mut *mut GstClock);
    pub fn gst_message_parse_progress(message: *mut GstMessage, type_: *mut GstProgressType, code: *mut *mut c_char, text: *mut *mut c_char);
    #[cfg(feature = "v1_10")]
    pub fn gst_message_parse_property_notify(message: *mut GstMessage, object: *mut *mut GstObject, property_name: *mut *const c_char, property_value: *mut *const gobject::GValue);
    pub fn gst_message_parse_qos(message: *mut GstMessage, live: *mut gboolean, running_time: *mut u64, stream_time: *mut u64, timestamp: *mut u64, duration: *mut u64);
    pub fn gst_message_parse_qos_stats(message: *mut GstMessage, format: *mut GstFormat, processed: *mut u64, dropped: *mut u64);
    pub fn gst_message_parse_qos_values(message: *mut GstMessage, jitter: *mut i64, proportion: *mut c_double, quality: *mut c_int);
    #[cfg(feature = "v1_10")]
    pub fn gst_message_parse_redirect_entry(message: *mut GstMessage, entry_index: size_t, location: *mut *const c_char, tag_list: *mut *mut GstTagList, entry_struct: *mut *const GstStructure);
    pub fn gst_message_parse_request_state(message: *mut GstMessage, state: *mut GstState);
    pub fn gst_message_parse_reset_time(message: *mut GstMessage, running_time: *mut GstClockTime);
    pub fn gst_message_parse_segment_done(message: *mut GstMessage, format: *mut GstFormat, position: *mut i64);
    pub fn gst_message_parse_segment_start(message: *mut GstMessage, format: *mut GstFormat, position: *mut i64);
    pub fn gst_message_parse_state_changed(message: *mut GstMessage, oldstate: *mut GstState, newstate: *mut GstState, pending: *mut GstState);
    pub fn gst_message_parse_step_done(message: *mut GstMessage, format: *mut GstFormat, amount: *mut u64, rate: *mut c_double, flush: *mut gboolean, intermediate: *mut gboolean, duration: *mut u64, eos: *mut gboolean);
    pub fn gst_message_parse_step_start(message: *mut GstMessage, active: *mut gboolean, format: *mut GstFormat, amount: *mut u64, rate: *mut c_double, flush: *mut gboolean, intermediate: *mut gboolean);
    #[cfg(feature = "v1_10")]
    pub fn gst_message_parse_stream_collection(message: *mut GstMessage, collection: *mut *mut GstStreamCollection);
    pub fn gst_message_parse_stream_status(message: *mut GstMessage, type_: *mut GstStreamStatusType, owner: *mut *mut GstElement);
    #[cfg(feature = "v1_10")]
    pub fn gst_message_parse_streams_selected(message: *mut GstMessage, collection: *mut *mut GstStreamCollection);
    pub fn gst_message_parse_structure_change(message: *mut GstMessage, type_: *mut GstStructureChangeType, owner: *mut *mut GstElement, busy: *mut gboolean);
    pub fn gst_message_parse_tag(message: *mut GstMessage, tag_list: *mut *mut GstTagList);
    pub fn gst_message_parse_toc(message: *mut GstMessage, toc: *mut *mut GstToc, updated: *mut gboolean);
    pub fn gst_message_parse_warning(message: *mut GstMessage, gerror: *mut *mut glib::GError, debug: *mut *mut c_char);
    #[cfg(feature = "v1_10")]
    pub fn gst_message_parse_warning_details(message: *mut GstMessage, structure: *mut *const GstStructure);
    pub fn gst_message_set_buffering_stats(message: *mut GstMessage, mode: GstBufferingMode, avg_in: c_int, avg_out: c_int, buffering_left: i64);
    #[cfg(feature = "v1_2")]
    pub fn gst_message_set_group_id(message: *mut GstMessage, group_id: c_uint);
    pub fn gst_message_set_qos_stats(message: *mut GstMessage, format: GstFormat, processed: u64, dropped: u64);
    pub fn gst_message_set_qos_values(message: *mut GstMessage, jitter: i64, proportion: c_double, quality: c_int);
    pub fn gst_message_set_seqnum(message: *mut GstMessage, seqnum: u32);
    pub fn gst_message_set_stream_status_object(message: *mut GstMessage, object: *const gobject::GValue);
    #[cfg(feature = "v1_10")]
    pub fn gst_message_streams_selected_add(message: *mut GstMessage, stream: *mut GstStream);
    #[cfg(feature = "v1_10")]
    pub fn gst_message_streams_selected_get_size(message: *mut GstMessage) -> c_uint;
    #[cfg(feature = "v1_10")]
    pub fn gst_message_streams_selected_get_stream(message: *mut GstMessage, idx: c_uint) -> *mut GstStream;

    //=========================================================================
    // GstMeta
    //=========================================================================
    #[cfg(feature = "v1_2")]
    pub fn gst_meta_api_type_get_tags(api: GType) -> *mut *mut c_char;
    pub fn gst_meta_api_type_has_tag(api: GType, tag: glib::GQuark) -> gboolean;
    pub fn gst_meta_api_type_register(api: *const c_char, tags: *mut *const c_char) -> GType;
    pub fn gst_meta_get_info(impl_: *const c_char) -> *const GstMetaInfo;
    pub fn gst_meta_register(api: GType, impl_: *const c_char, size: size_t, init_func: GstMetaInitFunction, free_func: GstMetaFreeFunction, transform_func: GstMetaTransformFunction) -> *const GstMetaInfo;

    //=========================================================================
    // GstMiniObject
    //=========================================================================
    pub fn gst_mini_object_copy(mini_object: *const GstMiniObject) -> *mut GstMiniObject;
    pub fn gst_mini_object_get_qdata(object: *mut GstMiniObject, quark: glib::GQuark) -> gpointer;
    pub fn gst_mini_object_init(mini_object: *mut GstMiniObject, flags: c_uint, type_: GType, copy_func: GstMiniObjectCopyFunction, dispose_func: GstMiniObjectDisposeFunction, free_func: GstMiniObjectFreeFunction);
    pub fn gst_mini_object_is_writable(mini_object: *const GstMiniObject) -> gboolean;
    pub fn gst_mini_object_lock(object: *mut GstMiniObject, flags: GstLockFlags) -> gboolean;
    pub fn gst_mini_object_make_writable(mini_object: *mut GstMiniObject) -> *mut GstMiniObject;
    pub fn gst_mini_object_ref(mini_object: *mut GstMiniObject) -> *mut GstMiniObject;
    pub fn gst_mini_object_set_qdata(object: *mut GstMiniObject, quark: glib::GQuark, data: gpointer, destroy: glib::GDestroyNotify);
    pub fn gst_mini_object_steal_qdata(object: *mut GstMiniObject, quark: glib::GQuark) -> gpointer;
    pub fn gst_mini_object_unlock(object: *mut GstMiniObject, flags: GstLockFlags);
    pub fn gst_mini_object_unref(mini_object: *mut GstMiniObject);
    pub fn gst_mini_object_weak_ref(object: *mut GstMiniObject, notify: GstMiniObjectNotify, data: gpointer);
    pub fn gst_mini_object_weak_unref(object: *mut GstMiniObject, notify: GstMiniObjectNotify, data: gpointer);
    pub fn gst_mini_object_replace(olddata: *mut *mut GstMiniObject, newdata: *mut GstMiniObject) -> gboolean;
    pub fn gst_mini_object_steal(olddata: *mut *mut GstMiniObject) -> *mut GstMiniObject;
    pub fn gst_mini_object_take(olddata: *mut *mut GstMiniObject, newdata: *mut GstMiniObject) -> gboolean;

    //=========================================================================
    // GstPadProbeInfo
    //=========================================================================
    pub fn gst_pad_probe_info_get_buffer(info: *mut GstPadProbeInfo) -> *mut GstBuffer;
    pub fn gst_pad_probe_info_get_buffer_list(info: *mut GstPadProbeInfo) -> *mut GstBufferList;
    pub fn gst_pad_probe_info_get_event(info: *mut GstPadProbeInfo) -> *mut GstEvent;
    pub fn gst_pad_probe_info_get_query(info: *mut GstPadProbeInfo) -> *mut GstQuery;

    //=========================================================================
    // GstParentBufferMeta
    //=========================================================================
    #[cfg(feature = "v1_6")]
    pub fn gst_parent_buffer_meta_get_info() -> *const GstMetaInfo;

    //=========================================================================
    // GstParseContext
    //=========================================================================
    pub fn gst_parse_context_get_type() -> GType;
    pub fn gst_parse_context_new() -> *mut GstParseContext;
    pub fn gst_parse_context_free(context: *mut GstParseContext);
    pub fn gst_parse_context_get_missing_elements(context: *mut GstParseContext) -> *mut *mut c_char;

    //=========================================================================
    // GstPoll
    //=========================================================================
    pub fn gst_poll_add_fd(set: *mut GstPoll, fd: *mut GstPollFD) -> gboolean;
    pub fn gst_poll_fd_can_read(set: *const GstPoll, fd: *mut GstPollFD) -> gboolean;
    pub fn gst_poll_fd_can_write(set: *const GstPoll, fd: *mut GstPollFD) -> gboolean;
    pub fn gst_poll_fd_ctl_read(set: *mut GstPoll, fd: *mut GstPollFD, active: gboolean) -> gboolean;
    pub fn gst_poll_fd_ctl_write(set: *mut GstPoll, fd: *mut GstPollFD, active: gboolean) -> gboolean;
    pub fn gst_poll_fd_has_closed(set: *const GstPoll, fd: *mut GstPollFD) -> gboolean;
    pub fn gst_poll_fd_has_error(set: *const GstPoll, fd: *mut GstPollFD) -> gboolean;
    pub fn gst_poll_fd_ignored(set: *mut GstPoll, fd: *mut GstPollFD);
    pub fn gst_poll_free(set: *mut GstPoll);
    pub fn gst_poll_get_read_gpollfd(set: *mut GstPoll, fd: *mut glib::GPollFD);
    pub fn gst_poll_read_control(set: *mut GstPoll) -> gboolean;
    pub fn gst_poll_remove_fd(set: *mut GstPoll, fd: *mut GstPollFD) -> gboolean;
    pub fn gst_poll_restart(set: *mut GstPoll);
    pub fn gst_poll_set_controllable(set: *mut GstPoll, controllable: gboolean) -> gboolean;
    pub fn gst_poll_set_flushing(set: *mut GstPoll, flushing: gboolean);
    pub fn gst_poll_wait(set: *mut GstPoll, timeout: GstClockTime) -> c_int;
    pub fn gst_poll_write_control(set: *mut GstPoll) -> gboolean;
    pub fn gst_poll_new(controllable: gboolean) -> *mut GstPoll;
    pub fn gst_poll_new_timer() -> *mut GstPoll;

    //=========================================================================
    // GstPollFD
    //=========================================================================
    pub fn gst_poll_fd_init(fd: *mut GstPollFD);

    //=========================================================================
    // GstProtectionMeta
    //=========================================================================
    pub fn gst_protection_meta_get_info() -> *const GstMetaInfo;

    //=========================================================================
    // GstQuery
    //=========================================================================
    pub fn gst_query_get_type() -> GType;
    pub fn gst_query_new_accept_caps(caps: *mut GstCaps) -> *mut GstQuery;
    pub fn gst_query_new_allocation(caps: *mut GstCaps, need_pool: gboolean) -> *mut GstQuery;
    pub fn gst_query_new_buffering(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_new_caps(filter: *mut GstCaps) -> *mut GstQuery;
    #[cfg(feature = "v1_2")]
    pub fn gst_query_new_context(context_type: *const c_char) -> *mut GstQuery;
    pub fn gst_query_new_convert(src_format: GstFormat, value: i64, dest_format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_new_custom(type_: GstQueryType, structure: *mut GstStructure) -> *mut GstQuery;
    pub fn gst_query_new_drain() -> *mut GstQuery;
    pub fn gst_query_new_duration(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_new_formats() -> *mut GstQuery;
    pub fn gst_query_new_latency() -> *mut GstQuery;
    pub fn gst_query_new_position(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_new_scheduling() -> *mut GstQuery;
    pub fn gst_query_new_seeking(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_new_segment(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_new_uri() -> *mut GstQuery;
    pub fn gst_query_add_allocation_meta(query: *mut GstQuery, api: GType, params: *const GstStructure);
    pub fn gst_query_add_allocation_param(query: *mut GstQuery, allocator: *mut GstAllocator, params: *const GstAllocationParams);
    pub fn gst_query_add_allocation_pool(query: *mut GstQuery, pool: *mut GstBufferPool, size: c_uint, min_buffers: c_uint, max_buffers: c_uint);
    pub fn gst_query_add_buffering_range(query: *mut GstQuery, start: i64, stop: i64) -> gboolean;
    pub fn gst_query_add_scheduling_mode(query: *mut GstQuery, mode: GstPadMode);
    pub fn gst_query_find_allocation_meta(query: *mut GstQuery, api: GType, index: *mut c_uint) -> gboolean;
    pub fn gst_query_get_n_allocation_metas(query: *mut GstQuery) -> c_uint;
    pub fn gst_query_get_n_allocation_params(query: *mut GstQuery) -> c_uint;
    pub fn gst_query_get_n_allocation_pools(query: *mut GstQuery) -> c_uint;
    pub fn gst_query_get_n_buffering_ranges(query: *mut GstQuery) -> c_uint;
    pub fn gst_query_get_n_scheduling_modes(query: *mut GstQuery) -> c_uint;
    pub fn gst_query_get_structure(query: *mut GstQuery) -> *const GstStructure;
    pub fn gst_query_has_scheduling_mode(query: *mut GstQuery, mode: GstPadMode) -> gboolean;
    pub fn gst_query_has_scheduling_mode_with_flags(query: *mut GstQuery, mode: GstPadMode, flags: GstSchedulingFlags) -> gboolean;
    pub fn gst_query_parse_accept_caps(query: *mut GstQuery, caps: *mut *mut GstCaps);
    pub fn gst_query_parse_accept_caps_result(query: *mut GstQuery, result: *mut gboolean);
    pub fn gst_query_parse_allocation(query: *mut GstQuery, caps: *mut *mut GstCaps, need_pool: *mut gboolean);
    pub fn gst_query_parse_buffering_percent(query: *mut GstQuery, busy: *mut gboolean, percent: *mut c_int);
    pub fn gst_query_parse_buffering_range(query: *mut GstQuery, format: *mut GstFormat, start: *mut i64, stop: *mut i64, estimated_total: *mut i64);
    pub fn gst_query_parse_buffering_stats(query: *mut GstQuery, mode: *mut GstBufferingMode, avg_in: *mut c_int, avg_out: *mut c_int, buffering_left: *mut i64);
    pub fn gst_query_parse_caps(query: *mut GstQuery, filter: *mut *mut GstCaps);
    pub fn gst_query_parse_caps_result(query: *mut GstQuery, caps: *mut *mut GstCaps);
    #[cfg(feature = "v1_2")]
    pub fn gst_query_parse_context(query: *mut GstQuery, context: *mut *mut GstContext);
    #[cfg(feature = "v1_2")]
    pub fn gst_query_parse_context_type(query: *mut GstQuery, context_type: *mut *const c_char) -> gboolean;
    pub fn gst_query_parse_convert(query: *mut GstQuery, src_format: *mut GstFormat, src_value: *mut i64, dest_format: *mut GstFormat, dest_value: *mut i64);
    pub fn gst_query_parse_duration(query: *mut GstQuery, format: *mut GstFormat, duration: *mut i64);
    pub fn gst_query_parse_latency(query: *mut GstQuery, live: *mut gboolean, min_latency: *mut GstClockTime, max_latency: *mut GstClockTime);
    pub fn gst_query_parse_n_formats(query: *mut GstQuery, n_formats: *mut c_uint);
    pub fn gst_query_parse_nth_allocation_meta(query: *mut GstQuery, index: c_uint, params: *mut *const GstStructure) -> GType;
    pub fn gst_query_parse_nth_allocation_param(query: *mut GstQuery, index: c_uint, allocator: *mut *mut GstAllocator, params: *mut GstAllocationParams);
    pub fn gst_query_parse_nth_allocation_pool(query: *mut GstQuery, index: c_uint, pool: *mut *mut GstBufferPool, size: *mut c_uint, min_buffers: *mut c_uint, max_buffers: *mut c_uint);
    pub fn gst_query_parse_nth_buffering_range(query: *mut GstQuery, index: c_uint, start: *mut i64, stop: *mut i64) -> gboolean;
    pub fn gst_query_parse_nth_format(query: *mut GstQuery, nth: c_uint, format: *mut GstFormat);
    pub fn gst_query_parse_nth_scheduling_mode(query: *mut GstQuery, index: c_uint) -> GstPadMode;
    pub fn gst_query_parse_position(query: *mut GstQuery, format: *mut GstFormat, cur: *mut i64);
    pub fn gst_query_parse_scheduling(query: *mut GstQuery, flags: *mut GstSchedulingFlags, minsize: *mut c_int, maxsize: *mut c_int, align: *mut c_int);
    pub fn gst_query_parse_seeking(query: *mut GstQuery, format: *mut GstFormat, seekable: *mut gboolean, segment_start: *mut i64, segment_end: *mut i64);
    pub fn gst_query_parse_segment(query: *mut GstQuery, rate: *mut c_double, format: *mut GstFormat, start_value: *mut i64, stop_value: *mut i64);
    pub fn gst_query_parse_uri(query: *mut GstQuery, uri: *mut *mut c_char);
    #[cfg(feature = "v1_2")]
    pub fn gst_query_parse_uri_redirection(query: *mut GstQuery, uri: *mut *mut c_char);
    #[cfg(feature = "v1_4")]
    pub fn gst_query_parse_uri_redirection_permanent(query: *mut GstQuery, permanent: *mut gboolean);
    pub fn gst_query_remove_nth_allocation_meta(query: *mut GstQuery, index: c_uint);
    #[cfg(feature = "v1_2")]
    pub fn gst_query_remove_nth_allocation_param(query: *mut GstQuery, index: c_uint);
    #[cfg(feature = "v1_2")]
    pub fn gst_query_remove_nth_allocation_pool(query: *mut GstQuery, index: c_uint);
    pub fn gst_query_set_accept_caps_result(query: *mut GstQuery, result: gboolean);
    pub fn gst_query_set_buffering_percent(query: *mut GstQuery, busy: gboolean, percent: c_int);
    pub fn gst_query_set_buffering_range(query: *mut GstQuery, format: GstFormat, start: i64, stop: i64, estimated_total: i64);
    pub fn gst_query_set_buffering_stats(query: *mut GstQuery, mode: GstBufferingMode, avg_in: c_int, avg_out: c_int, buffering_left: i64);
    pub fn gst_query_set_caps_result(query: *mut GstQuery, caps: *mut GstCaps);
    #[cfg(feature = "v1_2")]
    pub fn gst_query_set_context(query: *mut GstQuery, context: *mut GstContext);
    pub fn gst_query_set_convert(query: *mut GstQuery, src_format: GstFormat, src_value: i64, dest_format: GstFormat, dest_value: i64);
    pub fn gst_query_set_duration(query: *mut GstQuery, format: GstFormat, duration: i64);
    pub fn gst_query_set_formats(query: *mut GstQuery, n_formats: c_int, ...);
    pub fn gst_query_set_formatsv(query: *mut GstQuery, n_formats: c_int, formats: *mut GstFormat);
    pub fn gst_query_set_latency(query: *mut GstQuery, live: gboolean, min_latency: GstClockTime, max_latency: GstClockTime);
    pub fn gst_query_set_nth_allocation_param(query: *mut GstQuery, index: c_uint, allocator: *mut GstAllocator, params: *const GstAllocationParams);
    pub fn gst_query_set_nth_allocation_pool(query: *mut GstQuery, index: c_uint, pool: *mut GstBufferPool, size: c_uint, min_buffers: c_uint, max_buffers: c_uint);
    pub fn gst_query_set_position(query: *mut GstQuery, format: GstFormat, cur: i64);
    pub fn gst_query_set_scheduling(query: *mut GstQuery, flags: GstSchedulingFlags, minsize: c_int, maxsize: c_int, align: c_int);
    pub fn gst_query_set_seeking(query: *mut GstQuery, format: GstFormat, seekable: gboolean, segment_start: i64, segment_end: i64);
    pub fn gst_query_set_segment(query: *mut GstQuery, rate: c_double, format: GstFormat, start_value: i64, stop_value: i64);
    pub fn gst_query_set_uri(query: *mut GstQuery, uri: *const c_char);
    #[cfg(feature = "v1_2")]
    pub fn gst_query_set_uri_redirection(query: *mut GstQuery, uri: *const c_char);
    #[cfg(feature = "v1_4")]
    pub fn gst_query_set_uri_redirection_permanent(query: *mut GstQuery, permanent: gboolean);
    pub fn gst_query_writable_structure(query: *mut GstQuery) -> *mut GstStructure;

    //=========================================================================
    // GstSample
    //=========================================================================
    pub fn gst_sample_get_type() -> GType;
    pub fn gst_sample_new(buffer: *mut GstBuffer, caps: *mut GstCaps, segment: *const GstSegment, info: *mut GstStructure) -> *mut GstSample;
    pub fn gst_sample_get_buffer(sample: *mut GstSample) -> *mut GstBuffer;
    #[cfg(feature = "v1_6")]
    pub fn gst_sample_get_buffer_list(sample: *mut GstSample) -> *mut GstBufferList;
    pub fn gst_sample_get_caps(sample: *mut GstSample) -> *mut GstCaps;
    pub fn gst_sample_get_info(sample: *mut GstSample) -> *const GstStructure;
    pub fn gst_sample_get_segment(sample: *mut GstSample) -> *mut GstSegment;
    #[cfg(feature = "v1_6")]
    pub fn gst_sample_set_buffer_list(sample: *mut GstSample, buffer_list: *mut GstBufferList);

    //=========================================================================
    // GstSegment
    //=========================================================================
    pub fn gst_segment_get_type() -> GType;
    pub fn gst_segment_new() -> *mut GstSegment;
    pub fn gst_segment_clip(segment: *const GstSegment, format: GstFormat, start: u64, stop: u64, clip_start: *mut u64, clip_stop: *mut u64) -> gboolean;
    pub fn gst_segment_copy(segment: *const GstSegment) -> *mut GstSegment;
    pub fn gst_segment_copy_into(src: *const GstSegment, dest: *mut GstSegment);
    pub fn gst_segment_do_seek(segment: *mut GstSegment, rate: c_double, format: GstFormat, flags: GstSeekFlags, start_type: GstSeekType, start: u64, stop_type: GstSeekType, stop: u64, update: *mut gboolean) -> gboolean;
    pub fn gst_segment_free(segment: *mut GstSegment);
    pub fn gst_segment_init(segment: *mut GstSegment, format: GstFormat);
    #[cfg(feature = "v1_6")]
    pub fn gst_segment_is_equal(s0: *const GstSegment, s1: *const GstSegment) -> gboolean;
    #[cfg(feature = "v1_2_3")]
    pub fn gst_segment_offset_running_time(segment: *mut GstSegment, format: GstFormat, offset: i64) -> gboolean;
    #[cfg(feature = "v1_8")]
    pub fn gst_segment_position_from_running_time(segment: *const GstSegment, format: GstFormat, running_time: u64) -> u64;
    #[cfg(feature = "v1_8")]
    pub fn gst_segment_position_from_running_time_full(segment: *const GstSegment, format: GstFormat, running_time: u64, position: *mut u64) -> c_int;
    #[cfg(feature = "v1_8")]
    pub fn gst_segment_position_from_stream_time(segment: *const GstSegment, format: GstFormat, stream_time: u64) -> u64;
    #[cfg(feature = "v1_8")]
    pub fn gst_segment_position_from_stream_time_full(segment: *const GstSegment, format: GstFormat, stream_time: u64, position: *mut u64) -> c_int;
    pub fn gst_segment_set_running_time(segment: *mut GstSegment, format: GstFormat, running_time: u64) -> gboolean;
    pub fn gst_segment_to_position(segment: *const GstSegment, format: GstFormat, running_time: u64) -> u64;
    pub fn gst_segment_to_running_time(segment: *const GstSegment, format: GstFormat, position: u64) -> u64;
    #[cfg(feature = "v1_6")]
    pub fn gst_segment_to_running_time_full(segment: *const GstSegment, format: GstFormat, position: u64, running_time: *mut u64) -> c_int;
    #[cfg(feature = "v1_8")]
    pub fn gst_segment_to_stream_time(segment: *const GstSegment, format: GstFormat, position: u64) -> u64;
    #[cfg(feature = "v1_8")]
    pub fn gst_segment_to_stream_time_full(segment: *const GstSegment, format: GstFormat, position: u64, stream_time: *mut u64) -> c_int;

    //=========================================================================
    // GstStaticCaps
    //=========================================================================
    pub fn gst_static_caps_cleanup(static_caps: *mut GstStaticCaps);
    pub fn gst_static_caps_get(static_caps: *mut GstStaticCaps) -> *mut GstCaps;

    //=========================================================================
    // GstStaticPadTemplate
    //=========================================================================
    pub fn gst_static_pad_template_get(pad_template: *mut GstStaticPadTemplate) -> *mut GstPadTemplate;
    pub fn gst_static_pad_template_get_caps(templ: *mut GstStaticPadTemplate) -> *mut GstCaps;

    //=========================================================================
    // GstStructure
    //=========================================================================
    pub fn gst_structure_get_type() -> GType;
    pub fn gst_structure_new(name: *const c_char, firstfield: *const c_char, ...) -> *mut GstStructure;
    pub fn gst_structure_new_empty(name: *const c_char) -> *mut GstStructure;
    #[cfg(feature = "v1_2")]
    pub fn gst_structure_new_from_string(string: *const c_char) -> *mut GstStructure;
    pub fn gst_structure_new_id(name_quark: glib::GQuark, field_quark: glib::GQuark, ...) -> *mut GstStructure;
    pub fn gst_structure_new_id_empty(quark: glib::GQuark) -> *mut GstStructure;
    //pub fn gst_structure_new_valist(name: *const c_char, firstfield: *const c_char, varargs: /*Unimplemented*/va_list) -> *mut GstStructure;
    pub fn gst_structure_can_intersect(struct1: *const GstStructure, struct2: *const GstStructure) -> gboolean;
    pub fn gst_structure_copy(structure: *const GstStructure) -> *mut GstStructure;
    #[cfg(feature = "v1_6")]
    pub fn gst_structure_filter_and_map_in_place(structure: *mut GstStructure, func: GstStructureFilterMapFunc, user_data: gpointer);
    pub fn gst_structure_fixate(structure: *mut GstStructure);
    pub fn gst_structure_fixate_field(structure: *mut GstStructure, field_name: *const c_char) -> gboolean;
    pub fn gst_structure_fixate_field_boolean(structure: *mut GstStructure, field_name: *const c_char, target: gboolean) -> gboolean;
    pub fn gst_structure_fixate_field_nearest_double(structure: *mut GstStructure, field_name: *const c_char, target: c_double) -> gboolean;
    pub fn gst_structure_fixate_field_nearest_fraction(structure: *mut GstStructure, field_name: *const c_char, target_numerator: c_int, target_denominator: c_int) -> gboolean;
    pub fn gst_structure_fixate_field_nearest_int(structure: *mut GstStructure, field_name: *const c_char, target: c_int) -> gboolean;
    pub fn gst_structure_fixate_field_string(structure: *mut GstStructure, field_name: *const c_char, target: *const c_char) -> gboolean;
    pub fn gst_structure_foreach(structure: *const GstStructure, func: GstStructureForeachFunc, user_data: gpointer) -> gboolean;
    pub fn gst_structure_free(structure: *mut GstStructure);
    pub fn gst_structure_get(structure: *const GstStructure, first_fieldname: *const c_char, ...) -> gboolean;
    pub fn gst_structure_get_array(structure: *mut GstStructure, fieldname: *const c_char, array: *mut *mut gobject::GValueArray) -> gboolean;
    pub fn gst_structure_get_boolean(structure: *const GstStructure, fieldname: *const c_char, value: *mut gboolean) -> gboolean;
    pub fn gst_structure_get_clock_time(structure: *const GstStructure, fieldname: *const c_char, value: *mut GstClockTime) -> gboolean;
    pub fn gst_structure_get_date(structure: *const GstStructure, fieldname: *const c_char, value: *mut *mut glib::GDate) -> gboolean;
    pub fn gst_structure_get_date_time(structure: *const GstStructure, fieldname: *const c_char, value: *mut *mut GstDateTime) -> gboolean;
    pub fn gst_structure_get_double(structure: *const GstStructure, fieldname: *const c_char, value: *mut c_double) -> gboolean;
    pub fn gst_structure_get_enum(structure: *const GstStructure, fieldname: *const c_char, enumtype: GType, value: *mut c_int) -> gboolean;
    pub fn gst_structure_get_field_type(structure: *const GstStructure, fieldname: *const c_char) -> GType;
    #[cfg(feature = "v1_6")]
    pub fn gst_structure_get_flagset(structure: *const GstStructure, fieldname: *const c_char, value_flags: *mut c_uint, value_mask: *mut c_uint) -> gboolean;
    pub fn gst_structure_get_fraction(structure: *const GstStructure, fieldname: *const c_char, value_numerator: *mut c_int, value_denominator: *mut c_int) -> gboolean;
    pub fn gst_structure_get_int(structure: *const GstStructure, fieldname: *const c_char, value: *mut c_int) -> gboolean;
    #[cfg(feature = "v1_4")]
    pub fn gst_structure_get_int64(structure: *const GstStructure, fieldname: *const c_char, value: *mut i64) -> gboolean;
    pub fn gst_structure_get_list(structure: *mut GstStructure, fieldname: *const c_char, array: *mut *mut gobject::GValueArray) -> gboolean;
    pub fn gst_structure_get_name(structure: *const GstStructure) -> *const c_char;
    pub fn gst_structure_get_name_id(structure: *const GstStructure) -> glib::GQuark;
    pub fn gst_structure_get_string(structure: *const GstStructure, fieldname: *const c_char) -> *const c_char;
    pub fn gst_structure_get_uint(structure: *const GstStructure, fieldname: *const c_char, value: *mut c_uint) -> gboolean;
    #[cfg(feature = "v1_4")]
    pub fn gst_structure_get_uint64(structure: *const GstStructure, fieldname: *const c_char, value: *mut u64) -> gboolean;
    //pub fn gst_structure_get_valist(structure: *const GstStructure, first_fieldname: *const c_char, args: /*Unimplemented*/va_list) -> gboolean;
    pub fn gst_structure_get_value(structure: *const GstStructure, fieldname: *const c_char) -> *const gobject::GValue;
    pub fn gst_structure_has_field(structure: *const GstStructure, fieldname: *const c_char) -> gboolean;
    pub fn gst_structure_has_field_typed(structure: *const GstStructure, fieldname: *const c_char, type_: GType) -> gboolean;
    pub fn gst_structure_has_name(structure: *const GstStructure, name: *const c_char) -> gboolean;
    pub fn gst_structure_id_get(structure: *const GstStructure, first_field_id: glib::GQuark, ...) -> gboolean;
    //pub fn gst_structure_id_get_valist(structure: *const GstStructure, first_field_id: glib::GQuark, args: /*Unimplemented*/va_list) -> gboolean;
    pub fn gst_structure_id_get_value(structure: *const GstStructure, field: glib::GQuark) -> *const gobject::GValue;
    pub fn gst_structure_id_has_field(structure: *const GstStructure, field: glib::GQuark) -> gboolean;
    pub fn gst_structure_id_has_field_typed(structure: *const GstStructure, field: glib::GQuark, type_: GType) -> gboolean;
    pub fn gst_structure_id_set(structure: *mut GstStructure, fieldname: glib::GQuark, ...);
    //pub fn gst_structure_id_set_valist(structure: *mut GstStructure, fieldname: glib::GQuark, varargs: /*Unimplemented*/va_list);
    pub fn gst_structure_id_set_value(structure: *mut GstStructure, field: glib::GQuark, value: *const gobject::GValue);
    pub fn gst_structure_id_take_value(structure: *mut GstStructure, field: glib::GQuark, value: *mut gobject::GValue);
    pub fn gst_structure_intersect(struct1: *const GstStructure, struct2: *const GstStructure) -> *mut GstStructure;
    pub fn gst_structure_is_equal(structure1: *const GstStructure, structure2: *const GstStructure) -> gboolean;
    pub fn gst_structure_is_subset(subset: *const GstStructure, superset: *const GstStructure) -> gboolean;
    pub fn gst_structure_map_in_place(structure: *mut GstStructure, func: GstStructureMapFunc, user_data: gpointer) -> gboolean;
    pub fn gst_structure_n_fields(structure: *const GstStructure) -> c_int;
    pub fn gst_structure_nth_field_name(structure: *const GstStructure, index: c_uint) -> *const c_char;
    pub fn gst_structure_remove_all_fields(structure: *mut GstStructure);
    pub fn gst_structure_remove_field(structure: *mut GstStructure, fieldname: *const c_char);
    pub fn gst_structure_remove_fields(structure: *mut GstStructure, fieldname: *const c_char, ...);
    //pub fn gst_structure_remove_fields_valist(structure: *mut GstStructure, fieldname: *const c_char, varargs: /*Unimplemented*/va_list);
    pub fn gst_structure_set(structure: *mut GstStructure, fieldname: *const c_char, ...);
    pub fn gst_structure_set_array(structure: *mut GstStructure, fieldname: *const c_char, array: *const gobject::GValueArray);
    pub fn gst_structure_set_list(structure: *mut GstStructure, fieldname: *const c_char, array: *const gobject::GValueArray);
    pub fn gst_structure_set_name(structure: *mut GstStructure, name: *const c_char);
    pub fn gst_structure_set_parent_refcount(structure: *mut GstStructure, refcount: *mut c_int) -> gboolean;
    //pub fn gst_structure_set_valist(structure: *mut GstStructure, fieldname: *const c_char, varargs: /*Unimplemented*/va_list);
    pub fn gst_structure_set_value(structure: *mut GstStructure, fieldname: *const c_char, value: *const gobject::GValue);
    pub fn gst_structure_take_value(structure: *mut GstStructure, fieldname: *const c_char, value: *mut gobject::GValue);
    pub fn gst_structure_to_string(structure: *const GstStructure) -> *mut c_char;
    pub fn gst_structure_from_string(string: *const c_char, end: *mut *mut c_char) -> *mut GstStructure;

    //=========================================================================
    // GstTagList
    //=========================================================================
    pub fn gst_tag_list_get_type() -> GType;
    pub fn gst_tag_list_new(tag: *const c_char, ...) -> *mut GstTagList;
    pub fn gst_tag_list_new_empty() -> *mut GstTagList;
    pub fn gst_tag_list_new_from_string(str: *const c_char) -> *mut GstTagList;
    //pub fn gst_tag_list_new_valist(var_args: /*Unimplemented*/va_list) -> *mut GstTagList;
    pub fn gst_tag_list_add(list: *mut GstTagList, mode: GstTagMergeMode, tag: *const c_char, ...);
    //pub fn gst_tag_list_add_valist(list: *mut GstTagList, mode: GstTagMergeMode, tag: *const c_char, var_args: /*Unimplemented*/va_list);
    //pub fn gst_tag_list_add_valist_values(list: *mut GstTagList, mode: GstTagMergeMode, tag: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn gst_tag_list_add_value(list: *mut GstTagList, mode: GstTagMergeMode, tag: *const c_char, value: *const gobject::GValue);
    pub fn gst_tag_list_add_values(list: *mut GstTagList, mode: GstTagMergeMode, tag: *const c_char, ...);
    pub fn gst_tag_list_foreach(list: *const GstTagList, func: GstTagForeachFunc, user_data: gpointer);
    pub fn gst_tag_list_get_boolean(list: *const GstTagList, tag: *const c_char, value: *mut gboolean) -> gboolean;
    pub fn gst_tag_list_get_boolean_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut gboolean) -> gboolean;
    pub fn gst_tag_list_get_date(list: *const GstTagList, tag: *const c_char, value: *mut *mut glib::GDate) -> gboolean;
    pub fn gst_tag_list_get_date_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut *mut glib::GDate) -> gboolean;
    pub fn gst_tag_list_get_date_time(list: *const GstTagList, tag: *const c_char, value: *mut *mut GstDateTime) -> gboolean;
    pub fn gst_tag_list_get_date_time_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut *mut GstDateTime) -> gboolean;
    pub fn gst_tag_list_get_double(list: *const GstTagList, tag: *const c_char, value: *mut c_double) -> gboolean;
    pub fn gst_tag_list_get_double_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut c_double) -> gboolean;
    pub fn gst_tag_list_get_float(list: *const GstTagList, tag: *const c_char, value: *mut c_float) -> gboolean;
    pub fn gst_tag_list_get_float_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut c_float) -> gboolean;
    pub fn gst_tag_list_get_int(list: *const GstTagList, tag: *const c_char, value: *mut c_int) -> gboolean;
    pub fn gst_tag_list_get_int64(list: *const GstTagList, tag: *const c_char, value: *mut i64) -> gboolean;
    pub fn gst_tag_list_get_int64_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut i64) -> gboolean;
    pub fn gst_tag_list_get_int_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut c_int) -> gboolean;
    pub fn gst_tag_list_get_pointer(list: *const GstTagList, tag: *const c_char, value: *mut gpointer) -> gboolean;
    pub fn gst_tag_list_get_pointer_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut gpointer) -> gboolean;
    pub fn gst_tag_list_get_sample(list: *const GstTagList, tag: *const c_char, sample: *mut *mut GstSample) -> gboolean;
    pub fn gst_tag_list_get_sample_index(list: *const GstTagList, tag: *const c_char, index: c_uint, sample: *mut *mut GstSample) -> gboolean;
    pub fn gst_tag_list_get_scope(list: *const GstTagList) -> GstTagScope;
    pub fn gst_tag_list_get_string(list: *const GstTagList, tag: *const c_char, value: *mut *mut c_char) -> gboolean;
    pub fn gst_tag_list_get_string_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut *mut c_char) -> gboolean;
    pub fn gst_tag_list_get_tag_size(list: *const GstTagList, tag: *const c_char) -> c_uint;
    pub fn gst_tag_list_get_uint(list: *const GstTagList, tag: *const c_char, value: *mut c_uint) -> gboolean;
    pub fn gst_tag_list_get_uint64(list: *const GstTagList, tag: *const c_char, value: *mut u64) -> gboolean;
    pub fn gst_tag_list_get_uint64_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut u64) -> gboolean;
    pub fn gst_tag_list_get_uint_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut c_uint) -> gboolean;
    pub fn gst_tag_list_get_value_index(list: *const GstTagList, tag: *const c_char, index: c_uint) -> *const gobject::GValue;
    pub fn gst_tag_list_insert(into: *mut GstTagList, from: *const GstTagList, mode: GstTagMergeMode);
    pub fn gst_tag_list_is_empty(list: *const GstTagList) -> gboolean;
    pub fn gst_tag_list_is_equal(list1: *const GstTagList, list2: *const GstTagList) -> gboolean;
    pub fn gst_tag_list_merge(list1: *const GstTagList, list2: *const GstTagList, mode: GstTagMergeMode) -> *mut GstTagList;
    pub fn gst_tag_list_n_tags(list: *const GstTagList) -> c_int;
    pub fn gst_tag_list_nth_tag_name(list: *const GstTagList, index: c_uint) -> *const c_char;
    pub fn gst_tag_list_peek_string_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut *const c_char) -> gboolean;
    pub fn gst_tag_list_remove_tag(list: *mut GstTagList, tag: *const c_char);
    pub fn gst_tag_list_set_scope(list: *mut GstTagList, scope: GstTagScope);
    pub fn gst_tag_list_to_string(list: *const GstTagList) -> *mut c_char;
    pub fn gst_tag_list_copy_value(dest: *mut gobject::GValue, list: *const GstTagList, tag: *const c_char) -> gboolean;

    //=========================================================================
    // GstToc
    //=========================================================================
    pub fn gst_toc_get_type() -> GType;
    pub fn gst_toc_new(scope: GstTocScope) -> *mut GstToc;
    pub fn gst_toc_append_entry(toc: *mut GstToc, entry: *mut GstTocEntry);
    pub fn gst_toc_dump(toc: *mut GstToc);
    pub fn gst_toc_find_entry(toc: *const GstToc, uid: *const c_char) -> *mut GstTocEntry;
    pub fn gst_toc_get_entries(toc: *const GstToc) -> *mut glib::GList;
    pub fn gst_toc_get_scope(toc: *const GstToc) -> GstTocScope;
    pub fn gst_toc_get_tags(toc: *const GstToc) -> *mut GstTagList;
    pub fn gst_toc_merge_tags(toc: *mut GstToc, tags: *mut GstTagList, mode: GstTagMergeMode);
    pub fn gst_toc_set_tags(toc: *mut GstToc, tags: *mut GstTagList);

    //=========================================================================
    // GstTocEntry
    //=========================================================================
    pub fn gst_toc_entry_get_type() -> GType;
    pub fn gst_toc_entry_new(type_: GstTocEntryType, uid: *const c_char) -> *mut GstTocEntry;
    pub fn gst_toc_entry_append_sub_entry(entry: *mut GstTocEntry, subentry: *mut GstTocEntry);
    pub fn gst_toc_entry_get_entry_type(entry: *const GstTocEntry) -> GstTocEntryType;
    #[cfg(feature = "v1_4")]
    pub fn gst_toc_entry_get_loop(entry: *const GstTocEntry, loop_type: *mut GstTocLoopType, repeat_count: *mut c_int) -> gboolean;
    pub fn gst_toc_entry_get_parent(entry: *mut GstTocEntry) -> *mut GstTocEntry;
    pub fn gst_toc_entry_get_start_stop_times(entry: *const GstTocEntry, start: *mut i64, stop: *mut i64) -> gboolean;
    pub fn gst_toc_entry_get_sub_entries(entry: *const GstTocEntry) -> *mut glib::GList;
    pub fn gst_toc_entry_get_tags(entry: *const GstTocEntry) -> *mut GstTagList;
    pub fn gst_toc_entry_get_toc(entry: *mut GstTocEntry) -> *mut GstToc;
    pub fn gst_toc_entry_get_uid(entry: *const GstTocEntry) -> *const c_char;
    pub fn gst_toc_entry_is_alternative(entry: *const GstTocEntry) -> gboolean;
    pub fn gst_toc_entry_is_sequence(entry: *const GstTocEntry) -> gboolean;
    pub fn gst_toc_entry_merge_tags(entry: *mut GstTocEntry, tags: *mut GstTagList, mode: GstTagMergeMode);
    #[cfg(feature = "v1_4")]
    pub fn gst_toc_entry_set_loop(entry: *mut GstTocEntry, loop_type: GstTocLoopType, repeat_count: c_int);
    pub fn gst_toc_entry_set_start_stop_times(entry: *mut GstTocEntry, start: i64, stop: i64);
    pub fn gst_toc_entry_set_tags(entry: *mut GstTocEntry, tags: *mut GstTagList);

    //=========================================================================
    // GstTypeFind
    //=========================================================================
    pub fn gst_type_find_get_length(find: *mut GstTypeFind) -> u64;
    pub fn gst_type_find_peek(find: *mut GstTypeFind, offset: i64, size: c_uint) -> *mut u8;
    pub fn gst_type_find_suggest(find: *mut GstTypeFind, probability: c_uint, caps: *mut GstCaps);
    pub fn gst_type_find_suggest_simple(find: *mut GstTypeFind, probability: c_uint, media_type: *const c_char, fieldname: *const c_char, ...);
    pub fn gst_type_find_register(plugin: *mut GstPlugin, name: *const c_char, rank: c_uint, func: GstTypeFindFunction, extensions: *const c_char, possible_caps: *mut GstCaps, data: gpointer, data_notify: glib::GDestroyNotify) -> gboolean;

    //=========================================================================
    // GstUri
    //=========================================================================
    pub fn gst_uri_get_type() -> GType;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_new(scheme: *const c_char, userinfo: *const c_char, host: *const c_char, port: c_uint, path: *const c_char, query: *const c_char, fragment: *const c_char) -> *mut GstUri;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_append_path(uri: *mut GstUri, relative_path: *const c_char) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_append_path_segment(uri: *mut GstUri, path_segment: *const c_char) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_equal(first: *const GstUri, second: *const GstUri) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_from_string_with_base(base: *mut GstUri, uri: *const c_char) -> *mut GstUri;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_get_fragment(uri: *const GstUri) -> *const c_char;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_get_host(uri: *const GstUri) -> *const c_char;
    #[cfg(feature = "v1_12")]
    pub fn gst_uri_get_media_fragment_table(uri: *const GstUri) -> *mut glib::GHashTable;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_get_path(uri: *const GstUri) -> *mut c_char;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_get_path_segments(uri: *const GstUri) -> *mut glib::GList;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_get_path_string(uri: *const GstUri) -> *mut c_char;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_get_port(uri: *const GstUri) -> c_uint;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_get_query_keys(uri: *const GstUri) -> *mut glib::GList;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_get_query_string(uri: *const GstUri) -> *mut c_char;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_get_query_table(uri: *const GstUri) -> *mut glib::GHashTable;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_get_query_value(uri: *const GstUri, query_key: *const c_char) -> *const c_char;
    pub fn gst_uri_get_scheme(uri: *const GstUri) -> *const c_char;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_get_userinfo(uri: *const GstUri) -> *const c_char;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_is_normalized(uri: *const GstUri) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_is_writable(uri: *const GstUri) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_join(base_uri: *mut GstUri, ref_uri: *mut GstUri) -> *mut GstUri;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_make_writable(uri: *mut GstUri) -> *mut GstUri;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_new_with_base(base: *mut GstUri, scheme: *const c_char, userinfo: *const c_char, host: *const c_char, port: c_uint, path: *const c_char, query: *const c_char, fragment: *const c_char) -> *mut GstUri;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_normalize(uri: *mut GstUri) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_query_has_key(uri: *const GstUri, query_key: *const c_char) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_remove_query_key(uri: *mut GstUri, query_key: *const c_char) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_set_fragment(uri: *mut GstUri, fragment: *const c_char) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_set_host(uri: *mut GstUri, host: *const c_char) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_set_path(uri: *mut GstUri, path: *const c_char) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_set_path_segments(uri: *mut GstUri, path_segments: *mut glib::GList) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_set_path_string(uri: *mut GstUri, path: *const c_char) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_set_port(uri: *mut GstUri, port: c_uint) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_set_query_string(uri: *mut GstUri, query: *const c_char) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_set_query_table(uri: *mut GstUri, query_table: *mut glib::GHashTable) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_set_query_value(uri: *mut GstUri, query_key: *const c_char, query_value: *const c_char) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_set_scheme(uri: *mut GstUri, scheme: *const c_char) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_set_userinfo(uri: *mut GstUri, userinfo: *const c_char) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_to_string(uri: *const GstUri) -> *mut c_char;
    pub fn gst_uri_construct(protocol: *const c_char, location: *const c_char) -> *mut c_char;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_from_string(uri: *const c_char) -> *mut GstUri;
    pub fn gst_uri_get_location(uri: *const c_char) -> *mut c_char;
    pub fn gst_uri_get_protocol(uri: *const c_char) -> *mut c_char;
    pub fn gst_uri_has_protocol(uri: *const c_char, protocol: *const c_char) -> gboolean;
    pub fn gst_uri_is_valid(uri: *const c_char) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_uri_join_strings(base_uri: *const c_char, ref_uri: *const c_char) -> *mut c_char;
    pub fn gst_uri_protocol_is_supported(type_: GstURIType, protocol: *const c_char) -> gboolean;
    pub fn gst_uri_protocol_is_valid(protocol: *const c_char) -> gboolean;

    //=========================================================================
    // GstAllocator
    //=========================================================================
    pub fn gst_allocator_get_type() -> GType;
    pub fn gst_allocator_find(name: *const c_char) -> *mut GstAllocator;
    pub fn gst_allocator_register(name: *const c_char, allocator: *mut GstAllocator);
    pub fn gst_allocator_alloc(allocator: *mut GstAllocator, size: size_t, params: *mut GstAllocationParams) -> *mut GstMemory;
    pub fn gst_allocator_free(allocator: *mut GstAllocator, memory: *mut GstMemory);
    pub fn gst_allocator_set_default(allocator: *mut GstAllocator);

    //=========================================================================
    // GstBin
    //=========================================================================
    pub fn gst_bin_get_type() -> GType;
    pub fn gst_bin_new(name: *const c_char) -> *mut GstElement;
    pub fn gst_bin_add(bin: *mut GstBin, element: *mut GstElement) -> gboolean;
    pub fn gst_bin_add_many(bin: *mut GstBin, element_1: *mut GstElement, ...);
    pub fn gst_bin_find_unlinked_pad(bin: *mut GstBin, direction: GstPadDirection) -> *mut GstPad;
    pub fn gst_bin_get_by_interface(bin: *mut GstBin, iface: GType) -> *mut GstElement;
    pub fn gst_bin_get_by_name(bin: *mut GstBin, name: *const c_char) -> *mut GstElement;
    pub fn gst_bin_get_by_name_recurse_up(bin: *mut GstBin, name: *const c_char) -> *mut GstElement;
    #[cfg(feature = "v1_10")]
    pub fn gst_bin_get_suppressed_flags(bin: *mut GstBin) -> GstElementFlags;
    pub fn gst_bin_iterate_all_by_interface(bin: *mut GstBin, iface: GType) -> *mut GstIterator;
    pub fn gst_bin_iterate_elements(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_iterate_recurse(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_iterate_sinks(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_iterate_sorted(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_iterate_sources(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_recalculate_latency(bin: *mut GstBin) -> gboolean;
    pub fn gst_bin_remove(bin: *mut GstBin, element: *mut GstElement) -> gboolean;
    pub fn gst_bin_remove_many(bin: *mut GstBin, element_1: *mut GstElement, ...);
    #[cfg(feature = "v1_10")]
    pub fn gst_bin_set_suppressed_flags(bin: *mut GstBin, flags: GstElementFlags);
    #[cfg(feature = "v1_6")]
    pub fn gst_bin_sync_children_states(bin: *mut GstBin) -> gboolean;

    //=========================================================================
    // GstBitmask
    //=========================================================================
    pub fn gst_bitmask_get_type() -> GType;

    //=========================================================================
    // GstBufferPool
    //=========================================================================
    pub fn gst_buffer_pool_get_type() -> GType;
    pub fn gst_buffer_pool_new() -> *mut GstBufferPool;
    pub fn gst_buffer_pool_config_add_option(config: *mut GstStructure, option: *const c_char);
    pub fn gst_buffer_pool_config_get_allocator(config: *mut GstStructure, allocator: *mut *mut GstAllocator, params: *mut GstAllocationParams) -> gboolean;
    pub fn gst_buffer_pool_config_get_option(config: *mut GstStructure, index: c_uint) -> *const c_char;
    pub fn gst_buffer_pool_config_get_params(config: *mut GstStructure, caps: *mut *mut GstCaps, size: *mut c_uint, min_buffers: *mut c_uint, max_buffers: *mut c_uint) -> gboolean;
    pub fn gst_buffer_pool_config_has_option(config: *mut GstStructure, option: *const c_char) -> gboolean;
    pub fn gst_buffer_pool_config_n_options(config: *mut GstStructure) -> c_uint;
    pub fn gst_buffer_pool_config_set_allocator(config: *mut GstStructure, allocator: *mut GstAllocator, params: *const GstAllocationParams);
    pub fn gst_buffer_pool_config_set_params(config: *mut GstStructure, caps: *mut GstCaps, size: c_uint, min_buffers: c_uint, max_buffers: c_uint);
    #[cfg(feature = "v1_4")]
    pub fn gst_buffer_pool_config_validate_params(config: *mut GstStructure, caps: *mut GstCaps, size: c_uint, min_buffers: c_uint, max_buffers: c_uint) -> gboolean;
    pub fn gst_buffer_pool_acquire_buffer(pool: *mut GstBufferPool, buffer: *mut *mut GstBuffer, params: *mut GstBufferPoolAcquireParams) -> GstFlowReturn;
    pub fn gst_buffer_pool_get_config(pool: *mut GstBufferPool) -> *mut GstStructure;
    pub fn gst_buffer_pool_get_options(pool: *mut GstBufferPool) -> *mut *mut c_char;
    pub fn gst_buffer_pool_has_option(pool: *mut GstBufferPool, option: *const c_char) -> gboolean;
    pub fn gst_buffer_pool_is_active(pool: *mut GstBufferPool) -> gboolean;
    pub fn gst_buffer_pool_release_buffer(pool: *mut GstBufferPool, buffer: *mut GstBuffer);
    pub fn gst_buffer_pool_set_active(pool: *mut GstBufferPool, active: gboolean) -> gboolean;
    pub fn gst_buffer_pool_set_config(pool: *mut GstBufferPool, config: *mut GstStructure) -> gboolean;
    #[cfg(feature = "v1_4")]
    pub fn gst_buffer_pool_set_flushing(pool: *mut GstBufferPool, flushing: gboolean);

    //=========================================================================
    // GstBus
    //=========================================================================
    pub fn gst_bus_get_type() -> GType;
    pub fn gst_bus_new() -> *mut GstBus;
    pub fn gst_bus_add_signal_watch(bus: *mut GstBus);
    pub fn gst_bus_add_signal_watch_full(bus: *mut GstBus, priority: c_int);
    pub fn gst_bus_add_watch(bus: *mut GstBus, func: GstBusFunc, user_data: gpointer) -> c_uint;
    pub fn gst_bus_add_watch_full(bus: *mut GstBus, priority: c_int, func: GstBusFunc, user_data: gpointer, notify: glib::GDestroyNotify) -> c_uint;
    pub fn gst_bus_async_signal_func(bus: *mut GstBus, message: *mut GstMessage, data: gpointer) -> gboolean;
    pub fn gst_bus_create_watch(bus: *mut GstBus) -> *mut glib::GSource;
    pub fn gst_bus_disable_sync_message_emission(bus: *mut GstBus);
    pub fn gst_bus_enable_sync_message_emission(bus: *mut GstBus);
    pub fn gst_bus_have_pending(bus: *mut GstBus) -> gboolean;
    pub fn gst_bus_peek(bus: *mut GstBus) -> *mut GstMessage;
    pub fn gst_bus_poll(bus: *mut GstBus, events: GstMessageType, timeout: GstClockTime) -> *mut GstMessage;
    pub fn gst_bus_pop(bus: *mut GstBus) -> *mut GstMessage;
    pub fn gst_bus_pop_filtered(bus: *mut GstBus, types: GstMessageType) -> *mut GstMessage;
    pub fn gst_bus_post(bus: *mut GstBus, message: *mut GstMessage) -> gboolean;
    pub fn gst_bus_remove_signal_watch(bus: *mut GstBus);
    #[cfg(feature = "v1_6")]
    pub fn gst_bus_remove_watch(bus: *mut GstBus) -> gboolean;
    pub fn gst_bus_set_flushing(bus: *mut GstBus, flushing: gboolean);
    pub fn gst_bus_set_sync_handler(bus: *mut GstBus, func: GstBusSyncHandler, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_bus_sync_signal_handler(bus: *mut GstBus, message: *mut GstMessage, data: gpointer) -> GstBusSyncReply;
    pub fn gst_bus_timed_pop(bus: *mut GstBus, timeout: GstClockTime) -> *mut GstMessage;
    pub fn gst_bus_timed_pop_filtered(bus: *mut GstBus, timeout: GstClockTime, types: GstMessageType) -> *mut GstMessage;

    //=========================================================================
    // GstClock
    //=========================================================================
    pub fn gst_clock_get_type() -> GType;
    pub fn gst_clock_id_compare_func(id1: gconstpointer, id2: gconstpointer) -> c_int;
    pub fn gst_clock_id_get_time(id: GstClockID) -> GstClockTime;
    pub fn gst_clock_id_ref(id: GstClockID) -> GstClockID;
    pub fn gst_clock_id_unref(id: GstClockID);
    pub fn gst_clock_id_unschedule(id: GstClockID);
    pub fn gst_clock_id_wait(id: GstClockID, jitter: *mut GstClockTimeDiff) -> GstClockReturn;
    pub fn gst_clock_id_wait_async(id: GstClockID, func: GstClockCallback, user_data: gpointer, destroy_data: glib::GDestroyNotify) -> GstClockReturn;
    pub fn gst_clock_add_observation(clock: *mut GstClock, slave: GstClockTime, master: GstClockTime, r_squared: *mut c_double) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_clock_add_observation_unapplied(clock: *mut GstClock, slave: GstClockTime, master: GstClockTime, r_squared: *mut c_double, internal: *mut GstClockTime, external: *mut GstClockTime, rate_num: *mut GstClockTime, rate_denom: *mut GstClockTime) -> gboolean;
    pub fn gst_clock_adjust_unlocked(clock: *mut GstClock, internal: GstClockTime) -> GstClockTime;
    #[cfg(feature = "v1_6")]
    pub fn gst_clock_adjust_with_calibration(clock: *mut GstClock, internal_target: GstClockTime, cinternal: GstClockTime, cexternal: GstClockTime, cnum: GstClockTime, cdenom: GstClockTime) -> GstClockTime;
    pub fn gst_clock_get_calibration(clock: *mut GstClock, internal: *mut GstClockTime, external: *mut GstClockTime, rate_num: *mut GstClockTime, rate_denom: *mut GstClockTime);
    pub fn gst_clock_get_internal_time(clock: *mut GstClock) -> GstClockTime;
    pub fn gst_clock_get_master(clock: *mut GstClock) -> *mut GstClock;
    pub fn gst_clock_get_resolution(clock: *mut GstClock) -> GstClockTime;
    pub fn gst_clock_get_time(clock: *mut GstClock) -> GstClockTime;
    pub fn gst_clock_get_timeout(clock: *mut GstClock) -> GstClockTime;
    #[cfg(feature = "v1_6")]
    pub fn gst_clock_is_synced(clock: *mut GstClock) -> gboolean;
    pub fn gst_clock_new_periodic_id(clock: *mut GstClock, start_time: GstClockTime, interval: GstClockTime) -> GstClockID;
    pub fn gst_clock_new_single_shot_id(clock: *mut GstClock, time: GstClockTime) -> GstClockID;
    pub fn gst_clock_periodic_id_reinit(clock: *mut GstClock, id: GstClockID, start_time: GstClockTime, interval: GstClockTime) -> gboolean;
    pub fn gst_clock_set_calibration(clock: *mut GstClock, internal: GstClockTime, external: GstClockTime, rate_num: GstClockTime, rate_denom: GstClockTime);
    pub fn gst_clock_set_master(clock: *mut GstClock, master: *mut GstClock) -> gboolean;
    pub fn gst_clock_set_resolution(clock: *mut GstClock, resolution: GstClockTime) -> GstClockTime;
    #[cfg(feature = "v1_6")]
    pub fn gst_clock_set_synced(clock: *mut GstClock, synced: gboolean);
    pub fn gst_clock_set_timeout(clock: *mut GstClock, timeout: GstClockTime);
    pub fn gst_clock_single_shot_id_reinit(clock: *mut GstClock, id: GstClockID, time: GstClockTime) -> gboolean;
    pub fn gst_clock_unadjust_unlocked(clock: *mut GstClock, external: GstClockTime) -> GstClockTime;
    #[cfg(feature = "v1_8")]
    pub fn gst_clock_unadjust_with_calibration(clock: *mut GstClock, external_target: GstClockTime, cinternal: GstClockTime, cexternal: GstClockTime, cnum: GstClockTime, cdenom: GstClockTime) -> GstClockTime;
    #[cfg(feature = "v1_6")]
    pub fn gst_clock_wait_for_sync(clock: *mut GstClock, timeout: GstClockTime) -> gboolean;

    //=========================================================================
    // GstControlBinding
    //=========================================================================
    pub fn gst_control_binding_get_type() -> GType;
    pub fn gst_control_binding_get_g_value_array(binding: *mut GstControlBinding, timestamp: GstClockTime, interval: GstClockTime, n_values: c_uint, values: *mut gobject::GValue) -> gboolean;
    pub fn gst_control_binding_get_value(binding: *mut GstControlBinding, timestamp: GstClockTime) -> *mut gobject::GValue;
    pub fn gst_control_binding_get_value_array(binding: *mut GstControlBinding, timestamp: GstClockTime, interval: GstClockTime, n_values: c_uint, values: gpointer) -> gboolean;
    pub fn gst_control_binding_is_disabled(binding: *mut GstControlBinding) -> gboolean;
    pub fn gst_control_binding_set_disabled(binding: *mut GstControlBinding, disabled: gboolean);
    pub fn gst_control_binding_sync_values(binding: *mut GstControlBinding, object: *mut GstObject, timestamp: GstClockTime, last_sync: GstClockTime) -> gboolean;

    //=========================================================================
    // GstControlSource
    //=========================================================================
    pub fn gst_control_source_get_type() -> GType;
    pub fn gst_control_source_get_value(self_: *mut GstControlSource, timestamp: GstClockTime, value: *mut c_double) -> gboolean;
    pub fn gst_control_source_get_value_array(self_: *mut GstControlSource, timestamp: GstClockTime, interval: GstClockTime, n_values: c_uint, values: *mut c_double) -> gboolean;

    //=========================================================================
    // GstDevice
    //=========================================================================
    pub fn gst_device_get_type() -> GType;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_create_element(device: *mut GstDevice, name: *const c_char) -> *mut GstElement;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_get_caps(device: *mut GstDevice) -> *mut GstCaps;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_get_device_class(device: *mut GstDevice) -> *mut c_char;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_get_display_name(device: *mut GstDevice) -> *mut c_char;
    #[cfg(feature = "v1_6")]
    pub fn gst_device_get_properties(device: *mut GstDevice) -> *mut GstStructure;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_has_classes(device: *mut GstDevice, classes: *const c_char) -> gboolean;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_has_classesv(device: *mut GstDevice, classes: *mut *mut c_char) -> gboolean;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_reconfigure_element(device: *mut GstDevice, element: *mut GstElement) -> gboolean;

    //=========================================================================
    // GstDeviceMonitor
    //=========================================================================
    pub fn gst_device_monitor_get_type() -> GType;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_monitor_new() -> *mut GstDeviceMonitor;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_monitor_add_filter(monitor: *mut GstDeviceMonitor, classes: *const c_char, caps: *mut GstCaps) -> c_uint;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_monitor_get_bus(monitor: *mut GstDeviceMonitor) -> *mut GstBus;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_monitor_get_devices(monitor: *mut GstDeviceMonitor) -> *mut glib::GList;
    #[cfg(feature = "v1_6")]
    pub fn gst_device_monitor_get_providers(monitor: *mut GstDeviceMonitor) -> *mut *mut c_char;
    #[cfg(feature = "v1_6")]
    pub fn gst_device_monitor_get_show_all_devices(monitor: *mut GstDeviceMonitor) -> gboolean;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_monitor_remove_filter(monitor: *mut GstDeviceMonitor, filter_id: c_uint) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_device_monitor_set_show_all_devices(monitor: *mut GstDeviceMonitor, show_all: gboolean);
    #[cfg(feature = "v1_4")]
    pub fn gst_device_monitor_start(monitor: *mut GstDeviceMonitor) -> gboolean;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_monitor_stop(monitor: *mut GstDeviceMonitor);

    //=========================================================================
    // GstDeviceProvider
    //=========================================================================
    pub fn gst_device_provider_get_type() -> GType;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_register(plugin: *mut GstPlugin, name: *const c_char, rank: c_uint, type_: GType) -> gboolean;
    pub fn gst_device_provider_can_monitor(provider: *mut GstDeviceProvider) -> gboolean;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_device_add(provider: *mut GstDeviceProvider, device: *mut GstDevice);
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_device_remove(provider: *mut GstDeviceProvider, device: *mut GstDevice);
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_get_bus(provider: *mut GstDeviceProvider) -> *mut GstBus;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_get_devices(provider: *mut GstDeviceProvider) -> *mut glib::GList;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_get_factory(provider: *mut GstDeviceProvider) -> *mut GstDeviceProviderFactory;
    #[cfg(feature = "v1_6")]
    pub fn gst_device_provider_get_hidden_providers(provider: *mut GstDeviceProvider) -> *mut *mut c_char;
    #[cfg(feature = "v1_6")]
    pub fn gst_device_provider_hide_provider(provider: *mut GstDeviceProvider, name: *const c_char);
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_start(provider: *mut GstDeviceProvider) -> gboolean;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_stop(provider: *mut GstDeviceProvider);
    #[cfg(feature = "v1_6")]
    pub fn gst_device_provider_unhide_provider(provider: *mut GstDeviceProvider, name: *const c_char);

    //=========================================================================
    // GstDeviceProviderFactory
    //=========================================================================
    pub fn gst_device_provider_factory_get_type() -> GType;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_factory_find(name: *const c_char) -> *mut GstDeviceProviderFactory;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_factory_get_by_name(factoryname: *const c_char) -> *mut GstDeviceProvider;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_factory_list_get_device_providers(minrank: GstRank) -> *mut glib::GList;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_factory_get(factory: *mut GstDeviceProviderFactory) -> *mut GstDeviceProvider;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_factory_get_device_provider_type(factory: *mut GstDeviceProviderFactory) -> GType;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_factory_get_metadata(factory: *mut GstDeviceProviderFactory, key: *const c_char) -> *const c_char;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_factory_get_metadata_keys(factory: *mut GstDeviceProviderFactory) -> *mut *mut c_char;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_factory_has_classes(factory: *mut GstDeviceProviderFactory, classes: *const c_char) -> gboolean;
    #[cfg(feature = "v1_4")]
    pub fn gst_device_provider_factory_has_classesv(factory: *mut GstDeviceProviderFactory, classes: *mut *mut c_char) -> gboolean;

    //=========================================================================
    // GstDoubleRange
    //=========================================================================
    pub fn gst_double_range_get_type() -> GType;

    //=========================================================================
    // GstDynamicTypeFactory
    //=========================================================================
    pub fn gst_dynamic_type_factory_get_type() -> GType;
    pub fn gst_dynamic_type_factory_load(factoryname: *const c_char) -> GType;

    //=========================================================================
    // GstElement
    //=========================================================================
    pub fn gst_element_get_type() -> GType;
    pub fn gst_element_make_from_uri(type_: GstURIType, uri: *const c_char, elementname: *const c_char, error: *mut *mut glib::GError) -> *mut GstElement;
    pub fn gst_element_register(plugin: *mut GstPlugin, name: *const c_char, rank: c_uint, type_: GType) -> gboolean;
    pub fn gst_element_state_change_return_get_name(state_ret: GstStateChangeReturn) -> *const c_char;
    pub fn gst_element_state_get_name(state: GstState) -> *const c_char;
    pub fn gst_element_abort_state(element: *mut GstElement);
    pub fn gst_element_add_pad(element: *mut GstElement, pad: *mut GstPad) -> gboolean;
    #[cfg(feature = "v1_10")]
    pub fn gst_element_add_property_deep_notify_watch(element: *mut GstElement, property_name: *const c_char, include_value: gboolean) -> c_ulong;
    #[cfg(feature = "v1_10")]
    pub fn gst_element_add_property_notify_watch(element: *mut GstElement, property_name: *const c_char, include_value: gboolean) -> c_ulong;
    #[cfg(feature = "v1_10")]
    pub fn gst_element_call_async(element: *mut GstElement, func: GstElementCallAsyncFunc, user_data: gpointer, destroy_notify: glib::GDestroyNotify);
    pub fn gst_element_change_state(element: *mut GstElement, transition: GstStateChange) -> GstStateChangeReturn;
    pub fn gst_element_continue_state(element: *mut GstElement, ret: GstStateChangeReturn) -> GstStateChangeReturn;
    pub fn gst_element_create_all_pads(element: *mut GstElement);
    pub fn gst_element_get_base_time(element: *mut GstElement) -> GstClockTime;
    pub fn gst_element_get_bus(element: *mut GstElement) -> *mut GstBus;
    pub fn gst_element_get_clock(element: *mut GstElement) -> *mut GstClock;
    pub fn gst_element_get_compatible_pad(element: *mut GstElement, pad: *mut GstPad, caps: *mut GstCaps) -> *mut GstPad;
    pub fn gst_element_get_compatible_pad_template(element: *mut GstElement, compattempl: *mut GstPadTemplate) -> *mut GstPadTemplate;
    #[cfg(feature = "v1_8")]
    pub fn gst_element_get_context(element: *mut GstElement, context_type: *const c_char) -> *mut GstContext;
    #[cfg(feature = "v1_8")]
    pub fn gst_element_get_context_unlocked(element: *mut GstElement, context_type: *const c_char) -> *mut GstContext;
    #[cfg(feature = "v1_8")]
    pub fn gst_element_get_contexts(element: *mut GstElement) -> *mut glib::GList;
    pub fn gst_element_get_factory(element: *mut GstElement) -> *mut GstElementFactory;
    pub fn gst_element_get_request_pad(element: *mut GstElement, name: *const c_char) -> *mut GstPad;
    pub fn gst_element_get_start_time(element: *mut GstElement) -> GstClockTime;
    pub fn gst_element_get_state(element: *mut GstElement, state: *mut GstState, pending: *mut GstState, timeout: GstClockTime) -> GstStateChangeReturn;
    pub fn gst_element_get_static_pad(element: *mut GstElement, name: *const c_char) -> *mut GstPad;
    pub fn gst_element_is_locked_state(element: *mut GstElement) -> gboolean;
    pub fn gst_element_iterate_pads(element: *mut GstElement) -> *mut GstIterator;
    pub fn gst_element_iterate_sink_pads(element: *mut GstElement) -> *mut GstIterator;
    pub fn gst_element_iterate_src_pads(element: *mut GstElement) -> *mut GstIterator;
    pub fn gst_element_link(src: *mut GstElement, dest: *mut GstElement) -> gboolean;
    pub fn gst_element_link_filtered(src: *mut GstElement, dest: *mut GstElement, filter: *mut GstCaps) -> gboolean;
    pub fn gst_element_link_many(element_1: *mut GstElement, element_2: *mut GstElement, ...) -> gboolean;
    pub fn gst_element_link_pads(src: *mut GstElement, srcpadname: *const c_char, dest: *mut GstElement, destpadname: *const c_char) -> gboolean;
    pub fn gst_element_link_pads_filtered(src: *mut GstElement, srcpadname: *const c_char, dest: *mut GstElement, destpadname: *const c_char, filter: *mut GstCaps) -> gboolean;
    pub fn gst_element_link_pads_full(src: *mut GstElement, srcpadname: *const c_char, dest: *mut GstElement, destpadname: *const c_char, flags: GstPadLinkCheck) -> gboolean;
    pub fn gst_element_lost_state(element: *mut GstElement);
    pub fn gst_element_message_full(element: *mut GstElement, type_: GstMessageType, domain: glib::GQuark, code: c_int, text: *mut c_char, debug: *mut c_char, file: *const c_char, function: *const c_char, line: c_int);
    #[cfg(feature = "v1_10")]
    pub fn gst_element_message_full_with_details(element: *mut GstElement, type_: GstMessageType, domain: glib::GQuark, code: c_int, text: *mut c_char, debug: *mut c_char, file: *const c_char, function: *const c_char, line: c_int, structure: *mut GstStructure);
    pub fn gst_element_no_more_pads(element: *mut GstElement);
    pub fn gst_element_post_message(element: *mut GstElement, message: *mut GstMessage) -> gboolean;
    pub fn gst_element_provide_clock(element: *mut GstElement) -> *mut GstClock;
    pub fn gst_element_query(element: *mut GstElement, query: *mut GstQuery) -> gboolean;
    pub fn gst_element_query_convert(element: *mut GstElement, src_format: GstFormat, src_val: i64, dest_format: GstFormat, dest_val: *mut i64) -> gboolean;
    pub fn gst_element_query_duration(element: *mut GstElement, format: GstFormat, duration: *mut i64) -> gboolean;
    pub fn gst_element_query_position(element: *mut GstElement, format: GstFormat, cur: *mut i64) -> gboolean;
    pub fn gst_element_release_request_pad(element: *mut GstElement, pad: *mut GstPad);
    pub fn gst_element_remove_pad(element: *mut GstElement, pad: *mut GstPad) -> gboolean;
    #[cfg(feature = "v1_10")]
    pub fn gst_element_remove_property_notify_watch(element: *mut GstElement, watch_id: c_ulong);
    pub fn gst_element_request_pad(element: *mut GstElement, templ: *mut GstPadTemplate, name: *const c_char, caps: *const GstCaps) -> *mut GstPad;
    pub fn gst_element_seek(element: *mut GstElement, rate: c_double, format: GstFormat, flags: GstSeekFlags, start_type: GstSeekType, start: i64, stop_type: GstSeekType, stop: i64) -> gboolean;
    pub fn gst_element_seek_simple(element: *mut GstElement, format: GstFormat, seek_flags: GstSeekFlags, seek_pos: i64) -> gboolean;
    pub fn gst_element_send_event(element: *mut GstElement, event: *mut GstEvent) -> gboolean;
    pub fn gst_element_set_base_time(element: *mut GstElement, time: GstClockTime);
    pub fn gst_element_set_bus(element: *mut GstElement, bus: *mut GstBus);
    pub fn gst_element_set_clock(element: *mut GstElement, clock: *mut GstClock) -> gboolean;
    pub fn gst_element_set_context(element: *mut GstElement, context: *mut GstContext);
    pub fn gst_element_set_locked_state(element: *mut GstElement, locked_state: gboolean) -> gboolean;
    pub fn gst_element_set_start_time(element: *mut GstElement, time: GstClockTime);
    pub fn gst_element_set_state(element: *mut GstElement, state: GstState) -> GstStateChangeReturn;
    pub fn gst_element_sync_state_with_parent(element: *mut GstElement) -> gboolean;
    pub fn gst_element_unlink(src: *mut GstElement, dest: *mut GstElement);
    pub fn gst_element_unlink_many(element_1: *mut GstElement, element_2: *mut GstElement, ...);
    pub fn gst_element_unlink_pads(src: *mut GstElement, srcpadname: *const c_char, dest: *mut GstElement, destpadname: *const c_char);

    //=========================================================================
    // GstElementFactory
    //=========================================================================
    pub fn gst_element_factory_get_type() -> GType;
    pub fn gst_element_factory_find(name: *const c_char) -> *mut GstElementFactory;
    pub fn gst_element_factory_list_filter(list: *mut glib::GList, caps: *const GstCaps, direction: GstPadDirection, subsetonly: gboolean) -> *mut glib::GList;
    pub fn gst_element_factory_list_get_elements(type_: GstElementFactoryListType, minrank: GstRank) -> *mut glib::GList;
    pub fn gst_element_factory_make(factoryname: *const c_char, name: *const c_char) -> *mut GstElement;
    pub fn gst_element_factory_can_sink_all_caps(factory: *mut GstElementFactory, caps: *const GstCaps) -> gboolean;
    pub fn gst_element_factory_can_sink_any_caps(factory: *mut GstElementFactory, caps: *const GstCaps) -> gboolean;
    pub fn gst_element_factory_can_src_all_caps(factory: *mut GstElementFactory, caps: *const GstCaps) -> gboolean;
    pub fn gst_element_factory_can_src_any_caps(factory: *mut GstElementFactory, caps: *const GstCaps) -> gboolean;
    pub fn gst_element_factory_create(factory: *mut GstElementFactory, name: *const c_char) -> *mut GstElement;
    pub fn gst_element_factory_get_element_type(factory: *mut GstElementFactory) -> GType;
    pub fn gst_element_factory_get_metadata(factory: *mut GstElementFactory, key: *const c_char) -> *const c_char;
    pub fn gst_element_factory_get_metadata_keys(factory: *mut GstElementFactory) -> *mut *mut c_char;
    pub fn gst_element_factory_get_num_pad_templates(factory: *mut GstElementFactory) -> c_uint;
    pub fn gst_element_factory_get_static_pad_templates(factory: *mut GstElementFactory) -> *const glib::GList;
    pub fn gst_element_factory_get_uri_protocols(factory: *mut GstElementFactory) -> *mut *mut c_char;
    pub fn gst_element_factory_get_uri_type(factory: *mut GstElementFactory) -> GstURIType;
    pub fn gst_element_factory_has_interface(factory: *mut GstElementFactory, interfacename: *const c_char) -> gboolean;
    pub fn gst_element_factory_list_is_type(factory: *mut GstElementFactory, type_: GstElementFactoryListType) -> gboolean;

    //=========================================================================
    // GstFlagSet
    //=========================================================================
    pub fn gst_flagset_get_type() -> GType;
    #[cfg(feature = "v1_6")]
    pub fn gst_flagset_register(flags_type: GType) -> GType;

    //=========================================================================
    // GstFraction
    //=========================================================================
    pub fn gst_fraction_get_type() -> GType;

    //=========================================================================
    // GstFractionRange
    //=========================================================================
    pub fn gst_fraction_range_get_type() -> GType;

    //=========================================================================
    // GstGhostPad
    //=========================================================================
    pub fn gst_ghost_pad_get_type() -> GType;
    pub fn gst_ghost_pad_new(name: *const c_char, target: *mut GstPad) -> *mut GstPad;
    pub fn gst_ghost_pad_new_from_template(name: *const c_char, target: *mut GstPad, templ: *mut GstPadTemplate) -> *mut GstPad;
    pub fn gst_ghost_pad_new_no_target(name: *const c_char, dir: GstPadDirection) -> *mut GstPad;
    pub fn gst_ghost_pad_new_no_target_from_template(name: *const c_char, templ: *mut GstPadTemplate) -> *mut GstPad;
    pub fn gst_ghost_pad_activate_mode_default(pad: *mut GstPad, parent: *mut GstObject, mode: GstPadMode, active: gboolean) -> gboolean;
    pub fn gst_ghost_pad_internal_activate_mode_default(pad: *mut GstPad, parent: *mut GstObject, mode: GstPadMode, active: gboolean) -> gboolean;
    pub fn gst_ghost_pad_construct(gpad: *mut GstGhostPad) -> gboolean;
    pub fn gst_ghost_pad_get_target(gpad: *mut GstGhostPad) -> *mut GstPad;
    pub fn gst_ghost_pad_set_target(gpad: *mut GstGhostPad, newtarget: *mut GstPad) -> gboolean;

    //=========================================================================
    // GstInt64Range
    //=========================================================================
    pub fn gst_int64_range_get_type() -> GType;

    //=========================================================================
    // GstIntRange
    //=========================================================================
    pub fn gst_int_range_get_type() -> GType;

    //=========================================================================
    // GstObject
    //=========================================================================
    pub fn gst_object_get_type() -> GType;
    pub fn gst_object_check_uniqueness(list: *mut glib::GList, name: *const c_char) -> gboolean;
    pub fn gst_object_default_deep_notify(object: *mut gobject::GObject, orig: *mut GstObject, pspec: *mut gobject::GParamSpec, excluded_props: *mut *mut c_char);
    pub fn gst_object_ref_sink(object: gpointer) -> gpointer;
    pub fn gst_object_replace(oldobj: *mut *mut GstObject, newobj: *mut GstObject) -> gboolean;
    pub fn gst_object_add_control_binding(object: *mut GstObject, binding: *mut GstControlBinding) -> gboolean;
    pub fn gst_object_default_error(source: *mut GstObject, error: *const glib::GError, debug: *const c_char);
    pub fn gst_object_get_control_binding(object: *mut GstObject, property_name: *const c_char) -> *mut GstControlBinding;
    pub fn gst_object_get_control_rate(object: *mut GstObject) -> GstClockTime;
    pub fn gst_object_get_g_value_array(object: *mut GstObject, property_name: *const c_char, timestamp: GstClockTime, interval: GstClockTime, n_values: c_uint, values: *mut gobject::GValue) -> gboolean;
    pub fn gst_object_get_name(object: *mut GstObject) -> *mut c_char;
    pub fn gst_object_get_parent(object: *mut GstObject) -> *mut GstObject;
    pub fn gst_object_get_path_string(object: *mut GstObject) -> *mut c_char;
    pub fn gst_object_get_value(object: *mut GstObject, property_name: *const c_char, timestamp: GstClockTime) -> *mut gobject::GValue;
    pub fn gst_object_get_value_array(object: *mut GstObject, property_name: *const c_char, timestamp: GstClockTime, interval: GstClockTime, n_values: c_uint, values: gpointer) -> gboolean;
    pub fn gst_object_has_active_control_bindings(object: *mut GstObject) -> gboolean;
    pub fn gst_object_has_ancestor(object: *mut GstObject, ancestor: *mut GstObject) -> gboolean;
    pub fn gst_object_has_as_ancestor(object: *mut GstObject, ancestor: *mut GstObject) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_object_has_as_parent(object: *mut GstObject, parent: *mut GstObject) -> gboolean;
    pub fn gst_object_ref(object: *mut GstObject) -> *mut GstObject;
    pub fn gst_object_remove_control_binding(object: *mut GstObject, binding: *mut GstControlBinding) -> gboolean;
    pub fn gst_object_set_control_binding_disabled(object: *mut GstObject, property_name: *const c_char, disabled: gboolean);
    pub fn gst_object_set_control_bindings_disabled(object: *mut GstObject, disabled: gboolean);
    pub fn gst_object_set_control_rate(object: *mut GstObject, control_rate: GstClockTime);
    pub fn gst_object_set_name(object: *mut GstObject, name: *const c_char) -> gboolean;
    pub fn gst_object_set_parent(object: *mut GstObject, parent: *mut GstObject) -> gboolean;
    pub fn gst_object_suggest_next_sync(object: *mut GstObject) -> GstClockTime;
    pub fn gst_object_sync_values(object: *mut GstObject, timestamp: GstClockTime) -> gboolean;
    pub fn gst_object_unparent(object: *mut GstObject);
    pub fn gst_object_unref(object: *mut GstObject);

    //=========================================================================
    // GstPad
    //=========================================================================
    pub fn gst_pad_get_type() -> GType;
    pub fn gst_pad_new(name: *const c_char, direction: GstPadDirection) -> *mut GstPad;
    pub fn gst_pad_new_from_static_template(templ: *mut GstStaticPadTemplate, name: *const c_char) -> *mut GstPad;
    pub fn gst_pad_new_from_template(templ: *mut GstPadTemplate, name: *const c_char) -> *mut GstPad;
    #[cfg(feature = "v1_4")]
    pub fn gst_pad_link_get_name(ret: GstPadLinkReturn) -> *const c_char;
    pub fn gst_pad_activate_mode(pad: *mut GstPad, mode: GstPadMode, active: gboolean) -> gboolean;
    pub fn gst_pad_add_probe(pad: *mut GstPad, mask: GstPadProbeType, callback: GstPadProbeCallback, user_data: gpointer, destroy_data: glib::GDestroyNotify) -> c_ulong;
    pub fn gst_pad_can_link(srcpad: *mut GstPad, sinkpad: *mut GstPad) -> gboolean;
    pub fn gst_pad_chain(pad: *mut GstPad, buffer: *mut GstBuffer) -> GstFlowReturn;
    pub fn gst_pad_chain_list(pad: *mut GstPad, list: *mut GstBufferList) -> GstFlowReturn;
    pub fn gst_pad_check_reconfigure(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_create_stream_id(pad: *mut GstPad, parent: *mut GstElement, stream_id: *const c_char) -> *mut c_char;
    pub fn gst_pad_create_stream_id_printf(pad: *mut GstPad, parent: *mut GstElement, stream_id: *const c_char, ...) -> *mut c_char;
    //pub fn gst_pad_create_stream_id_printf_valist(pad: *mut GstPad, parent: *mut GstElement, stream_id: *const c_char, var_args: /*Unimplemented*/va_list) -> *mut c_char;
    pub fn gst_pad_event_default(pad: *mut GstPad, parent: *mut GstObject, event: *mut GstEvent) -> gboolean;
    pub fn gst_pad_forward(pad: *mut GstPad, forward: GstPadForwardFunction, user_data: gpointer) -> gboolean;
    pub fn gst_pad_get_allowed_caps(pad: *mut GstPad) -> *mut GstCaps;
    pub fn gst_pad_get_current_caps(pad: *mut GstPad) -> *mut GstCaps;
    pub fn gst_pad_get_direction(pad: *mut GstPad) -> GstPadDirection;
    pub fn gst_pad_get_element_private(pad: *mut GstPad) -> gpointer;
    #[cfg(feature = "v1_4")]
    pub fn gst_pad_get_last_flow_return(pad: *mut GstPad) -> GstFlowReturn;
    pub fn gst_pad_get_offset(pad: *mut GstPad) -> i64;
    pub fn gst_pad_get_pad_template(pad: *mut GstPad) -> *mut GstPadTemplate;
    pub fn gst_pad_get_pad_template_caps(pad: *mut GstPad) -> *mut GstCaps;
    pub fn gst_pad_get_parent_element(pad: *mut GstPad) -> *mut GstElement;
    pub fn gst_pad_get_peer(pad: *mut GstPad) -> *mut GstPad;
    pub fn gst_pad_get_range(pad: *mut GstPad, offset: u64, size: c_uint, buffer: *mut *mut GstBuffer) -> GstFlowReturn;
    pub fn gst_pad_get_sticky_event(pad: *mut GstPad, event_type: GstEventType, idx: c_uint) -> *mut GstEvent;
    #[cfg(feature = "v1_10")]
    pub fn gst_pad_get_stream(pad: *mut GstPad) -> *mut GstStream;
    #[cfg(feature = "v1_2")]
    pub fn gst_pad_get_stream_id(pad: *mut GstPad) -> *mut c_char;
    #[cfg(feature = "v1_12")]
    pub fn gst_pad_get_task_state(pad: *mut GstPad) -> GstTaskState;
    pub fn gst_pad_has_current_caps(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_is_active(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_is_blocked(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_is_blocking(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_is_linked(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_iterate_internal_links(pad: *mut GstPad) -> *mut GstIterator;
    pub fn gst_pad_iterate_internal_links_default(pad: *mut GstPad, parent: *mut GstObject) -> *mut GstIterator;
    pub fn gst_pad_link(srcpad: *mut GstPad, sinkpad: *mut GstPad) -> GstPadLinkReturn;
    pub fn gst_pad_link_full(srcpad: *mut GstPad, sinkpad: *mut GstPad, flags: GstPadLinkCheck) -> GstPadLinkReturn;
    #[cfg(feature = "v1_10")]
    pub fn gst_pad_link_maybe_ghosting(src: *mut GstPad, sink: *mut GstPad) -> gboolean;
    #[cfg(feature = "v1_10")]
    pub fn gst_pad_link_maybe_ghosting_full(src: *mut GstPad, sink: *mut GstPad, flags: GstPadLinkCheck) -> gboolean;
    pub fn gst_pad_mark_reconfigure(pad: *mut GstPad);
    pub fn gst_pad_needs_reconfigure(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_pause_task(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_peer_query(pad: *mut GstPad, query: *mut GstQuery) -> gboolean;
    pub fn gst_pad_peer_query_accept_caps(pad: *mut GstPad, caps: *mut GstCaps) -> gboolean;
    pub fn gst_pad_peer_query_caps(pad: *mut GstPad, filter: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_pad_peer_query_convert(pad: *mut GstPad, src_format: GstFormat, src_val: i64, dest_format: GstFormat, dest_val: *mut i64) -> gboolean;
    pub fn gst_pad_peer_query_duration(pad: *mut GstPad, format: GstFormat, duration: *mut i64) -> gboolean;
    pub fn gst_pad_peer_query_position(pad: *mut GstPad, format: GstFormat, cur: *mut i64) -> gboolean;
    pub fn gst_pad_proxy_query_accept_caps(pad: *mut GstPad, query: *mut GstQuery) -> gboolean;
    pub fn gst_pad_proxy_query_caps(pad: *mut GstPad, query: *mut GstQuery) -> gboolean;
    pub fn gst_pad_pull_range(pad: *mut GstPad, offset: u64, size: c_uint, buffer: *mut *mut GstBuffer) -> GstFlowReturn;
    pub fn gst_pad_push(pad: *mut GstPad, buffer: *mut GstBuffer) -> GstFlowReturn;
    pub fn gst_pad_push_event(pad: *mut GstPad, event: *mut GstEvent) -> gboolean;
    pub fn gst_pad_push_list(pad: *mut GstPad, list: *mut GstBufferList) -> GstFlowReturn;
    pub fn gst_pad_query(pad: *mut GstPad, query: *mut GstQuery) -> gboolean;
    pub fn gst_pad_query_accept_caps(pad: *mut GstPad, caps: *mut GstCaps) -> gboolean;
    pub fn gst_pad_query_caps(pad: *mut GstPad, filter: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_pad_query_convert(pad: *mut GstPad, src_format: GstFormat, src_val: i64, dest_format: GstFormat, dest_val: *mut i64) -> gboolean;
    pub fn gst_pad_query_default(pad: *mut GstPad, parent: *mut GstObject, query: *mut GstQuery) -> gboolean;
    pub fn gst_pad_query_duration(pad: *mut GstPad, format: GstFormat, duration: *mut i64) -> gboolean;
    pub fn gst_pad_query_position(pad: *mut GstPad, format: GstFormat, cur: *mut i64) -> gboolean;
    pub fn gst_pad_remove_probe(pad: *mut GstPad, id: c_ulong);
    pub fn gst_pad_send_event(pad: *mut GstPad, event: *mut GstEvent) -> gboolean;
    pub fn gst_pad_set_activate_function_full(pad: *mut GstPad, activate: GstPadActivateFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_activatemode_function_full(pad: *mut GstPad, activatemode: GstPadActivateModeFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_active(pad: *mut GstPad, active: gboolean) -> gboolean;
    pub fn gst_pad_set_chain_function_full(pad: *mut GstPad, chain: GstPadChainFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_chain_list_function_full(pad: *mut GstPad, chainlist: GstPadChainListFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_element_private(pad: *mut GstPad, priv_: gpointer);
    #[cfg(feature = "v1_8")]
    pub fn gst_pad_set_event_full_function_full(pad: *mut GstPad, event: GstPadEventFullFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_event_function_full(pad: *mut GstPad, event: GstPadEventFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_getrange_function_full(pad: *mut GstPad, get: GstPadGetRangeFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_iterate_internal_links_function_full(pad: *mut GstPad, iterintlink: GstPadIterIntLinkFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_link_function_full(pad: *mut GstPad, link: GstPadLinkFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_offset(pad: *mut GstPad, offset: i64);
    pub fn gst_pad_set_query_function_full(pad: *mut GstPad, query: GstPadQueryFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_unlink_function_full(pad: *mut GstPad, unlink: GstPadUnlinkFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_start_task(pad: *mut GstPad, func: GstTaskFunction, user_data: gpointer, notify: glib::GDestroyNotify) -> gboolean;
    pub fn gst_pad_sticky_events_foreach(pad: *mut GstPad, foreach_func: GstPadStickyEventsForeachFunction, user_data: gpointer);
    pub fn gst_pad_stop_task(pad: *mut GstPad) -> gboolean;
    #[cfg(feature = "v1_2")]
    pub fn gst_pad_store_sticky_event(pad: *mut GstPad, event: *mut GstEvent) -> GstFlowReturn;
    pub fn gst_pad_unlink(srcpad: *mut GstPad, sinkpad: *mut GstPad) -> gboolean;
    pub fn gst_pad_use_fixed_caps(pad: *mut GstPad);

    //=========================================================================
    // GstPadTemplate
    //=========================================================================
    pub fn gst_pad_template_get_type() -> GType;
    pub fn gst_pad_template_new(name_template: *const c_char, direction: GstPadDirection, presence: GstPadPresence, caps: *mut GstCaps) -> *mut GstPadTemplate;
    pub fn gst_pad_template_get_caps(templ: *mut GstPadTemplate) -> *mut GstCaps;
    pub fn gst_pad_template_pad_created(templ: *mut GstPadTemplate, pad: *mut GstPad);

    //=========================================================================
    // GstParamArray
    //=========================================================================
    pub fn gst_param_spec_array_get_type() -> GType;

    //=========================================================================
    // GstParamFraction
    //=========================================================================
    pub fn gst_param_spec_fraction_get_type() -> GType;

    //=========================================================================
    // GstPipeline
    //=========================================================================
    pub fn gst_pipeline_get_type() -> GType;
    pub fn gst_pipeline_new(name: *const c_char) -> *mut GstElement;
    pub fn gst_pipeline_auto_clock(pipeline: *mut GstPipeline);
    pub fn gst_pipeline_get_auto_flush_bus(pipeline: *mut GstPipeline) -> gboolean;
    pub fn gst_pipeline_get_bus(pipeline: *mut GstPipeline) -> *mut GstBus;
    pub fn gst_pipeline_get_clock(pipeline: *mut GstPipeline) -> *mut GstClock;
    pub fn gst_pipeline_get_delay(pipeline: *mut GstPipeline) -> GstClockTime;
    #[cfg(feature = "v1_6")]
    pub fn gst_pipeline_get_latency(pipeline: *mut GstPipeline) -> GstClockTime;
    #[cfg(feature = "v1_6")]
    pub fn gst_pipeline_get_pipeline_clock(pipeline: *mut GstPipeline) -> *mut GstClock;
    pub fn gst_pipeline_set_auto_flush_bus(pipeline: *mut GstPipeline, auto_flush: gboolean);
    pub fn gst_pipeline_set_clock(pipeline: *mut GstPipeline, clock: *mut GstClock) -> gboolean;
    pub fn gst_pipeline_set_delay(pipeline: *mut GstPipeline, delay: GstClockTime);
    #[cfg(feature = "v1_6")]
    pub fn gst_pipeline_set_latency(pipeline: *mut GstPipeline, latency: GstClockTime);
    pub fn gst_pipeline_use_clock(pipeline: *mut GstPipeline, clock: *mut GstClock);

    //=========================================================================
    // GstPlugin
    //=========================================================================
    pub fn gst_plugin_get_type() -> GType;
    pub fn gst_plugin_list_free(list: *mut glib::GList);
    pub fn gst_plugin_load_by_name(name: *const c_char) -> *mut GstPlugin;
    pub fn gst_plugin_load_file(filename: *const c_char, error: *mut *mut glib::GError) -> *mut GstPlugin;
    pub fn gst_plugin_register_static(major_version: c_int, minor_version: c_int, name: *const c_char, description: *const c_char, init_func: GstPluginInitFunc, version: *const c_char, license: *const c_char, source: *const c_char, package: *const c_char, origin: *const c_char) -> gboolean;
    pub fn gst_plugin_register_static_full(major_version: c_int, minor_version: c_int, name: *const c_char, description: *const c_char, init_full_func: GstPluginInitFullFunc, version: *const c_char, license: *const c_char, source: *const c_char, package: *const c_char, origin: *const c_char, user_data: gpointer) -> gboolean;
    pub fn gst_plugin_add_dependency(plugin: *mut GstPlugin, env_vars: *mut *const c_char, paths: *mut *const c_char, names: *mut *const c_char, flags: GstPluginDependencyFlags);
    pub fn gst_plugin_add_dependency_simple(plugin: *mut GstPlugin, env_vars: *const c_char, paths: *const c_char, names: *const c_char, flags: GstPluginDependencyFlags);
    pub fn gst_plugin_get_cache_data(plugin: *mut GstPlugin) -> *const GstStructure;
    pub fn gst_plugin_get_description(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_filename(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_license(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_name(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_origin(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_package(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_release_date_string(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_source(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_version(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_is_loaded(plugin: *mut GstPlugin) -> gboolean;
    pub fn gst_plugin_load(plugin: *mut GstPlugin) -> *mut GstPlugin;
    pub fn gst_plugin_set_cache_data(plugin: *mut GstPlugin, cache_data: *mut GstStructure);

    //=========================================================================
    // GstPluginFeature
    //=========================================================================
    pub fn gst_plugin_feature_get_type() -> GType;
    pub fn gst_plugin_feature_list_copy(list: *mut glib::GList) -> *mut glib::GList;
    pub fn gst_plugin_feature_list_debug(list: *mut glib::GList);
    pub fn gst_plugin_feature_list_free(list: *mut glib::GList);
    pub fn gst_plugin_feature_rank_compare_func(p1: gconstpointer, p2: gconstpointer) -> c_int;
    pub fn gst_plugin_feature_check_version(feature: *mut GstPluginFeature, min_major: c_uint, min_minor: c_uint, min_micro: c_uint) -> gboolean;
    pub fn gst_plugin_feature_get_plugin(feature: *mut GstPluginFeature) -> *mut GstPlugin;
    #[cfg(feature = "v1_2")]
    pub fn gst_plugin_feature_get_plugin_name(feature: *mut GstPluginFeature) -> *const c_char;
    pub fn gst_plugin_feature_get_rank(feature: *mut GstPluginFeature) -> c_uint;
    pub fn gst_plugin_feature_load(feature: *mut GstPluginFeature) -> *mut GstPluginFeature;
    pub fn gst_plugin_feature_set_rank(feature: *mut GstPluginFeature, rank: c_uint);

    //=========================================================================
    // GstProxyPad
    //=========================================================================
    pub fn gst_proxy_pad_get_type() -> GType;
    pub fn gst_proxy_pad_chain_default(pad: *mut GstPad, parent: *mut GstObject, buffer: *mut GstBuffer) -> GstFlowReturn;
    pub fn gst_proxy_pad_chain_list_default(pad: *mut GstPad, parent: *mut GstObject, list: *mut GstBufferList) -> GstFlowReturn;
    pub fn gst_proxy_pad_getrange_default(pad: *mut GstPad, parent: *mut GstObject, offset: u64, size: c_uint, buffer: *mut *mut GstBuffer) -> GstFlowReturn;
    pub fn gst_proxy_pad_iterate_internal_links_default(pad: *mut GstPad, parent: *mut GstObject) -> *mut GstIterator;
    pub fn gst_proxy_pad_get_internal(pad: *mut GstProxyPad) -> *mut GstProxyPad;

    //=========================================================================
    // GstRegistry
    //=========================================================================
    pub fn gst_registry_get_type() -> GType;
    pub fn gst_registry_fork_is_enabled() -> gboolean;
    pub fn gst_registry_fork_set_enabled(enabled: gboolean);
    pub fn gst_registry_get() -> *mut GstRegistry;
    pub fn gst_registry_add_feature(registry: *mut GstRegistry, feature: *mut GstPluginFeature) -> gboolean;
    pub fn gst_registry_add_plugin(registry: *mut GstRegistry, plugin: *mut GstPlugin) -> gboolean;
    pub fn gst_registry_check_feature_version(registry: *mut GstRegistry, feature_name: *const c_char, min_major: c_uint, min_minor: c_uint, min_micro: c_uint) -> gboolean;
    pub fn gst_registry_feature_filter(registry: *mut GstRegistry, filter: GstPluginFeatureFilter, first: gboolean, user_data: gpointer) -> *mut glib::GList;
    pub fn gst_registry_find_feature(registry: *mut GstRegistry, name: *const c_char, type_: GType) -> *mut GstPluginFeature;
    pub fn gst_registry_find_plugin(registry: *mut GstRegistry, name: *const c_char) -> *mut GstPlugin;
    pub fn gst_registry_get_feature_list(registry: *mut GstRegistry, type_: GType) -> *mut glib::GList;
    pub fn gst_registry_get_feature_list_by_plugin(registry: *mut GstRegistry, name: *const c_char) -> *mut glib::GList;
    pub fn gst_registry_get_feature_list_cookie(registry: *mut GstRegistry) -> u32;
    pub fn gst_registry_get_plugin_list(registry: *mut GstRegistry) -> *mut glib::GList;
    pub fn gst_registry_lookup(registry: *mut GstRegistry, filename: *const c_char) -> *mut GstPlugin;
    pub fn gst_registry_lookup_feature(registry: *mut GstRegistry, name: *const c_char) -> *mut GstPluginFeature;
    pub fn gst_registry_plugin_filter(registry: *mut GstRegistry, filter: GstPluginFilter, first: gboolean, user_data: gpointer) -> *mut glib::GList;
    pub fn gst_registry_remove_feature(registry: *mut GstRegistry, feature: *mut GstPluginFeature);
    pub fn gst_registry_remove_plugin(registry: *mut GstRegistry, plugin: *mut GstPlugin);
    pub fn gst_registry_scan_path(registry: *mut GstRegistry, path: *const c_char) -> gboolean;

    //=========================================================================
    // GstStream
    //=========================================================================
    pub fn gst_stream_get_type() -> GType;
    #[cfg(feature = "v1_10")]
    pub fn gst_stream_new(stream_id: *const c_char, caps: *mut GstCaps, type_: GstStreamType, flags: GstStreamFlags) -> *mut GstStream;
    #[cfg(feature = "v1_10")]
    pub fn gst_stream_get_caps(stream: *mut GstStream) -> *mut GstCaps;
    #[cfg(feature = "v1_10")]
    pub fn gst_stream_get_stream_flags(stream: *mut GstStream) -> GstStreamFlags;
    #[cfg(feature = "v1_10")]
    pub fn gst_stream_get_stream_id(stream: *mut GstStream) -> *const c_char;
    #[cfg(feature = "v1_10")]
    pub fn gst_stream_get_stream_type(stream: *mut GstStream) -> GstStreamType;
    #[cfg(feature = "v1_10")]
    pub fn gst_stream_get_tags(stream: *mut GstStream) -> *mut GstTagList;
    #[cfg(feature = "v1_10")]
    pub fn gst_stream_set_caps(stream: *mut GstStream, caps: *mut GstCaps);
    #[cfg(feature = "v1_10")]
    pub fn gst_stream_set_stream_flags(stream: *mut GstStream, flags: GstStreamFlags);
    #[cfg(feature = "v1_10")]
    pub fn gst_stream_set_stream_type(stream: *mut GstStream, stream_type: GstStreamType);
    #[cfg(feature = "v1_10")]
    pub fn gst_stream_set_tags(stream: *mut GstStream, tags: *mut GstTagList);

    //=========================================================================
    // GstStreamCollection
    //=========================================================================
    pub fn gst_stream_collection_get_type() -> GType;
    #[cfg(feature = "v1_10")]
    pub fn gst_stream_collection_new(upstream_id: *const c_char) -> *mut GstStreamCollection;
    #[cfg(feature = "v1_10")]
    pub fn gst_stream_collection_add_stream(collection: *mut GstStreamCollection, stream: *mut GstStream) -> gboolean;
    #[cfg(feature = "v1_10")]
    pub fn gst_stream_collection_get_size(collection: *mut GstStreamCollection) -> c_uint;
    #[cfg(feature = "v1_10")]
    pub fn gst_stream_collection_get_stream(collection: *mut GstStreamCollection, index: c_uint) -> *mut GstStream;
    #[cfg(feature = "v1_10")]
    pub fn gst_stream_collection_get_upstream_id(collection: *mut GstStreamCollection) -> *const c_char;

    //=========================================================================
    // GstSystemClock
    //=========================================================================
    pub fn gst_system_clock_get_type() -> GType;
    pub fn gst_system_clock_obtain() -> *mut GstClock;
    #[cfg(feature = "v1_4")]
    pub fn gst_system_clock_set_default(new_clock: *mut GstClock);

    //=========================================================================
    // GstTask
    //=========================================================================
    pub fn gst_task_get_type() -> GType;
    pub fn gst_task_new(func: GstTaskFunction, user_data: gpointer, notify: glib::GDestroyNotify) -> *mut GstTask;
    pub fn gst_task_cleanup_all();
    pub fn gst_task_get_pool(task: *mut GstTask) -> *mut GstTaskPool;
    pub fn gst_task_get_state(task: *mut GstTask) -> GstTaskState;
    pub fn gst_task_join(task: *mut GstTask) -> gboolean;
    pub fn gst_task_pause(task: *mut GstTask) -> gboolean;
    pub fn gst_task_set_enter_callback(task: *mut GstTask, enter_func: GstTaskThreadFunc, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_task_set_leave_callback(task: *mut GstTask, leave_func: GstTaskThreadFunc, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_task_set_lock(task: *mut GstTask, mutex: *mut glib::GRecMutex);
    pub fn gst_task_set_pool(task: *mut GstTask, pool: *mut GstTaskPool);
    pub fn gst_task_set_state(task: *mut GstTask, state: GstTaskState) -> gboolean;
    pub fn gst_task_start(task: *mut GstTask) -> gboolean;
    pub fn gst_task_stop(task: *mut GstTask) -> gboolean;

    //=========================================================================
    // GstTaskPool
    //=========================================================================
    pub fn gst_task_pool_get_type() -> GType;
    pub fn gst_task_pool_new() -> *mut GstTaskPool;
    pub fn gst_task_pool_cleanup(pool: *mut GstTaskPool);
    pub fn gst_task_pool_join(pool: *mut GstTaskPool, id: gpointer);
    pub fn gst_task_pool_prepare(pool: *mut GstTaskPool, error: *mut *mut glib::GError);
    pub fn gst_task_pool_push(pool: *mut GstTaskPool, func: GstTaskPoolFunction, user_data: gpointer, error: *mut *mut glib::GError) -> gpointer;

    //=========================================================================
    // GstTracer
    //=========================================================================
    pub fn gst_tracer_get_type() -> GType;

    //=========================================================================
    // GstTracerFactory
    //=========================================================================
    pub fn gst_tracer_factory_get_type() -> GType;
    #[cfg(feature = "v1_8")]
    pub fn gst_tracer_factory_get_list() -> *mut glib::GList;

    //=========================================================================
    // GstTracerRecord
    //=========================================================================
    pub fn gst_tracer_record_get_type() -> GType;

    //=========================================================================
    // GstTypeFindFactory
    //=========================================================================
    pub fn gst_type_find_factory_get_type() -> GType;
    pub fn gst_type_find_factory_get_list() -> *mut glib::GList;
    pub fn gst_type_find_factory_call_function(factory: *mut GstTypeFindFactory, find: *mut GstTypeFind);
    pub fn gst_type_find_factory_get_caps(factory: *mut GstTypeFindFactory) -> *mut GstCaps;
    pub fn gst_type_find_factory_get_extensions(factory: *mut GstTypeFindFactory) -> *mut *mut c_char;
    pub fn gst_type_find_factory_has_function(factory: *mut GstTypeFindFactory) -> gboolean;

    //=========================================================================
    // GstValueArray
    //=========================================================================
    pub fn gst_value_array_get_type() -> GType;
    #[cfg(feature = "v1_2")]
    pub fn gst_value_array_append_and_take_value(value: *mut gobject::GValue, append_value: *mut gobject::GValue);
    pub fn gst_value_array_append_value(value: *mut gobject::GValue, append_value: *const gobject::GValue);
    pub fn gst_value_array_get_size(value: *const gobject::GValue) -> c_uint;
    pub fn gst_value_array_get_value(value: *const gobject::GValue, index: c_uint) -> *const gobject::GValue;
    pub fn gst_value_array_prepend_value(value: *mut gobject::GValue, prepend_value: *const gobject::GValue);

    //=========================================================================
    // GstValueList
    //=========================================================================
    pub fn gst_value_list_get_type() -> GType;
    #[cfg(feature = "v1_2")]
    pub fn gst_value_list_append_and_take_value(value: *mut gobject::GValue, append_value: *mut gobject::GValue);
    pub fn gst_value_list_append_value(value: *mut gobject::GValue, append_value: *const gobject::GValue);
    pub fn gst_value_list_concat(dest: *mut gobject::GValue, value1: *const gobject::GValue, value2: *const gobject::GValue);
    pub fn gst_value_list_get_size(value: *const gobject::GValue) -> c_uint;
    pub fn gst_value_list_get_value(value: *const gobject::GValue, index: c_uint) -> *const gobject::GValue;
    pub fn gst_value_list_merge(dest: *mut gobject::GValue, value1: *const gobject::GValue, value2: *const gobject::GValue);
    pub fn gst_value_list_prepend_value(value: *mut gobject::GValue, prepend_value: *const gobject::GValue);

    //=========================================================================
    // GstChildProxy
    //=========================================================================
    pub fn gst_child_proxy_get_type() -> GType;
    pub fn gst_child_proxy_child_added(parent: *mut GstChildProxy, child: *mut gobject::GObject, name: *const c_char);
    pub fn gst_child_proxy_child_removed(parent: *mut GstChildProxy, child: *mut gobject::GObject, name: *const c_char);
    pub fn gst_child_proxy_get(object: *mut GstChildProxy, first_property_name: *const c_char, ...);
    pub fn gst_child_proxy_get_child_by_index(parent: *mut GstChildProxy, index: c_uint) -> *mut gobject::GObject;
    pub fn gst_child_proxy_get_child_by_name(parent: *mut GstChildProxy, name: *const c_char) -> *mut gobject::GObject;
    pub fn gst_child_proxy_get_children_count(parent: *mut GstChildProxy) -> c_uint;
    pub fn gst_child_proxy_get_property(object: *mut GstChildProxy, name: *const c_char, value: *mut gobject::GValue);
    //pub fn gst_child_proxy_get_valist(object: *mut GstChildProxy, first_property_name: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn gst_child_proxy_lookup(object: *mut GstChildProxy, name: *const c_char, target: *mut *mut gobject::GObject, pspec: *mut *mut gobject::GParamSpec) -> gboolean;
    pub fn gst_child_proxy_set(object: *mut GstChildProxy, first_property_name: *const c_char, ...);
    pub fn gst_child_proxy_set_property(object: *mut GstChildProxy, name: *const c_char, value: *const gobject::GValue);
    //pub fn gst_child_proxy_set_valist(object: *mut GstChildProxy, first_property_name: *const c_char, var_args: /*Unimplemented*/va_list);

    //=========================================================================
    // GstPreset
    //=========================================================================
    pub fn gst_preset_get_type() -> GType;
    pub fn gst_preset_get_app_dir() -> *const c_char;
    pub fn gst_preset_set_app_dir(app_dir: *const c_char) -> gboolean;
    pub fn gst_preset_delete_preset(preset: *mut GstPreset, name: *const c_char) -> gboolean;
    pub fn gst_preset_get_meta(preset: *mut GstPreset, name: *const c_char, tag: *const c_char, value: *mut *mut c_char) -> gboolean;
    pub fn gst_preset_get_preset_names(preset: *mut GstPreset) -> *mut *mut c_char;
    pub fn gst_preset_get_property_names(preset: *mut GstPreset) -> *mut *mut c_char;
    #[cfg(feature = "v1_6")]
    pub fn gst_preset_is_editable(preset: *mut GstPreset) -> gboolean;
    pub fn gst_preset_load_preset(preset: *mut GstPreset, name: *const c_char) -> gboolean;
    pub fn gst_preset_rename_preset(preset: *mut GstPreset, old_name: *const c_char, new_name: *const c_char) -> gboolean;
    pub fn gst_preset_save_preset(preset: *mut GstPreset, name: *const c_char) -> gboolean;
    pub fn gst_preset_set_meta(preset: *mut GstPreset, name: *const c_char, tag: *const c_char, value: *const c_char) -> gboolean;

    //=========================================================================
    // GstTagSetter
    //=========================================================================
    pub fn gst_tag_setter_get_type() -> GType;
    //pub fn gst_tag_setter_add_tag_valist(setter: *mut GstTagSetter, mode: GstTagMergeMode, tag: *const c_char, var_args: /*Unimplemented*/va_list);
    //pub fn gst_tag_setter_add_tag_valist_values(setter: *mut GstTagSetter, mode: GstTagMergeMode, tag: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn gst_tag_setter_add_tag_value(setter: *mut GstTagSetter, mode: GstTagMergeMode, tag: *const c_char, value: *const gobject::GValue);
    pub fn gst_tag_setter_add_tag_values(setter: *mut GstTagSetter, mode: GstTagMergeMode, tag: *const c_char, ...);
    pub fn gst_tag_setter_add_tags(setter: *mut GstTagSetter, mode: GstTagMergeMode, tag: *const c_char, ...);
    pub fn gst_tag_setter_get_tag_list(setter: *mut GstTagSetter) -> *const GstTagList;
    pub fn gst_tag_setter_get_tag_merge_mode(setter: *mut GstTagSetter) -> GstTagMergeMode;
    pub fn gst_tag_setter_merge_tags(setter: *mut GstTagSetter, list: *const GstTagList, mode: GstTagMergeMode);
    pub fn gst_tag_setter_reset_tags(setter: *mut GstTagSetter);
    pub fn gst_tag_setter_set_tag_merge_mode(setter: *mut GstTagSetter, mode: GstTagMergeMode);

    //=========================================================================
    // GstTocSetter
    //=========================================================================
    pub fn gst_toc_setter_get_type() -> GType;
    pub fn gst_toc_setter_get_toc(setter: *mut GstTocSetter) -> *mut GstToc;
    pub fn gst_toc_setter_reset(setter: *mut GstTocSetter);
    pub fn gst_toc_setter_set_toc(setter: *mut GstTocSetter, toc: *mut GstToc);

    //=========================================================================
    // GstURIHandler
    //=========================================================================
    pub fn gst_uri_handler_get_type() -> GType;
    pub fn gst_uri_handler_get_protocols(handler: *mut GstURIHandler) -> *const *const c_char;
    pub fn gst_uri_handler_get_uri(handler: *mut GstURIHandler) -> *mut c_char;
    pub fn gst_uri_handler_get_uri_type(handler: *mut GstURIHandler) -> GstURIType;
    pub fn gst_uri_handler_set_uri(handler: *mut GstURIHandler, uri: *const c_char, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // Other functions
    //=========================================================================
    #[cfg(feature = "v1_12")]
    pub fn gst_calculate_linear_regression(xy: *const GstClockTime, temp: *mut GstClockTime, n: c_uint, m_num: *mut GstClockTime, m_denom: *mut GstClockTime, b: *mut GstClockTime, xbase: *mut GstClockTime, r_squared: *mut c_double) -> gboolean;
    pub fn gst_debug_add_log_function(func: GstLogFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_debug_bin_to_dot_data(bin: *mut GstBin, details: GstDebugGraphDetails) -> *mut c_char;
    pub fn gst_debug_bin_to_dot_file(bin: *mut GstBin, details: GstDebugGraphDetails, file_name: *const c_char);
    pub fn gst_debug_bin_to_dot_file_with_ts(bin: *mut GstBin, details: GstDebugGraphDetails, file_name: *const c_char);
    pub fn gst_debug_construct_term_color(colorinfo: c_uint) -> *mut c_char;
    pub fn gst_debug_construct_win_color(colorinfo: c_uint) -> c_int;
    pub fn gst_debug_get_all_categories() -> *mut glib::GSList;
    #[cfg(feature = "v1_2")]
    pub fn gst_debug_get_color_mode() -> GstDebugColorMode;
    pub fn gst_debug_get_default_threshold() -> GstDebugLevel;
    #[cfg(feature = "v1_12")]
    pub fn gst_debug_get_stack_trace(flags: GstStackTraceFlags) -> *mut c_char;
    pub fn gst_debug_is_active() -> gboolean;
    pub fn gst_debug_is_colored() -> gboolean;
    pub fn gst_debug_log(category: *mut GstDebugCategory, level: GstDebugLevel, file: *const c_char, function: *const c_char, line: c_int, object: *mut gobject::GObject, format: *const c_char, ...);
    pub fn gst_debug_log_default(category: *mut GstDebugCategory, level: GstDebugLevel, file: *const c_char, function: *const c_char, line: c_int, object: *mut gobject::GObject, message: *mut GstDebugMessage, user_data: gpointer);
    //pub fn gst_debug_log_valist(category: *mut GstDebugCategory, level: GstDebugLevel, file: *const c_char, function: *const c_char, line: c_int, object: *mut gobject::GObject, format: *const c_char, args: /*Unimplemented*/va_list);
    pub fn gst_debug_print_stack_trace();
    pub fn gst_debug_remove_log_function(func: GstLogFunction) -> c_uint;
    pub fn gst_debug_remove_log_function_by_data(data: gpointer) -> c_uint;
    pub fn gst_debug_set_active(active: gboolean);
    #[cfg(feature = "v1_2")]
    pub fn gst_debug_set_color_mode(mode: GstDebugColorMode);
    #[cfg(feature = "v1_2")]
    pub fn gst_debug_set_color_mode_from_string(mode: *const c_char);
    pub fn gst_debug_set_colored(colored: gboolean);
    pub fn gst_debug_set_default_threshold(level: GstDebugLevel);
    pub fn gst_debug_set_threshold_for_name(name: *const c_char, level: GstDebugLevel);
    #[cfg(feature = "v1_2")]
    pub fn gst_debug_set_threshold_from_string(list: *const c_char, reset: gboolean);
    pub fn gst_debug_unset_threshold_for_name(name: *const c_char);
    pub fn gst_deinit();
    pub fn gst_dynamic_type_register(plugin: *mut GstPlugin, type_: GType) -> gboolean;
    pub fn gst_error_get_message(domain: glib::GQuark, code: c_int) -> *mut c_char;
    pub fn gst_filename_to_uri(filename: *const c_char, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn gst_flow_get_name(ret: GstFlowReturn) -> *const c_char;
    pub fn gst_flow_to_quark(ret: GstFlowReturn) -> glib::GQuark;
    pub fn gst_formats_contains(formats: *mut GstFormat, format: GstFormat) -> gboolean;
    #[cfg(feature = "v1_8")]
    pub fn gst_info_strdup_printf(format: *const c_char, ...) -> *mut c_char;
    //#[cfg(feature = "v1_8")]
    //pub fn gst_info_strdup_vprintf(format: *const c_char, args: /*Unimplemented*/va_list) -> *mut c_char;
    //#[cfg(feature = "v1_8")]
    //pub fn gst_info_vasprintf(result: *mut *mut c_char, format: *const c_char, args: /*Unimplemented*/va_list) -> c_int;
    pub fn gst_init(argc: *mut c_int, argv: *mut *mut c_char);
    pub fn gst_init_check(argc: *mut c_int, argv: *mut *mut c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn gst_init_get_option_group() -> *mut glib::GOptionGroup;
    pub fn gst_is_caps_features(obj: gconstpointer) -> gboolean;
    pub fn gst_is_initialized() -> gboolean;
    pub fn gst_make_element_message_details(name: *const c_char, ...) -> *mut GstStructure;
    pub fn gst_param_spec_array(name: *const c_char, nick: *const c_char, blurb: *const c_char, element_spec: *mut gobject::GParamSpec, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gst_param_spec_fraction(name: *const c_char, nick: *const c_char, blurb: *const c_char, min_num: c_int, min_denom: c_int, max_num: c_int, max_denom: c_int, default_num: c_int, default_denom: c_int, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gst_parent_buffer_meta_api_get_type() -> GType;
    pub fn gst_parse_bin_from_description(bin_description: *const c_char, ghost_unlinked_pads: gboolean, error: *mut *mut glib::GError) -> *mut GstBin;
    pub fn gst_parse_bin_from_description_full(bin_description: *const c_char, ghost_unlinked_pads: gboolean, context: *mut GstParseContext, flags: GstParseFlags, error: *mut *mut glib::GError) -> *mut GstElement;
    pub fn gst_parse_launch(pipeline_description: *const c_char, error: *mut *mut glib::GError) -> *mut GstElement;
    pub fn gst_parse_launch_full(pipeline_description: *const c_char, context: *mut GstParseContext, flags: GstParseFlags, error: *mut *mut glib::GError) -> *mut GstElement;
    pub fn gst_parse_launchv(argv: *mut *mut c_char, error: *mut *mut glib::GError) -> *mut GstElement;
    pub fn gst_parse_launchv_full(argv: *mut *mut c_char, context: *mut GstParseContext, flags: GstParseFlags, error: *mut *mut glib::GError) -> *mut GstElement;
    #[cfg(feature = "v1_12")]
    pub fn gst_print(format: *const c_char, ...);
    #[cfg(feature = "v1_12")]
    pub fn gst_printerr(format: *const c_char, ...);
    #[cfg(feature = "v1_12")]
    pub fn gst_printerrln(format: *const c_char, ...);
    #[cfg(feature = "v1_12")]
    pub fn gst_println(format: *const c_char, ...);
    pub fn gst_protection_meta_api_get_type() -> GType;
    #[cfg(feature = "v1_6")]
    pub fn gst_protection_select_system(system_identifiers: *mut *const c_char) -> *const c_char;
    pub fn gst_segtrap_is_enabled() -> gboolean;
    pub fn gst_segtrap_set_enabled(enabled: gboolean);
    pub fn gst_static_caps_get_type() -> GType;
    pub fn gst_static_pad_template_get_type() -> GType;
    pub fn gst_tag_exists(tag: *const c_char) -> gboolean;
    pub fn gst_tag_get_description(tag: *const c_char) -> *const c_char;
    pub fn gst_tag_get_flag(tag: *const c_char) -> GstTagFlag;
    pub fn gst_tag_get_nick(tag: *const c_char) -> *const c_char;
    pub fn gst_tag_get_type(tag: *const c_char) -> GType;
    pub fn gst_tag_is_fixed(tag: *const c_char) -> gboolean;
    pub fn gst_tag_merge_strings_with_comma(dest: *mut gobject::GValue, src: *const gobject::GValue);
    pub fn gst_tag_merge_use_first(dest: *mut gobject::GValue, src: *const gobject::GValue);
    pub fn gst_tag_register(name: *const c_char, flag: GstTagFlag, type_: GType, nick: *const c_char, blurb: *const c_char, func: GstTagMergeFunc);
    pub fn gst_tag_register_static(name: *const c_char, flag: GstTagFlag, type_: GType, nick: *const c_char, blurb: *const c_char, func: GstTagMergeFunc);
    pub fn gst_type_find_get_type() -> GType;
    pub fn gst_update_registry() -> gboolean;
    pub fn gst_util_array_binary_search(array: gpointer, num_elements: c_uint, element_size: size_t, search_func: glib::GCompareDataFunc, mode: GstSearchMode, search_data: gconstpointer, user_data: gpointer) -> gpointer;
    pub fn gst_util_double_to_fraction(src: c_double, dest_n: *mut c_int, dest_d: *mut c_int);
    pub fn gst_util_dump_mem(mem: *const u8, size: c_uint);
    pub fn gst_util_fraction_add(a_n: c_int, a_d: c_int, b_n: c_int, b_d: c_int, res_n: *mut c_int, res_d: *mut c_int) -> gboolean;
    pub fn gst_util_fraction_compare(a_n: c_int, a_d: c_int, b_n: c_int, b_d: c_int) -> c_int;
    pub fn gst_util_fraction_multiply(a_n: c_int, a_d: c_int, b_n: c_int, b_d: c_int, res_n: *mut c_int, res_d: *mut c_int) -> gboolean;
    pub fn gst_util_fraction_to_double(src_n: c_int, src_d: c_int, dest: *mut c_double);
    pub fn gst_util_gdouble_to_guint64(value: c_double) -> u64;
    #[cfg(feature = "v1_12")]
    pub fn gst_util_get_object_array(object: *mut gobject::GObject, name: *const c_char, array: *mut *mut gobject::GValueArray) -> gboolean;
    pub fn gst_util_get_timestamp() -> GstClockTime;
    pub fn gst_util_greatest_common_divisor(a: c_int, b: c_int) -> c_int;
    pub fn gst_util_greatest_common_divisor_int64(a: i64, b: i64) -> i64;
    pub fn gst_util_group_id_next() -> c_uint;
    pub fn gst_util_guint64_to_gdouble(value: u64) -> c_double;
    pub fn gst_util_seqnum_compare(s1: u32, s2: u32) -> i32;
    pub fn gst_util_seqnum_next() -> u32;
    pub fn gst_util_set_object_arg(object: *mut gobject::GObject, name: *const c_char, value: *const c_char);
    #[cfg(feature = "v1_12")]
    pub fn gst_util_set_object_array(object: *mut gobject::GObject, name: *const c_char, array: *const gobject::GValueArray) -> gboolean;
    pub fn gst_util_set_value_from_string(value: *mut gobject::GValue, value_str: *const c_char);
    pub fn gst_util_uint64_scale(val: u64, num: u64, denom: u64) -> u64;
    pub fn gst_util_uint64_scale_ceil(val: u64, num: u64, denom: u64) -> u64;
    pub fn gst_util_uint64_scale_int(val: u64, num: c_int, denom: c_int) -> u64;
    pub fn gst_util_uint64_scale_int_ceil(val: u64, num: c_int, denom: c_int) -> u64;
    pub fn gst_util_uint64_scale_int_round(val: u64, num: c_int, denom: c_int) -> u64;
    pub fn gst_util_uint64_scale_round(val: u64, num: u64, denom: u64) -> u64;
    pub fn gst_value_can_compare(value1: *const gobject::GValue, value2: *const gobject::GValue) -> gboolean;
    pub fn gst_value_can_intersect(value1: *const gobject::GValue, value2: *const gobject::GValue) -> gboolean;
    pub fn gst_value_can_subtract(minuend: *const gobject::GValue, subtrahend: *const gobject::GValue) -> gboolean;
    pub fn gst_value_can_union(value1: *const gobject::GValue, value2: *const gobject::GValue) -> gboolean;
    pub fn gst_value_compare(value1: *const gobject::GValue, value2: *const gobject::GValue) -> c_int;
    pub fn gst_value_deserialize(dest: *mut gobject::GValue, src: *const c_char) -> gboolean;
    pub fn gst_value_fixate(dest: *mut gobject::GValue, src: *const gobject::GValue) -> gboolean;
    pub fn gst_value_fraction_multiply(product: *mut gobject::GValue, factor1: *const gobject::GValue, factor2: *const gobject::GValue) -> gboolean;
    pub fn gst_value_fraction_subtract(dest: *mut gobject::GValue, minuend: *const gobject::GValue, subtrahend: *const gobject::GValue) -> gboolean;
    pub fn gst_value_get_bitmask(value: *const gobject::GValue) -> u64;
    pub fn gst_value_get_caps(value: *const gobject::GValue) -> *const GstCaps;
    pub fn gst_value_get_caps_features(value: *const gobject::GValue) -> *const GstCapsFeatures;
    pub fn gst_value_get_double_range_max(value: *const gobject::GValue) -> c_double;
    pub fn gst_value_get_double_range_min(value: *const gobject::GValue) -> c_double;
    #[cfg(feature = "v1_6")]
    pub fn gst_value_get_flagset_flags(value: *const gobject::GValue) -> c_uint;
    #[cfg(feature = "v1_6")]
    pub fn gst_value_get_flagset_mask(value: *const gobject::GValue) -> c_uint;
    pub fn gst_value_get_fraction_denominator(value: *const gobject::GValue) -> c_int;
    pub fn gst_value_get_fraction_numerator(value: *const gobject::GValue) -> c_int;
    pub fn gst_value_get_fraction_range_max(value: *const gobject::GValue) -> *const gobject::GValue;
    pub fn gst_value_get_fraction_range_min(value: *const gobject::GValue) -> *const gobject::GValue;
    pub fn gst_value_get_int64_range_max(value: *const gobject::GValue) -> i64;
    pub fn gst_value_get_int64_range_min(value: *const gobject::GValue) -> i64;
    pub fn gst_value_get_int64_range_step(value: *const gobject::GValue) -> i64;
    pub fn gst_value_get_int_range_max(value: *const gobject::GValue) -> c_int;
    pub fn gst_value_get_int_range_min(value: *const gobject::GValue) -> c_int;
    pub fn gst_value_get_int_range_step(value: *const gobject::GValue) -> c_int;
    pub fn gst_value_get_structure(value: *const gobject::GValue) -> *const GstStructure;
    pub fn gst_value_init_and_copy(dest: *mut gobject::GValue, src: *const gobject::GValue);
    pub fn gst_value_intersect(dest: *mut gobject::GValue, value1: *const gobject::GValue, value2: *const gobject::GValue) -> gboolean;
    pub fn gst_value_is_fixed(value: *const gobject::GValue) -> gboolean;
    pub fn gst_value_is_subset(value1: *const gobject::GValue, value2: *const gobject::GValue) -> gboolean;
    pub fn gst_value_register(table: *const GstValueTable);
    pub fn gst_value_serialize(value: *const gobject::GValue) -> *mut c_char;
    pub fn gst_value_set_bitmask(value: *mut gobject::GValue, bitmask: u64);
    pub fn gst_value_set_caps(value: *mut gobject::GValue, caps: *const GstCaps);
    pub fn gst_value_set_caps_features(value: *mut gobject::GValue, features: *const GstCapsFeatures);
    pub fn gst_value_set_double_range(value: *mut gobject::GValue, start: c_double, end: c_double);
    #[cfg(feature = "v1_6")]
    pub fn gst_value_set_flagset(value: *mut gobject::GValue, flags: c_uint, mask: c_uint);
    pub fn gst_value_set_fraction(value: *mut gobject::GValue, numerator: c_int, denominator: c_int);
    pub fn gst_value_set_fraction_range(value: *mut gobject::GValue, start: *const gobject::GValue, end: *const gobject::GValue);
    pub fn gst_value_set_fraction_range_full(value: *mut gobject::GValue, numerator_start: c_int, denominator_start: c_int, numerator_end: c_int, denominator_end: c_int);
    pub fn gst_value_set_int64_range(value: *mut gobject::GValue, start: i64, end: i64);
    pub fn gst_value_set_int64_range_step(value: *mut gobject::GValue, start: i64, end: i64, step: i64);
    pub fn gst_value_set_int_range(value: *mut gobject::GValue, start: c_int, end: c_int);
    pub fn gst_value_set_int_range_step(value: *mut gobject::GValue, start: c_int, end: c_int, step: c_int);
    pub fn gst_value_set_structure(value: *mut gobject::GValue, structure: *const GstStructure);
    pub fn gst_value_subtract(dest: *mut gobject::GValue, minuend: *const gobject::GValue, subtrahend: *const gobject::GValue) -> gboolean;
    pub fn gst_value_union(dest: *mut gobject::GValue, value1: *const gobject::GValue, value2: *const gobject::GValue) -> gboolean;
    pub fn gst_version(major: *mut c_uint, minor: *mut c_uint, micro: *mut c_uint, nano: *mut c_uint);
    pub fn gst_version_string() -> *mut c_char;

}
