// This file was generated by gir (bf7bd49) from gir-files (???)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals)]

extern crate libc;
#[macro_use] extern crate bitflags;
extern crate glib_sys as glib;
extern crate gobject_sys as gobject;
extern crate gstreamer_sys as gst;
extern crate gstreamer_base_sys as gst_base;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType, Volatile};

// Enums
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstColorBalanceType {
    Hardware = 0,
    Software = 1,
}
pub const GST_COLOR_BALANCE_HARDWARE: GstColorBalanceType = GstColorBalanceType::Hardware;
pub const GST_COLOR_BALANCE_SOFTWARE: GstColorBalanceType = GstColorBalanceType::Software;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstNavigationCommand {
    Invalid = 0,
    Menu1 = 1,
    Menu2 = 2,
    Menu3 = 3,
    Menu4 = 4,
    Menu5 = 5,
    Menu6 = 6,
    Menu7 = 7,
    Left = 20,
    Right = 21,
    Up = 22,
    Down = 23,
    Activate = 24,
    PrevAngle = 30,
    NextAngle = 31,
}
pub const GST_NAVIGATION_COMMAND_INVALID: GstNavigationCommand = GstNavigationCommand::Invalid;
pub const GST_NAVIGATION_COMMAND_MENU1: GstNavigationCommand = GstNavigationCommand::Menu1;
pub const GST_NAVIGATION_COMMAND_MENU2: GstNavigationCommand = GstNavigationCommand::Menu2;
pub const GST_NAVIGATION_COMMAND_MENU3: GstNavigationCommand = GstNavigationCommand::Menu3;
pub const GST_NAVIGATION_COMMAND_MENU4: GstNavigationCommand = GstNavigationCommand::Menu4;
pub const GST_NAVIGATION_COMMAND_MENU5: GstNavigationCommand = GstNavigationCommand::Menu5;
pub const GST_NAVIGATION_COMMAND_MENU6: GstNavigationCommand = GstNavigationCommand::Menu6;
pub const GST_NAVIGATION_COMMAND_MENU7: GstNavigationCommand = GstNavigationCommand::Menu7;
pub const GST_NAVIGATION_COMMAND_LEFT: GstNavigationCommand = GstNavigationCommand::Left;
pub const GST_NAVIGATION_COMMAND_RIGHT: GstNavigationCommand = GstNavigationCommand::Right;
pub const GST_NAVIGATION_COMMAND_UP: GstNavigationCommand = GstNavigationCommand::Up;
pub const GST_NAVIGATION_COMMAND_DOWN: GstNavigationCommand = GstNavigationCommand::Down;
pub const GST_NAVIGATION_COMMAND_ACTIVATE: GstNavigationCommand = GstNavigationCommand::Activate;
pub const GST_NAVIGATION_COMMAND_PREV_ANGLE: GstNavigationCommand = GstNavigationCommand::PrevAngle;
pub const GST_NAVIGATION_COMMAND_NEXT_ANGLE: GstNavigationCommand = GstNavigationCommand::NextAngle;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstNavigationEventType {
    Invalid = 0,
    KeyPress = 1,
    KeyRelease = 2,
    MouseButtonPress = 3,
    MouseButtonRelease = 4,
    MouseMove = 5,
    Command = 6,
}
pub const GST_NAVIGATION_EVENT_INVALID: GstNavigationEventType = GstNavigationEventType::Invalid;
pub const GST_NAVIGATION_EVENT_KEY_PRESS: GstNavigationEventType = GstNavigationEventType::KeyPress;
pub const GST_NAVIGATION_EVENT_KEY_RELEASE: GstNavigationEventType = GstNavigationEventType::KeyRelease;
pub const GST_NAVIGATION_EVENT_MOUSE_BUTTON_PRESS: GstNavigationEventType = GstNavigationEventType::MouseButtonPress;
pub const GST_NAVIGATION_EVENT_MOUSE_BUTTON_RELEASE: GstNavigationEventType = GstNavigationEventType::MouseButtonRelease;
pub const GST_NAVIGATION_EVENT_MOUSE_MOVE: GstNavigationEventType = GstNavigationEventType::MouseMove;
pub const GST_NAVIGATION_EVENT_COMMAND: GstNavigationEventType = GstNavigationEventType::Command;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstNavigationMessageType {
    Invalid = 0,
    MouseOver = 1,
    CommandsChanged = 2,
    AnglesChanged = 3,
    Event = 4,
}
pub const GST_NAVIGATION_MESSAGE_INVALID: GstNavigationMessageType = GstNavigationMessageType::Invalid;
pub const GST_NAVIGATION_MESSAGE_MOUSE_OVER: GstNavigationMessageType = GstNavigationMessageType::MouseOver;
pub const GST_NAVIGATION_MESSAGE_COMMANDS_CHANGED: GstNavigationMessageType = GstNavigationMessageType::CommandsChanged;
pub const GST_NAVIGATION_MESSAGE_ANGLES_CHANGED: GstNavigationMessageType = GstNavigationMessageType::AnglesChanged;
pub const GST_NAVIGATION_MESSAGE_EVENT: GstNavigationMessageType = GstNavigationMessageType::Event;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstNavigationQueryType {
    Invalid = 0,
    Commands = 1,
    Angles = 2,
}
pub const GST_NAVIGATION_QUERY_INVALID: GstNavigationQueryType = GstNavigationQueryType::Invalid;
pub const GST_NAVIGATION_QUERY_COMMANDS: GstNavigationQueryType = GstNavigationQueryType::Commands;
pub const GST_NAVIGATION_QUERY_ANGLES: GstNavigationQueryType = GstNavigationQueryType::Angles;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoAlphaMode {
    Copy = 0,
    Set = 1,
    Mult = 2,
}
pub const GST_VIDEO_ALPHA_MODE_COPY: GstVideoAlphaMode = GstVideoAlphaMode::Copy;
pub const GST_VIDEO_ALPHA_MODE_SET: GstVideoAlphaMode = GstVideoAlphaMode::Set;
pub const GST_VIDEO_ALPHA_MODE_MULT: GstVideoAlphaMode = GstVideoAlphaMode::Mult;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoChromaMethod {
    Nearest = 0,
    Linear = 1,
}
pub const GST_VIDEO_CHROMA_METHOD_NEAREST: GstVideoChromaMethod = GstVideoChromaMethod::Nearest;
pub const GST_VIDEO_CHROMA_METHOD_LINEAR: GstVideoChromaMethod = GstVideoChromaMethod::Linear;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoChromaMode {
    Full = 0,
    UpsampleOnly = 1,
    DownsampleOnly = 2,
    None = 3,
}
pub const GST_VIDEO_CHROMA_MODE_FULL: GstVideoChromaMode = GstVideoChromaMode::Full;
pub const GST_VIDEO_CHROMA_MODE_UPSAMPLE_ONLY: GstVideoChromaMode = GstVideoChromaMode::UpsampleOnly;
pub const GST_VIDEO_CHROMA_MODE_DOWNSAMPLE_ONLY: GstVideoChromaMode = GstVideoChromaMode::DownsampleOnly;
pub const GST_VIDEO_CHROMA_MODE_NONE: GstVideoChromaMode = GstVideoChromaMode::None;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoColorMatrix {
    Unknown = 0,
    Rgb = 1,
    Fcc = 2,
    Bt709 = 3,
    Bt601 = 4,
    Smpte240m = 5,
    Bt2020 = 6,
}
pub const GST_VIDEO_COLOR_MATRIX_UNKNOWN: GstVideoColorMatrix = GstVideoColorMatrix::Unknown;
pub const GST_VIDEO_COLOR_MATRIX_RGB: GstVideoColorMatrix = GstVideoColorMatrix::Rgb;
pub const GST_VIDEO_COLOR_MATRIX_FCC: GstVideoColorMatrix = GstVideoColorMatrix::Fcc;
pub const GST_VIDEO_COLOR_MATRIX_BT709: GstVideoColorMatrix = GstVideoColorMatrix::Bt709;
pub const GST_VIDEO_COLOR_MATRIX_BT601: GstVideoColorMatrix = GstVideoColorMatrix::Bt601;
pub const GST_VIDEO_COLOR_MATRIX_SMPTE240M: GstVideoColorMatrix = GstVideoColorMatrix::Smpte240m;
pub const GST_VIDEO_COLOR_MATRIX_BT2020: GstVideoColorMatrix = GstVideoColorMatrix::Bt2020;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoColorPrimaries {
    Unknown = 0,
    Bt709 = 1,
    Bt470m = 2,
    Bt470bg = 3,
    Smpte170m = 4,
    Smpte240m = 5,
    Film = 6,
    Bt2020 = 7,
    Adobergb = 8,
}
pub const GST_VIDEO_COLOR_PRIMARIES_UNKNOWN: GstVideoColorPrimaries = GstVideoColorPrimaries::Unknown;
pub const GST_VIDEO_COLOR_PRIMARIES_BT709: GstVideoColorPrimaries = GstVideoColorPrimaries::Bt709;
pub const GST_VIDEO_COLOR_PRIMARIES_BT470M: GstVideoColorPrimaries = GstVideoColorPrimaries::Bt470m;
pub const GST_VIDEO_COLOR_PRIMARIES_BT470BG: GstVideoColorPrimaries = GstVideoColorPrimaries::Bt470bg;
pub const GST_VIDEO_COLOR_PRIMARIES_SMPTE170M: GstVideoColorPrimaries = GstVideoColorPrimaries::Smpte170m;
pub const GST_VIDEO_COLOR_PRIMARIES_SMPTE240M: GstVideoColorPrimaries = GstVideoColorPrimaries::Smpte240m;
pub const GST_VIDEO_COLOR_PRIMARIES_FILM: GstVideoColorPrimaries = GstVideoColorPrimaries::Film;
pub const GST_VIDEO_COLOR_PRIMARIES_BT2020: GstVideoColorPrimaries = GstVideoColorPrimaries::Bt2020;
pub const GST_VIDEO_COLOR_PRIMARIES_ADOBERGB: GstVideoColorPrimaries = GstVideoColorPrimaries::Adobergb;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoColorRange {
    Unknown = 0,
    _0255 = 1,
    _16235 = 2,
}
pub const GST_VIDEO_COLOR_RANGE_UNKNOWN: GstVideoColorRange = GstVideoColorRange::Unknown;
pub const GST_VIDEO_COLOR_RANGE_0_255: GstVideoColorRange = GstVideoColorRange::_0255;
pub const GST_VIDEO_COLOR_RANGE_16_235: GstVideoColorRange = GstVideoColorRange::_16235;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoDitherMethod {
    None = 0,
    Verterr = 1,
    FloydSteinberg = 2,
    SierraLite = 3,
    Bayer = 4,
}
pub const GST_VIDEO_DITHER_NONE: GstVideoDitherMethod = GstVideoDitherMethod::None;
pub const GST_VIDEO_DITHER_VERTERR: GstVideoDitherMethod = GstVideoDitherMethod::Verterr;
pub const GST_VIDEO_DITHER_FLOYD_STEINBERG: GstVideoDitherMethod = GstVideoDitherMethod::FloydSteinberg;
pub const GST_VIDEO_DITHER_SIERRA_LITE: GstVideoDitherMethod = GstVideoDitherMethod::SierraLite;
pub const GST_VIDEO_DITHER_BAYER: GstVideoDitherMethod = GstVideoDitherMethod::Bayer;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoFieldOrder {
    Unknown = 0,
    TopFieldFirst = 1,
    BottomFieldFirst = 2,
}
pub const GST_VIDEO_FIELD_ORDER_UNKNOWN: GstVideoFieldOrder = GstVideoFieldOrder::Unknown;
pub const GST_VIDEO_FIELD_ORDER_TOP_FIELD_FIRST: GstVideoFieldOrder = GstVideoFieldOrder::TopFieldFirst;
pub const GST_VIDEO_FIELD_ORDER_BOTTOM_FIELD_FIRST: GstVideoFieldOrder = GstVideoFieldOrder::BottomFieldFirst;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoFormat {
    Unknown = 0,
    Encoded = 1,
    I420 = 2,
    Yv12 = 3,
    Yuy2 = 4,
    Uyvy = 5,
    Ayuv = 6,
    Rgbx = 7,
    Bgrx = 8,
    Xrgb = 9,
    Xbgr = 10,
    Rgba = 11,
    Bgra = 12,
    Argb = 13,
    Abgr = 14,
    Rgb = 15,
    Bgr = 16,
    Y41b = 17,
    Y42b = 18,
    Yvyu = 19,
    Y444 = 20,
    V210 = 21,
    V216 = 22,
    Nv12 = 23,
    Nv21 = 24,
    Gray8 = 25,
    Gray16Be = 26,
    Gray16Le = 27,
    V308 = 28,
    Rgb16 = 29,
    Bgr16 = 30,
    Rgb15 = 31,
    Bgr15 = 32,
    Uyvp = 33,
    A420 = 34,
    Rgb8p = 35,
    Yuv9 = 36,
    Yvu9 = 37,
    Iyu1 = 38,
    Argb64 = 39,
    Ayuv64 = 40,
    R210 = 41,
    I42010be = 42,
    I42010le = 43,
    I42210be = 44,
    I42210le = 45,
    Y44410be = 46,
    Y44410le = 47,
    Gbr = 48,
    Gbr10be = 49,
    Gbr10le = 50,
    Nv16 = 51,
    Nv24 = 52,
    Nv1264z32 = 53,
    A42010be = 54,
    A42010le = 55,
    A42210be = 56,
    A42210le = 57,
    A44410be = 58,
    A44410le = 59,
    Nv61 = 60,
    P01010be = 61,
    P01010le = 62,
    Iyu2 = 63,
    Vyuy = 64,
    Gbra = 65,
    Gbra10be = 66,
    Gbra10le = 67,
    Gbr12be = 68,
    Gbr12le = 69,
    Gbra12be = 70,
    Gbra12le = 71,
    I42012be = 72,
    I42012le = 73,
    I42212be = 74,
    I42212le = 75,
    Y44412be = 76,
    Y44412le = 77,
}
pub const GST_VIDEO_FORMAT_UNKNOWN: GstVideoFormat = GstVideoFormat::Unknown;
pub const GST_VIDEO_FORMAT_ENCODED: GstVideoFormat = GstVideoFormat::Encoded;
pub const GST_VIDEO_FORMAT_I420: GstVideoFormat = GstVideoFormat::I420;
pub const GST_VIDEO_FORMAT_YV12: GstVideoFormat = GstVideoFormat::Yv12;
pub const GST_VIDEO_FORMAT_YUY2: GstVideoFormat = GstVideoFormat::Yuy2;
pub const GST_VIDEO_FORMAT_UYVY: GstVideoFormat = GstVideoFormat::Uyvy;
pub const GST_VIDEO_FORMAT_AYUV: GstVideoFormat = GstVideoFormat::Ayuv;
pub const GST_VIDEO_FORMAT_RGBx: GstVideoFormat = GstVideoFormat::Rgbx;
pub const GST_VIDEO_FORMAT_BGRx: GstVideoFormat = GstVideoFormat::Bgrx;
pub const GST_VIDEO_FORMAT_xRGB: GstVideoFormat = GstVideoFormat::Xrgb;
pub const GST_VIDEO_FORMAT_xBGR: GstVideoFormat = GstVideoFormat::Xbgr;
pub const GST_VIDEO_FORMAT_RGBA: GstVideoFormat = GstVideoFormat::Rgba;
pub const GST_VIDEO_FORMAT_BGRA: GstVideoFormat = GstVideoFormat::Bgra;
pub const GST_VIDEO_FORMAT_ARGB: GstVideoFormat = GstVideoFormat::Argb;
pub const GST_VIDEO_FORMAT_ABGR: GstVideoFormat = GstVideoFormat::Abgr;
pub const GST_VIDEO_FORMAT_RGB: GstVideoFormat = GstVideoFormat::Rgb;
pub const GST_VIDEO_FORMAT_BGR: GstVideoFormat = GstVideoFormat::Bgr;
pub const GST_VIDEO_FORMAT_Y41B: GstVideoFormat = GstVideoFormat::Y41b;
pub const GST_VIDEO_FORMAT_Y42B: GstVideoFormat = GstVideoFormat::Y42b;
pub const GST_VIDEO_FORMAT_YVYU: GstVideoFormat = GstVideoFormat::Yvyu;
pub const GST_VIDEO_FORMAT_Y444: GstVideoFormat = GstVideoFormat::Y444;
pub const GST_VIDEO_FORMAT_v210: GstVideoFormat = GstVideoFormat::V210;
pub const GST_VIDEO_FORMAT_v216: GstVideoFormat = GstVideoFormat::V216;
pub const GST_VIDEO_FORMAT_NV12: GstVideoFormat = GstVideoFormat::Nv12;
pub const GST_VIDEO_FORMAT_NV21: GstVideoFormat = GstVideoFormat::Nv21;
pub const GST_VIDEO_FORMAT_GRAY8: GstVideoFormat = GstVideoFormat::Gray8;
pub const GST_VIDEO_FORMAT_GRAY16_BE: GstVideoFormat = GstVideoFormat::Gray16Be;
pub const GST_VIDEO_FORMAT_GRAY16_LE: GstVideoFormat = GstVideoFormat::Gray16Le;
pub const GST_VIDEO_FORMAT_v308: GstVideoFormat = GstVideoFormat::V308;
pub const GST_VIDEO_FORMAT_RGB16: GstVideoFormat = GstVideoFormat::Rgb16;
pub const GST_VIDEO_FORMAT_BGR16: GstVideoFormat = GstVideoFormat::Bgr16;
pub const GST_VIDEO_FORMAT_RGB15: GstVideoFormat = GstVideoFormat::Rgb15;
pub const GST_VIDEO_FORMAT_BGR15: GstVideoFormat = GstVideoFormat::Bgr15;
pub const GST_VIDEO_FORMAT_UYVP: GstVideoFormat = GstVideoFormat::Uyvp;
pub const GST_VIDEO_FORMAT_A420: GstVideoFormat = GstVideoFormat::A420;
pub const GST_VIDEO_FORMAT_RGB8P: GstVideoFormat = GstVideoFormat::Rgb8p;
pub const GST_VIDEO_FORMAT_YUV9: GstVideoFormat = GstVideoFormat::Yuv9;
pub const GST_VIDEO_FORMAT_YVU9: GstVideoFormat = GstVideoFormat::Yvu9;
pub const GST_VIDEO_FORMAT_IYU1: GstVideoFormat = GstVideoFormat::Iyu1;
pub const GST_VIDEO_FORMAT_ARGB64: GstVideoFormat = GstVideoFormat::Argb64;
pub const GST_VIDEO_FORMAT_AYUV64: GstVideoFormat = GstVideoFormat::Ayuv64;
pub const GST_VIDEO_FORMAT_r210: GstVideoFormat = GstVideoFormat::R210;
pub const GST_VIDEO_FORMAT_I420_10BE: GstVideoFormat = GstVideoFormat::I42010be;
pub const GST_VIDEO_FORMAT_I420_10LE: GstVideoFormat = GstVideoFormat::I42010le;
pub const GST_VIDEO_FORMAT_I422_10BE: GstVideoFormat = GstVideoFormat::I42210be;
pub const GST_VIDEO_FORMAT_I422_10LE: GstVideoFormat = GstVideoFormat::I42210le;
pub const GST_VIDEO_FORMAT_Y444_10BE: GstVideoFormat = GstVideoFormat::Y44410be;
pub const GST_VIDEO_FORMAT_Y444_10LE: GstVideoFormat = GstVideoFormat::Y44410le;
pub const GST_VIDEO_FORMAT_GBR: GstVideoFormat = GstVideoFormat::Gbr;
pub const GST_VIDEO_FORMAT_GBR_10BE: GstVideoFormat = GstVideoFormat::Gbr10be;
pub const GST_VIDEO_FORMAT_GBR_10LE: GstVideoFormat = GstVideoFormat::Gbr10le;
pub const GST_VIDEO_FORMAT_NV16: GstVideoFormat = GstVideoFormat::Nv16;
pub const GST_VIDEO_FORMAT_NV24: GstVideoFormat = GstVideoFormat::Nv24;
pub const GST_VIDEO_FORMAT_NV12_64Z32: GstVideoFormat = GstVideoFormat::Nv1264z32;
pub const GST_VIDEO_FORMAT_A420_10BE: GstVideoFormat = GstVideoFormat::A42010be;
pub const GST_VIDEO_FORMAT_A420_10LE: GstVideoFormat = GstVideoFormat::A42010le;
pub const GST_VIDEO_FORMAT_A422_10BE: GstVideoFormat = GstVideoFormat::A42210be;
pub const GST_VIDEO_FORMAT_A422_10LE: GstVideoFormat = GstVideoFormat::A42210le;
pub const GST_VIDEO_FORMAT_A444_10BE: GstVideoFormat = GstVideoFormat::A44410be;
pub const GST_VIDEO_FORMAT_A444_10LE: GstVideoFormat = GstVideoFormat::A44410le;
pub const GST_VIDEO_FORMAT_NV61: GstVideoFormat = GstVideoFormat::Nv61;
pub const GST_VIDEO_FORMAT_P010_10BE: GstVideoFormat = GstVideoFormat::P01010be;
pub const GST_VIDEO_FORMAT_P010_10LE: GstVideoFormat = GstVideoFormat::P01010le;
pub const GST_VIDEO_FORMAT_IYU2: GstVideoFormat = GstVideoFormat::Iyu2;
pub const GST_VIDEO_FORMAT_VYUY: GstVideoFormat = GstVideoFormat::Vyuy;
pub const GST_VIDEO_FORMAT_GBRA: GstVideoFormat = GstVideoFormat::Gbra;
pub const GST_VIDEO_FORMAT_GBRA_10BE: GstVideoFormat = GstVideoFormat::Gbra10be;
pub const GST_VIDEO_FORMAT_GBRA_10LE: GstVideoFormat = GstVideoFormat::Gbra10le;
pub const GST_VIDEO_FORMAT_GBR_12BE: GstVideoFormat = GstVideoFormat::Gbr12be;
pub const GST_VIDEO_FORMAT_GBR_12LE: GstVideoFormat = GstVideoFormat::Gbr12le;
pub const GST_VIDEO_FORMAT_GBRA_12BE: GstVideoFormat = GstVideoFormat::Gbra12be;
pub const GST_VIDEO_FORMAT_GBRA_12LE: GstVideoFormat = GstVideoFormat::Gbra12le;
pub const GST_VIDEO_FORMAT_I420_12BE: GstVideoFormat = GstVideoFormat::I42012be;
pub const GST_VIDEO_FORMAT_I420_12LE: GstVideoFormat = GstVideoFormat::I42012le;
pub const GST_VIDEO_FORMAT_I422_12BE: GstVideoFormat = GstVideoFormat::I42212be;
pub const GST_VIDEO_FORMAT_I422_12LE: GstVideoFormat = GstVideoFormat::I42212le;
pub const GST_VIDEO_FORMAT_Y444_12BE: GstVideoFormat = GstVideoFormat::Y44412be;
pub const GST_VIDEO_FORMAT_Y444_12LE: GstVideoFormat = GstVideoFormat::Y44412le;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoGLTextureOrientation {
    NormalYNormal = 0,
    NormalYFlip = 1,
    FlipYNormal = 2,
    FlipYFlip = 3,
}
pub const GST_VIDEO_GL_TEXTURE_ORIENTATION_X_NORMAL_Y_NORMAL: GstVideoGLTextureOrientation = GstVideoGLTextureOrientation::NormalYNormal;
pub const GST_VIDEO_GL_TEXTURE_ORIENTATION_X_NORMAL_Y_FLIP: GstVideoGLTextureOrientation = GstVideoGLTextureOrientation::NormalYFlip;
pub const GST_VIDEO_GL_TEXTURE_ORIENTATION_X_FLIP_Y_NORMAL: GstVideoGLTextureOrientation = GstVideoGLTextureOrientation::FlipYNormal;
pub const GST_VIDEO_GL_TEXTURE_ORIENTATION_X_FLIP_Y_FLIP: GstVideoGLTextureOrientation = GstVideoGLTextureOrientation::FlipYFlip;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoGLTextureType {
    Luminance = 0,
    LuminanceAlpha = 1,
    Rgb16 = 2,
    Rgb = 3,
    Rgba = 4,
    R = 5,
    Rg = 6,
}
pub const GST_VIDEO_GL_TEXTURE_TYPE_LUMINANCE: GstVideoGLTextureType = GstVideoGLTextureType::Luminance;
pub const GST_VIDEO_GL_TEXTURE_TYPE_LUMINANCE_ALPHA: GstVideoGLTextureType = GstVideoGLTextureType::LuminanceAlpha;
pub const GST_VIDEO_GL_TEXTURE_TYPE_RGB16: GstVideoGLTextureType = GstVideoGLTextureType::Rgb16;
pub const GST_VIDEO_GL_TEXTURE_TYPE_RGB: GstVideoGLTextureType = GstVideoGLTextureType::Rgb;
pub const GST_VIDEO_GL_TEXTURE_TYPE_RGBA: GstVideoGLTextureType = GstVideoGLTextureType::Rgba;
pub const GST_VIDEO_GL_TEXTURE_TYPE_R: GstVideoGLTextureType = GstVideoGLTextureType::R;
pub const GST_VIDEO_GL_TEXTURE_TYPE_RG: GstVideoGLTextureType = GstVideoGLTextureType::Rg;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoGammaMode {
    None = 0,
    Remap = 1,
}
pub const GST_VIDEO_GAMMA_MODE_NONE: GstVideoGammaMode = GstVideoGammaMode::None;
pub const GST_VIDEO_GAMMA_MODE_REMAP: GstVideoGammaMode = GstVideoGammaMode::Remap;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoInterlaceMode {
    Progressive = 0,
    Interleaved = 1,
    Mixed = 2,
    Fields = 3,
}
pub const GST_VIDEO_INTERLACE_MODE_PROGRESSIVE: GstVideoInterlaceMode = GstVideoInterlaceMode::Progressive;
pub const GST_VIDEO_INTERLACE_MODE_INTERLEAVED: GstVideoInterlaceMode = GstVideoInterlaceMode::Interleaved;
pub const GST_VIDEO_INTERLACE_MODE_MIXED: GstVideoInterlaceMode = GstVideoInterlaceMode::Mixed;
pub const GST_VIDEO_INTERLACE_MODE_FIELDS: GstVideoInterlaceMode = GstVideoInterlaceMode::Fields;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoMatrixMode {
    Full = 0,
    InputOnly = 1,
    OutputOnly = 2,
    None = 3,
}
pub const GST_VIDEO_MATRIX_MODE_FULL: GstVideoMatrixMode = GstVideoMatrixMode::Full;
pub const GST_VIDEO_MATRIX_MODE_INPUT_ONLY: GstVideoMatrixMode = GstVideoMatrixMode::InputOnly;
pub const GST_VIDEO_MATRIX_MODE_OUTPUT_ONLY: GstVideoMatrixMode = GstVideoMatrixMode::OutputOnly;
pub const GST_VIDEO_MATRIX_MODE_NONE: GstVideoMatrixMode = GstVideoMatrixMode::None;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoMultiviewFramePacking {
    None = -1,
    Mono = 0,
    Left = 1,
    Right = 2,
    SideBySide = 3,
    SideBySideQuincunx = 4,
    ColumnInterleaved = 5,
    RowInterleaved = 6,
    TopBottom = 7,
    Checkerboard = 8,
}
pub const GST_VIDEO_MULTIVIEW_FRAME_PACKING_NONE: GstVideoMultiviewFramePacking = GstVideoMultiviewFramePacking::None;
pub const GST_VIDEO_MULTIVIEW_FRAME_PACKING_MONO: GstVideoMultiviewFramePacking = GstVideoMultiviewFramePacking::Mono;
pub const GST_VIDEO_MULTIVIEW_FRAME_PACKING_LEFT: GstVideoMultiviewFramePacking = GstVideoMultiviewFramePacking::Left;
pub const GST_VIDEO_MULTIVIEW_FRAME_PACKING_RIGHT: GstVideoMultiviewFramePacking = GstVideoMultiviewFramePacking::Right;
pub const GST_VIDEO_MULTIVIEW_FRAME_PACKING_SIDE_BY_SIDE: GstVideoMultiviewFramePacking = GstVideoMultiviewFramePacking::SideBySide;
pub const GST_VIDEO_MULTIVIEW_FRAME_PACKING_SIDE_BY_SIDE_QUINCUNX: GstVideoMultiviewFramePacking = GstVideoMultiviewFramePacking::SideBySideQuincunx;
pub const GST_VIDEO_MULTIVIEW_FRAME_PACKING_COLUMN_INTERLEAVED: GstVideoMultiviewFramePacking = GstVideoMultiviewFramePacking::ColumnInterleaved;
pub const GST_VIDEO_MULTIVIEW_FRAME_PACKING_ROW_INTERLEAVED: GstVideoMultiviewFramePacking = GstVideoMultiviewFramePacking::RowInterleaved;
pub const GST_VIDEO_MULTIVIEW_FRAME_PACKING_TOP_BOTTOM: GstVideoMultiviewFramePacking = GstVideoMultiviewFramePacking::TopBottom;
pub const GST_VIDEO_MULTIVIEW_FRAME_PACKING_CHECKERBOARD: GstVideoMultiviewFramePacking = GstVideoMultiviewFramePacking::Checkerboard;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoMultiviewMode {
    None = -1,
    Mono = 0,
    Left = 1,
    Right = 2,
    SideBySide = 3,
    SideBySideQuincunx = 4,
    ColumnInterleaved = 5,
    RowInterleaved = 6,
    TopBottom = 7,
    Checkerboard = 8,
    FrameByFrame = 32,
    MultiviewFrameByFrame = 33,
    Separated = 34,
}
pub const GST_VIDEO_MULTIVIEW_MODE_NONE: GstVideoMultiviewMode = GstVideoMultiviewMode::None;
pub const GST_VIDEO_MULTIVIEW_MODE_MONO: GstVideoMultiviewMode = GstVideoMultiviewMode::Mono;
pub const GST_VIDEO_MULTIVIEW_MODE_LEFT: GstVideoMultiviewMode = GstVideoMultiviewMode::Left;
pub const GST_VIDEO_MULTIVIEW_MODE_RIGHT: GstVideoMultiviewMode = GstVideoMultiviewMode::Right;
pub const GST_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE: GstVideoMultiviewMode = GstVideoMultiviewMode::SideBySide;
pub const GST_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE_QUINCUNX: GstVideoMultiviewMode = GstVideoMultiviewMode::SideBySideQuincunx;
pub const GST_VIDEO_MULTIVIEW_MODE_COLUMN_INTERLEAVED: GstVideoMultiviewMode = GstVideoMultiviewMode::ColumnInterleaved;
pub const GST_VIDEO_MULTIVIEW_MODE_ROW_INTERLEAVED: GstVideoMultiviewMode = GstVideoMultiviewMode::RowInterleaved;
pub const GST_VIDEO_MULTIVIEW_MODE_TOP_BOTTOM: GstVideoMultiviewMode = GstVideoMultiviewMode::TopBottom;
pub const GST_VIDEO_MULTIVIEW_MODE_CHECKERBOARD: GstVideoMultiviewMode = GstVideoMultiviewMode::Checkerboard;
pub const GST_VIDEO_MULTIVIEW_MODE_FRAME_BY_FRAME: GstVideoMultiviewMode = GstVideoMultiviewMode::FrameByFrame;
pub const GST_VIDEO_MULTIVIEW_MODE_MULTIVIEW_FRAME_BY_FRAME: GstVideoMultiviewMode = GstVideoMultiviewMode::MultiviewFrameByFrame;
pub const GST_VIDEO_MULTIVIEW_MODE_SEPARATED: GstVideoMultiviewMode = GstVideoMultiviewMode::Separated;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoOrientationMethod {
    Identity = 0,
    _90r = 1,
    _180 = 2,
    _90l = 3,
    Horiz = 4,
    Vert = 5,
    UlLr = 6,
    UrLl = 7,
    Auto = 8,
    Custom = 9,
}
pub const GST_VIDEO_ORIENTATION_IDENTITY: GstVideoOrientationMethod = GstVideoOrientationMethod::Identity;
pub const GST_VIDEO_ORIENTATION_90R: GstVideoOrientationMethod = GstVideoOrientationMethod::_90r;
pub const GST_VIDEO_ORIENTATION_180: GstVideoOrientationMethod = GstVideoOrientationMethod::_180;
pub const GST_VIDEO_ORIENTATION_90L: GstVideoOrientationMethod = GstVideoOrientationMethod::_90l;
pub const GST_VIDEO_ORIENTATION_HORIZ: GstVideoOrientationMethod = GstVideoOrientationMethod::Horiz;
pub const GST_VIDEO_ORIENTATION_VERT: GstVideoOrientationMethod = GstVideoOrientationMethod::Vert;
pub const GST_VIDEO_ORIENTATION_UL_LR: GstVideoOrientationMethod = GstVideoOrientationMethod::UlLr;
pub const GST_VIDEO_ORIENTATION_UR_LL: GstVideoOrientationMethod = GstVideoOrientationMethod::UrLl;
pub const GST_VIDEO_ORIENTATION_AUTO: GstVideoOrientationMethod = GstVideoOrientationMethod::Auto;
pub const GST_VIDEO_ORIENTATION_CUSTOM: GstVideoOrientationMethod = GstVideoOrientationMethod::Custom;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoOverlayFormatFlags {
    None = 0,
    PremultipliedAlpha = 1,
    GlobalAlpha = 2,
}
pub const GST_VIDEO_OVERLAY_FORMAT_FLAG_NONE: GstVideoOverlayFormatFlags = GstVideoOverlayFormatFlags::None;
pub const GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA: GstVideoOverlayFormatFlags = GstVideoOverlayFormatFlags::PremultipliedAlpha;
pub const GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA: GstVideoOverlayFormatFlags = GstVideoOverlayFormatFlags::GlobalAlpha;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoPrimariesMode {
    None = 0,
    MergeOnly = 1,
    Fast = 2,
}
pub const GST_VIDEO_PRIMARIES_MODE_NONE: GstVideoPrimariesMode = GstVideoPrimariesMode::None;
pub const GST_VIDEO_PRIMARIES_MODE_MERGE_ONLY: GstVideoPrimariesMode = GstVideoPrimariesMode::MergeOnly;
pub const GST_VIDEO_PRIMARIES_MODE_FAST: GstVideoPrimariesMode = GstVideoPrimariesMode::Fast;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoResamplerMethod {
    Nearest = 0,
    Linear = 1,
    Cubic = 2,
    Sinc = 3,
    Lanczos = 4,
}
pub const GST_VIDEO_RESAMPLER_METHOD_NEAREST: GstVideoResamplerMethod = GstVideoResamplerMethod::Nearest;
pub const GST_VIDEO_RESAMPLER_METHOD_LINEAR: GstVideoResamplerMethod = GstVideoResamplerMethod::Linear;
pub const GST_VIDEO_RESAMPLER_METHOD_CUBIC: GstVideoResamplerMethod = GstVideoResamplerMethod::Cubic;
pub const GST_VIDEO_RESAMPLER_METHOD_SINC: GstVideoResamplerMethod = GstVideoResamplerMethod::Sinc;
pub const GST_VIDEO_RESAMPLER_METHOD_LANCZOS: GstVideoResamplerMethod = GstVideoResamplerMethod::Lanczos;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoTileMode {
    Unknown = 0,
    Zflipz2x2 = 65536,
}
pub const GST_VIDEO_TILE_MODE_UNKNOWN: GstVideoTileMode = GstVideoTileMode::Unknown;
pub const GST_VIDEO_TILE_MODE_ZFLIPZ_2X2: GstVideoTileMode = GstVideoTileMode::Zflipz2x2;

pub type VideoTileType = c_int;
pub const GST_VIDEO_TILE_TYPE_INDEXED: VideoTileType = 0;
pub type GstVideoTileType = VideoTileType;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstVideoTransferFunction {
    Unknown = 0,
    Gamma10 = 1,
    Gamma18 = 2,
    Gamma20 = 3,
    Gamma22 = 4,
    Bt709 = 5,
    Smpte240m = 6,
    Srgb = 7,
    Gamma28 = 8,
    Log100 = 9,
    Log316 = 10,
    Bt202012 = 11,
    Adobergb = 12,
}
pub const GST_VIDEO_TRANSFER_UNKNOWN: GstVideoTransferFunction = GstVideoTransferFunction::Unknown;
pub const GST_VIDEO_TRANSFER_GAMMA10: GstVideoTransferFunction = GstVideoTransferFunction::Gamma10;
pub const GST_VIDEO_TRANSFER_GAMMA18: GstVideoTransferFunction = GstVideoTransferFunction::Gamma18;
pub const GST_VIDEO_TRANSFER_GAMMA20: GstVideoTransferFunction = GstVideoTransferFunction::Gamma20;
pub const GST_VIDEO_TRANSFER_GAMMA22: GstVideoTransferFunction = GstVideoTransferFunction::Gamma22;
pub const GST_VIDEO_TRANSFER_BT709: GstVideoTransferFunction = GstVideoTransferFunction::Bt709;
pub const GST_VIDEO_TRANSFER_SMPTE240M: GstVideoTransferFunction = GstVideoTransferFunction::Smpte240m;
pub const GST_VIDEO_TRANSFER_SRGB: GstVideoTransferFunction = GstVideoTransferFunction::Srgb;
pub const GST_VIDEO_TRANSFER_GAMMA28: GstVideoTransferFunction = GstVideoTransferFunction::Gamma28;
pub const GST_VIDEO_TRANSFER_LOG100: GstVideoTransferFunction = GstVideoTransferFunction::Log100;
pub const GST_VIDEO_TRANSFER_LOG316: GstVideoTransferFunction = GstVideoTransferFunction::Log316;
pub const GST_VIDEO_TRANSFER_BT2020_12: GstVideoTransferFunction = GstVideoTransferFunction::Bt202012;
pub const GST_VIDEO_TRANSFER_ADOBERGB: GstVideoTransferFunction = GstVideoTransferFunction::Adobergb;

// Constants
pub const GST_BUFFER_POOL_OPTION_VIDEO_AFFINE_TRANSFORMATION_META: *const c_char = b"GstBufferPoolOptionVideoAffineTransformation\0" as *const u8 as *const c_char;
pub const GST_BUFFER_POOL_OPTION_VIDEO_ALIGNMENT: *const c_char = b"GstBufferPoolOptionVideoAlignment\0" as *const u8 as *const c_char;
pub const GST_BUFFER_POOL_OPTION_VIDEO_GL_TEXTURE_UPLOAD_META: *const c_char = b"GstBufferPoolOptionVideoGLTextureUploadMeta\0" as *const u8 as *const c_char;
pub const GST_BUFFER_POOL_OPTION_VIDEO_META: *const c_char = b"GstBufferPoolOptionVideoMeta\0" as *const u8 as *const c_char;
pub const GST_CAPS_FEATURE_META_GST_VIDEO_AFFINE_TRANSFORMATION_META: *const c_char = b"meta:GstVideoAffineTransformation\0" as *const u8 as *const c_char;
pub const GST_CAPS_FEATURE_META_GST_VIDEO_GL_TEXTURE_UPLOAD_META: *const c_char = b"meta:GstVideoGLTextureUploadMeta\0" as *const u8 as *const c_char;
pub const GST_CAPS_FEATURE_META_GST_VIDEO_META: *const c_char = b"meta:GstVideoMeta\0" as *const u8 as *const c_char;
pub const GST_CAPS_FEATURE_META_GST_VIDEO_OVERLAY_COMPOSITION: *const c_char = b"meta:GstVideoOverlayComposition\0" as *const u8 as *const c_char;
pub const GST_META_TAG_VIDEO_COLORSPACE_STR: *const c_char = b"colorspace\0" as *const u8 as *const c_char;
pub const GST_META_TAG_VIDEO_ORIENTATION_STR: *const c_char = b"orientation\0" as *const u8 as *const c_char;
pub const GST_META_TAG_VIDEO_SIZE_STR: *const c_char = b"size\0" as *const u8 as *const c_char;
pub const GST_META_TAG_VIDEO_STR: *const c_char = b"video\0" as *const u8 as *const c_char;
pub const GST_VIDEO_COLORIMETRY_BT2020: *const c_char = b"bt2020\0" as *const u8 as *const c_char;
pub const GST_VIDEO_COLORIMETRY_BT601: *const c_char = b"bt601\0" as *const u8 as *const c_char;
pub const GST_VIDEO_COLORIMETRY_BT709: *const c_char = b"bt709\0" as *const u8 as *const c_char;
pub const GST_VIDEO_COLORIMETRY_SMPTE240M: *const c_char = b"smpte240m\0" as *const u8 as *const c_char;
pub const GST_VIDEO_COLORIMETRY_SRGB: *const c_char = b"sRGB\0" as *const u8 as *const c_char;
pub const GST_VIDEO_COMP_A: c_int = 3;
pub const GST_VIDEO_COMP_B: c_int = 2;
pub const GST_VIDEO_COMP_G: c_int = 1;
pub const GST_VIDEO_COMP_INDEX: c_int = 0;
pub const GST_VIDEO_COMP_PALETTE: c_int = 1;
pub const GST_VIDEO_COMP_R: c_int = 0;
pub const GST_VIDEO_COMP_U: c_int = 1;
pub const GST_VIDEO_COMP_V: c_int = 2;
pub const GST_VIDEO_COMP_Y: c_int = 0;
pub const GST_VIDEO_CONVERTER_OPT_ALPHA_MODE: *const c_char = b"GstVideoConverter.alpha-mode\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_ALPHA_VALUE: *const c_char = b"GstVideoConverter.alpha-value\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_BORDER_ARGB: *const c_char = b"GstVideoConverter.border-argb\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_CHROMA_MODE: *const c_char = b"GstVideoConverter.chroma-mode\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_CHROMA_RESAMPLER_METHOD: *const c_char = b"GstVideoConverter.chroma-resampler-method\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_DEST_HEIGHT: *const c_char = b"GstVideoConverter.dest-height\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_DEST_WIDTH: *const c_char = b"GstVideoConverter.dest-width\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_DEST_X: *const c_char = b"GstVideoConverter.dest-x\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_DEST_Y: *const c_char = b"GstVideoConverter.dest-y\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_DITHER_METHOD: *const c_char = b"GstVideoConverter.dither-method\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_DITHER_QUANTIZATION: *const c_char = b"GstVideoConverter.dither-quantization\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_FILL_BORDER: *const c_char = b"GstVideoConverter.fill-border\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_GAMMA_MODE: *const c_char = b"GstVideoConverter.gamma-mode\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_MATRIX_MODE: *const c_char = b"GstVideoConverter.matrix-mode\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_PRIMARIES_MODE: *const c_char = b"GstVideoConverter.primaries-mode\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_RESAMPLER_METHOD: *const c_char = b"GstVideoConverter.resampler-method\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_RESAMPLER_TAPS: *const c_char = b"GstVideoConverter.resampler-taps\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_SRC_HEIGHT: *const c_char = b"GstVideoConverter.src-height\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_SRC_WIDTH: *const c_char = b"GstVideoConverter.src-width\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_SRC_X: *const c_char = b"GstVideoConverter.src-x\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_SRC_Y: *const c_char = b"GstVideoConverter.src-y\0" as *const u8 as *const c_char;
pub const GST_VIDEO_CONVERTER_OPT_THREADS: *const c_char = b"GstVideoConverter.threads\0" as *const u8 as *const c_char;
pub const GST_VIDEO_DECODER_MAX_ERRORS: c_int = 10;
pub const GST_VIDEO_DECODER_SINK_NAME: *const c_char = b"sink\0" as *const u8 as *const c_char;
pub const GST_VIDEO_DECODER_SRC_NAME: *const c_char = b"src\0" as *const u8 as *const c_char;
pub const GST_VIDEO_ENCODER_SINK_NAME: *const c_char = b"sink\0" as *const u8 as *const c_char;
pub const GST_VIDEO_ENCODER_SRC_NAME: *const c_char = b"src\0" as *const u8 as *const c_char;
pub const GST_VIDEO_FORMATS_ALL: *const c_char = b"{ I420, YV12, YUY2, UYVY, AYUV, RGBx, BGRx, xRGB, xBGR, RGBA, BGRA, ARGB, ABGR, RGB, BGR, Y41B, Y42B, YVYU, Y444, v210, v216, NV12, NV21, GRAY8, GRAY16_BE, GRAY16_LE, v308, RGB16, BGR16, RGB15, BGR15, UYVP, A420, RGB8P, YUV9, YVU9, IYU1, ARGB64, AYUV64, r210, I420_10BE, I420_10LE, I422_10BE, I422_10LE, Y444_10BE, Y444_10LE, GBR, GBR_10BE, GBR_10LE, NV16, NV24, NV12_64Z32, A420_10BE, A420_10LE, A422_10BE, A422_10LE, A444_10BE, A444_10LE, NV61, P010_10BE, P010_10LE, IYU2, VYUY, GBRA, GBRA_10BE, GBRA_10LE, GBR_12BE, GBR_12LE, GBRA_12BE, GBRA_12LE, I420_12BE, I420_12LE, I422_12BE, I422_12LE, Y444_12BE, Y444_12LE }\0" as *const u8 as *const c_char;
pub const GST_VIDEO_FPS_RANGE: *const c_char = b"(fraction) [ 0, max ]\0" as *const u8 as *const c_char;
pub const GST_VIDEO_MAX_COMPONENTS: c_int = 4;
pub const GST_VIDEO_MAX_PLANES: c_int = 4;
pub const GST_VIDEO_OVERLAY_COMPOSITION_BLEND_FORMATS: *const c_char = b"{ BGRx, RGBx, xRGB, xBGR, RGBA, BGRA, ARGB, ABGR, RGB, BGR, I420, YV12, AYUV, YUY2, UYVY, v308, Y41B, Y42B, Y444, NV12, NV21, A420, YUV9, YVU9, IYU1, GRAY8 }\0" as *const u8 as *const c_char;
pub const GST_VIDEO_RESAMPLER_OPT_CUBIC_B: *const c_char = b"GstVideoResampler.cubic-b\0" as *const u8 as *const c_char;
pub const GST_VIDEO_RESAMPLER_OPT_CUBIC_C: *const c_char = b"GstVideoResampler.cubic-c\0" as *const u8 as *const c_char;
pub const GST_VIDEO_RESAMPLER_OPT_ENVELOPE: *const c_char = b"GstVideoResampler.envelope\0" as *const u8 as *const c_char;
pub const GST_VIDEO_RESAMPLER_OPT_MAX_TAPS: *const c_char = b"GstVideoResampler.max-taps\0" as *const u8 as *const c_char;
pub const GST_VIDEO_RESAMPLER_OPT_SHARPEN: *const c_char = b"GstVideoResampler.sharpen\0" as *const u8 as *const c_char;
pub const GST_VIDEO_RESAMPLER_OPT_SHARPNESS: *const c_char = b"GstVideoResampler.sharpness\0" as *const u8 as *const c_char;
pub const GST_VIDEO_SCALER_OPT_DITHER_METHOD: *const c_char = b"GstVideoScaler.dither-method\0" as *const u8 as *const c_char;
pub const GST_VIDEO_SIZE_RANGE: *const c_char = b"(int) [ 1, max ]\0" as *const u8 as *const c_char;
pub const GST_VIDEO_TILE_TYPE_MASK: c_int = 0;
pub const GST_VIDEO_TILE_TYPE_SHIFT: c_int = 16;
pub const GST_VIDEO_TILE_X_TILES_MASK: c_int = 0;
pub const GST_VIDEO_TILE_Y_TILES_SHIFT: c_int = 16;

// Flags
bitflags! {
    #[repr(C)]
    pub flags GstVideoBufferFlags: c_uint {
        const GST_VIDEO_BUFFER_FLAG_INTERLACED = 1048576,
        const GST_VIDEO_BUFFER_FLAG_TFF = 2097152,
        const GST_VIDEO_BUFFER_FLAG_RFF = 4194304,
        const GST_VIDEO_BUFFER_FLAG_ONEFIELD = 8388608,
        const GST_VIDEO_BUFFER_FLAG_MULTIPLE_VIEW = 16777216,
        const GST_VIDEO_BUFFER_FLAG_FIRST_IN_BUNDLE = 33554432,
        const GST_VIDEO_BUFFER_FLAG_LAST = 268435456,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstVideoChromaFlags: c_uint {
        const GST_VIDEO_CHROMA_FLAG_NONE = 0,
        const GST_VIDEO_CHROMA_FLAG_INTERLACED = 1,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstVideoChromaSite: c_uint {
        const GST_VIDEO_CHROMA_SITE_UNKNOWN = 0,
        const GST_VIDEO_CHROMA_SITE_NONE = 1,
        const GST_VIDEO_CHROMA_SITE_H_COSITED = 2,
        const GST_VIDEO_CHROMA_SITE_V_COSITED = 4,
        const GST_VIDEO_CHROMA_SITE_ALT_LINE = 8,
        const GST_VIDEO_CHROMA_SITE_COSITED = 6,
        const GST_VIDEO_CHROMA_SITE_JPEG = 1,
        const GST_VIDEO_CHROMA_SITE_MPEG2 = 2,
        const GST_VIDEO_CHROMA_SITE_DV = 14,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstVideoCodecFrameFlags: c_uint {
        const GST_VIDEO_CODEC_FRAME_FLAG_DECODE_ONLY = 1,
        const GST_VIDEO_CODEC_FRAME_FLAG_SYNC_POINT = 2,
        const GST_VIDEO_CODEC_FRAME_FLAG_FORCE_KEYFRAME = 4,
        const GST_VIDEO_CODEC_FRAME_FLAG_FORCE_KEYFRAME_HEADERS = 8,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstVideoDitherFlags: c_uint {
        const GST_VIDEO_DITHER_FLAG_NONE = 0,
        const GST_VIDEO_DITHER_FLAG_INTERLACED = 1,
        const GST_VIDEO_DITHER_FLAG_QUANTIZE = 2,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstVideoFlags: c_uint {
        const GST_VIDEO_FLAG_NONE = 0,
        const GST_VIDEO_FLAG_VARIABLE_FPS = 1,
        const GST_VIDEO_FLAG_PREMULTIPLIED_ALPHA = 2,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstVideoFormatFlags: c_uint {
        const GST_VIDEO_FORMAT_FLAG_YUV = 1,
        const GST_VIDEO_FORMAT_FLAG_RGB = 2,
        const GST_VIDEO_FORMAT_FLAG_GRAY = 4,
        const GST_VIDEO_FORMAT_FLAG_ALPHA = 8,
        const GST_VIDEO_FORMAT_FLAG_LE = 16,
        const GST_VIDEO_FORMAT_FLAG_PALETTE = 32,
        const GST_VIDEO_FORMAT_FLAG_COMPLEX = 64,
        const GST_VIDEO_FORMAT_FLAG_UNPACK = 128,
        const GST_VIDEO_FORMAT_FLAG_TILED = 256,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstVideoFrameFlags: c_uint {
        const GST_VIDEO_FRAME_FLAG_NONE = 0,
        const GST_VIDEO_FRAME_FLAG_INTERLACED = 1,
        const GST_VIDEO_FRAME_FLAG_TFF = 2,
        const GST_VIDEO_FRAME_FLAG_RFF = 4,
        const GST_VIDEO_FRAME_FLAG_ONEFIELD = 8,
        const GST_VIDEO_FRAME_FLAG_MULTIPLE_VIEW = 16,
        const GST_VIDEO_FRAME_FLAG_FIRST_IN_BUNDLE = 32,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstVideoFrameMapFlags: c_uint {
        const GST_VIDEO_FRAME_MAP_FLAG_NO_REF = 65536,
        const GST_VIDEO_FRAME_MAP_FLAG_LAST = 16777216,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstVideoMultiviewFlags: c_uint {
        const GST_VIDEO_MULTIVIEW_FLAGS_NONE = 0,
        const GST_VIDEO_MULTIVIEW_FLAGS_RIGHT_VIEW_FIRST = 1,
        const GST_VIDEO_MULTIVIEW_FLAGS_LEFT_FLIPPED = 2,
        const GST_VIDEO_MULTIVIEW_FLAGS_LEFT_FLOPPED = 4,
        const GST_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLIPPED = 8,
        const GST_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLOPPED = 16,
        const GST_VIDEO_MULTIVIEW_FLAGS_HALF_ASPECT = 16384,
        const GST_VIDEO_MULTIVIEW_FLAGS_MIXED_MONO = 32768,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstVideoPackFlags: c_uint {
        const GST_VIDEO_PACK_FLAG_NONE = 0,
        const GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE = 1,
        const GST_VIDEO_PACK_FLAG_INTERLACED = 2,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstVideoResamplerFlags: c_uint {
        const GST_VIDEO_RESAMPLER_FLAG_NONE = 0,
        const GST_VIDEO_RESAMPLER_FLAG_HALF_TAPS = 1,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstVideoScalerFlags: c_uint {
        const GST_VIDEO_SCALER_FLAG_NONE = 0,
        const GST_VIDEO_SCALER_FLAG_INTERLACED = 1,
    }
}

bitflags! {
    #[repr(C)]
    pub flags GstVideoTimeCodeFlags: c_uint {
        const GST_VIDEO_TIME_CODE_FLAGS_NONE = 0,
        const GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME = 1,
        const GST_VIDEO_TIME_CODE_FLAGS_INTERLACED = 2,
    }
}

// Callbacks
pub type GstVideoAffineTransformationGetMatrix = Option<unsafe extern "C" fn(*mut GstVideoAffineTransformationMeta, *mut c_float) -> gboolean>;
pub type GstVideoConvertSampleCallback = Option<unsafe extern "C" fn(*mut gst::GstSample, *mut glib::GError, gpointer)>;
pub type GstVideoFormatPack = Option<unsafe extern "C" fn(*const GstVideoFormatInfo, GstVideoPackFlags, gpointer, c_int, gpointer, c_int, GstVideoChromaSite, c_int, c_int)>;
pub type GstVideoFormatUnpack = Option<unsafe extern "C" fn(*const GstVideoFormatInfo, GstVideoPackFlags, gpointer, gpointer, c_int, c_int, c_int, c_int)>;
pub type GstVideoGLTextureUpload = Option<unsafe extern "C" fn(*mut GstVideoGLTextureUploadMeta, c_uint) -> gboolean>;

// Records
#[repr(C)]
pub struct GstColorBalanceChannelClass {
    pub parent: gobject::GObjectClass,
    pub value_changed: Option<unsafe extern "C" fn(*mut GstColorBalanceChannel, c_int)>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstColorBalanceInterface {
    pub iface: gobject::GTypeInterface,
    pub list_channels: Option<unsafe extern "C" fn(*mut GstColorBalance) -> *const glib::GList>,
    pub set_value: Option<unsafe extern "C" fn(*mut GstColorBalance, *mut GstColorBalanceChannel, c_int)>,
    pub get_value: Option<unsafe extern "C" fn(*mut GstColorBalance, *mut GstColorBalanceChannel) -> c_int>,
    pub get_balance_type: Option<unsafe extern "C" fn(*mut GstColorBalance) -> GstColorBalanceType>,
    pub value_changed: Option<unsafe extern "C" fn(*mut GstColorBalance, *mut GstColorBalanceChannel, c_int)>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstNavigationInterface {
    pub iface: gobject::GTypeInterface,
    pub send_event: Option<unsafe extern "C" fn(*mut GstNavigation, *mut gst::GstStructure)>,
}

#[repr(C)]
pub struct GstVideoAffineTransformationMeta {
    pub meta: gst::GstMeta,
    pub matrix: [c_float; 16],
}

#[repr(C)]
pub struct GstVideoAlignment {
    pub padding_top: c_uint,
    pub padding_bottom: c_uint,
    pub padding_left: c_uint,
    pub padding_right: c_uint,
    pub stride_align: [c_uint; 4],
}

#[repr(C)]
pub struct GstVideoBufferPoolClass {
    pub parent_class: gst::GstBufferPoolClass,
}

#[repr(C)]
pub struct GstVideoBufferPoolPrivate(c_void);

#[repr(C)]
pub struct GstVideoChromaResample(c_void);

#[repr(C)]
pub struct GstVideoCodecFrame {
    pub ref_count: c_int,
    pub flags: u32,
    pub system_frame_number: u32,
    pub decode_frame_number: u32,
    pub presentation_frame_number: u32,
    pub dts: gst::GstClockTime,
    pub pts: gst::GstClockTime,
    pub duration: gst::GstClockTime,
    pub distance_from_sync: c_int,
    pub input_buffer: *mut gst::GstBuffer,
    pub output_buffer: *mut gst::GstBuffer,
    pub deadline: gst::GstClockTime,
    pub events: *mut glib::GList,
    pub user_data: gpointer,
    pub user_data_destroy_notify: glib::GDestroyNotify,
    _truncated_record_marker: c_void,
    //union,
}

#[repr(C)]
pub struct GstVideoCodecState {
    pub ref_count: c_int,
    pub info: GstVideoInfo,
    pub caps: *mut gst::GstCaps,
    pub codec_data: *mut gst::GstBuffer,
    pub allocation_caps: *mut gst::GstCaps,
    pub padding: [c_void; 19],
}

#[repr(C)]
pub struct GstVideoColorPrimariesInfo {
    pub primaries: GstVideoColorPrimaries,
    pub Wx: c_double,
    pub Wy: c_double,
    pub Rx: c_double,
    pub Ry: c_double,
    pub Gx: c_double,
    pub Gy: c_double,
    pub Bx: c_double,
    pub By: c_double,
}

#[repr(C)]
pub struct GstVideoColorimetry {
    pub range: GstVideoColorRange,
    pub matrix: GstVideoColorMatrix,
    pub transfer: GstVideoTransferFunction,
    pub primaries: GstVideoColorPrimaries,
}

#[repr(C)]
pub struct GstVideoConverter(c_void);

#[repr(C)]
pub struct GstVideoCropMeta {
    pub meta: gst::GstMeta,
    pub x: c_uint,
    pub y: c_uint,
    pub width: c_uint,
    pub height: c_uint,
}

#[repr(C)]
pub struct GstVideoDecoderClass {
    pub element_class: gst::GstElementClass,
    pub open: Option<unsafe extern "C" fn(*mut GstVideoDecoder) -> gboolean>,
    pub close: Option<unsafe extern "C" fn(*mut GstVideoDecoder) -> gboolean>,
    pub start: Option<unsafe extern "C" fn(*mut GstVideoDecoder) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstVideoDecoder) -> gboolean>,
    pub parse: Option<unsafe extern "C" fn(*mut GstVideoDecoder, *mut GstVideoCodecFrame, *mut gst_base::GstAdapter, gboolean) -> gst::GstFlowReturn>,
    pub set_format: Option<unsafe extern "C" fn(*mut GstVideoDecoder, *mut GstVideoCodecState) -> gboolean>,
    pub reset: Option<unsafe extern "C" fn(*mut GstVideoDecoder, gboolean) -> gboolean>,
    pub finish: Option<unsafe extern "C" fn(*mut GstVideoDecoder) -> gst::GstFlowReturn>,
    pub handle_frame: Option<unsafe extern "C" fn(*mut GstVideoDecoder, *mut GstVideoCodecFrame) -> gst::GstFlowReturn>,
    pub sink_event: Option<unsafe extern "C" fn(*mut GstVideoDecoder, *mut gst::GstEvent) -> gboolean>,
    pub src_event: Option<unsafe extern "C" fn(*mut GstVideoDecoder, *mut gst::GstEvent) -> gboolean>,
    pub negotiate: Option<unsafe extern "C" fn(*mut GstVideoDecoder) -> gboolean>,
    pub decide_allocation: Option<unsafe extern "C" fn(*mut GstVideoDecoder, *mut gst::GstQuery) -> gboolean>,
    pub propose_allocation: Option<unsafe extern "C" fn(*mut GstVideoDecoder, *mut gst::GstQuery) -> gboolean>,
    pub flush: Option<unsafe extern "C" fn(*mut GstVideoDecoder) -> gboolean>,
    pub sink_query: Option<unsafe extern "C" fn(*mut GstVideoDecoder, *mut gst::GstQuery) -> gboolean>,
    pub src_query: Option<unsafe extern "C" fn(*mut GstVideoDecoder, *mut gst::GstQuery) -> gboolean>,
    pub getcaps: Option<unsafe extern "C" fn(*mut GstVideoDecoder, *mut gst::GstCaps) -> *mut gst::GstCaps>,
    pub drain: Option<unsafe extern "C" fn(*mut GstVideoDecoder) -> gst::GstFlowReturn>,
    pub transform_meta: Option<unsafe extern "C" fn(*mut GstVideoDecoder, *mut GstVideoCodecFrame, *mut gst::GstMeta) -> gboolean>,
    pub padding: [c_void; 14],
}

#[repr(C)]
pub struct GstVideoDecoderPrivate(c_void);

#[repr(C)]
pub struct GstVideoDirectionInterface {
    pub iface: gobject::GTypeInterface,
}

#[repr(C)]
pub struct GstVideoDither(c_void);

#[repr(C)]
pub struct GstVideoEncoderClass {
    pub element_class: gst::GstElementClass,
    pub open: Option<unsafe extern "C" fn(*mut GstVideoEncoder) -> gboolean>,
    pub close: Option<unsafe extern "C" fn(*mut GstVideoEncoder) -> gboolean>,
    pub start: Option<unsafe extern "C" fn(*mut GstVideoEncoder) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstVideoEncoder) -> gboolean>,
    pub set_format: Option<unsafe extern "C" fn(*mut GstVideoEncoder, *mut GstVideoCodecState) -> gboolean>,
    pub handle_frame: Option<unsafe extern "C" fn(*mut GstVideoEncoder, *mut GstVideoCodecFrame) -> gst::GstFlowReturn>,
    pub reset: Option<unsafe extern "C" fn(*mut GstVideoEncoder, gboolean) -> gboolean>,
    pub finish: Option<unsafe extern "C" fn(*mut GstVideoEncoder) -> gst::GstFlowReturn>,
    pub pre_push: Option<unsafe extern "C" fn(*mut GstVideoEncoder, *mut GstVideoCodecFrame) -> gst::GstFlowReturn>,
    pub getcaps: Option<unsafe extern "C" fn(*mut GstVideoEncoder, *mut gst::GstCaps) -> *mut gst::GstCaps>,
    pub sink_event: Option<unsafe extern "C" fn(*mut GstVideoEncoder, *mut gst::GstEvent) -> gboolean>,
    pub src_event: Option<unsafe extern "C" fn(*mut GstVideoEncoder, *mut gst::GstEvent) -> gboolean>,
    pub negotiate: Option<unsafe extern "C" fn(*mut GstVideoEncoder) -> gboolean>,
    pub decide_allocation: Option<unsafe extern "C" fn(*mut GstVideoEncoder, *mut gst::GstQuery) -> gboolean>,
    pub propose_allocation: Option<unsafe extern "C" fn(*mut GstVideoEncoder, *mut gst::GstQuery) -> gboolean>,
    pub flush: Option<unsafe extern "C" fn(*mut GstVideoEncoder) -> gboolean>,
    pub sink_query: Option<unsafe extern "C" fn(*mut GstVideoEncoder, *mut gst::GstQuery) -> gboolean>,
    pub src_query: Option<unsafe extern "C" fn(*mut GstVideoEncoder, *mut gst::GstQuery) -> gboolean>,
    pub transform_meta: Option<unsafe extern "C" fn(*mut GstVideoEncoder, *mut GstVideoCodecFrame, *mut gst::GstMeta) -> gboolean>,
    pub _gst_reserved: [gpointer; 16],
}

#[repr(C)]
pub struct GstVideoEncoderPrivate(c_void);

#[repr(C)]
pub struct GstVideoFilterClass {
    pub parent_class: gst_base::GstBaseTransformClass,
    pub set_info: Option<unsafe extern "C" fn(*mut GstVideoFilter, *mut gst::GstCaps, *mut GstVideoInfo, *mut gst::GstCaps, *mut GstVideoInfo) -> gboolean>,
    pub transform_frame: Option<unsafe extern "C" fn(*mut GstVideoFilter, *mut GstVideoFrame, *mut GstVideoFrame) -> gst::GstFlowReturn>,
    pub transform_frame_ip: Option<unsafe extern "C" fn(*mut GstVideoFilter, *mut GstVideoFrame) -> gst::GstFlowReturn>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstVideoFormatInfo {
    pub format: GstVideoFormat,
    pub name: *const c_char,
    pub description: *const c_char,
    pub flags: GstVideoFormatFlags,
    pub bits: c_uint,
    pub n_components: c_uint,
    pub shift: [c_uint; 4],
    pub depth: [c_uint; 4],
    pub pixel_stride: [c_int; 4],
    pub n_planes: c_uint,
    pub plane: [c_uint; 4],
    pub poffset: [c_uint; 4],
    pub w_sub: [c_uint; 4],
    pub h_sub: [c_uint; 4],
    pub unpack_format: GstVideoFormat,
    pub unpack_func: GstVideoFormatUnpack,
    pub pack_lines: c_int,
    pub pack_func: GstVideoFormatPack,
    pub tile_mode: GstVideoTileMode,
    pub tile_ws: c_uint,
    pub tile_hs: c_uint,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstVideoFrame {
    pub info: GstVideoInfo,
    pub flags: GstVideoFrameFlags,
    pub buffer: *mut gst::GstBuffer,
    pub meta: gpointer,
    pub id: c_int,
    pub data: [gpointer; 4],
    pub map: [gst::GstMapInfo; 4],
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstVideoGLTextureUploadMeta {
    pub meta: gst::GstMeta,
    pub texture_orientation: GstVideoGLTextureOrientation,
    pub n_textures: c_uint,
    pub texture_type: [GstVideoGLTextureType; 4],
    pub buffer: *mut gst::GstBuffer,
    pub upload: GstVideoGLTextureUpload,
    pub user_data: gpointer,
    pub user_data_copy: gobject::GBoxedCopyFunc,
    pub user_data_free: gobject::GBoxedFreeFunc,
}

#[repr(C)]
pub struct GstVideoInfo {
    pub finfo: *const GstVideoFormatInfo,
    pub interlace_mode: GstVideoInterlaceMode,
    pub flags: GstVideoFlags,
    pub width: c_int,
    pub height: c_int,
    pub size: size_t,
    pub views: c_int,
    pub chroma_site: GstVideoChromaSite,
    pub colorimetry: GstVideoColorimetry,
    pub par_n: c_int,
    pub par_d: c_int,
    pub fps_n: c_int,
    pub fps_d: c_int,
    pub offset: [size_t; 4],
    pub stride: [c_int; 4],
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstVideoMeta {
    pub meta: gst::GstMeta,
    pub buffer: *mut gst::GstBuffer,
    pub flags: GstVideoFrameFlags,
    pub format: GstVideoFormat,
    pub id: c_int,
    pub width: c_uint,
    pub height: c_uint,
    pub n_planes: c_uint,
    pub offset: [size_t; 4],
    pub stride: [c_int; 4],
    pub map: Option<unsafe extern "C" fn(*mut GstVideoMeta, c_uint, *mut gst::GstMapInfo, *mut gpointer, *mut c_int, gst::GstMapFlags) -> gboolean>,
    pub unmap: Option<unsafe extern "C" fn(*mut GstVideoMeta, c_uint, *mut gst::GstMapInfo) -> gboolean>,
}

#[repr(C)]
pub struct GstVideoMetaTransform {
    pub in_info: *mut GstVideoInfo,
    pub out_info: *mut GstVideoInfo,
}

#[repr(C)]
pub struct GstVideoOrientationInterface {
    pub iface: gobject::GTypeInterface,
    pub get_hflip: Option<unsafe extern "C" fn(*mut GstVideoOrientation, gboolean) -> gboolean>,
    pub get_vflip: Option<unsafe extern "C" fn(*mut GstVideoOrientation, gboolean) -> gboolean>,
    pub get_hcenter: Option<unsafe extern "C" fn(*mut GstVideoOrientation, c_int) -> gboolean>,
    pub get_vcenter: Option<unsafe extern "C" fn(*mut GstVideoOrientation, c_int) -> gboolean>,
    pub set_hflip: Option<unsafe extern "C" fn(*mut GstVideoOrientation, gboolean) -> gboolean>,
    pub set_vflip: Option<unsafe extern "C" fn(*mut GstVideoOrientation, gboolean) -> gboolean>,
    pub set_hcenter: Option<unsafe extern "C" fn(*mut GstVideoOrientation, c_int) -> gboolean>,
    pub set_vcenter: Option<unsafe extern "C" fn(*mut GstVideoOrientation, c_int) -> gboolean>,
}

#[repr(C)]
pub struct GstVideoOverlayComposition(c_void);

#[repr(C)]
pub struct GstVideoOverlayCompositionMeta {
    pub meta: gst::GstMeta,
    pub overlay: *mut GstVideoOverlayComposition,
}

#[repr(C)]
pub struct GstVideoOverlayInterface {
    pub iface: gobject::GTypeInterface,
    pub expose: Option<unsafe extern "C" fn(*mut GstVideoOverlay)>,
    pub handle_events: Option<unsafe extern "C" fn(*mut GstVideoOverlay, gboolean)>,
    pub set_render_rectangle: Option<unsafe extern "C" fn(*mut GstVideoOverlay, c_int, c_int, c_int, c_int)>,
    pub set_window_handle: Option<unsafe extern "C" fn(*mut GstVideoOverlay, uintptr_t)>,
}

#[repr(C)]
pub struct GstVideoOverlayRectangle(c_void);

#[repr(C)]
pub struct GstVideoRectangle {
    pub x: c_int,
    pub y: c_int,
    pub w: c_int,
    pub h: c_int,
}

#[repr(C)]
pub struct GstVideoRegionOfInterestMeta {
    pub meta: gst::GstMeta,
    pub roi_type: glib::GQuark,
    pub id: c_int,
    pub parent_id: c_int,
    pub x: c_uint,
    pub y: c_uint,
    pub w: c_uint,
    pub h: c_uint,
}

#[repr(C)]
pub struct GstVideoResampler {
    pub in_size: c_int,
    pub out_size: c_int,
    pub max_taps: c_uint,
    pub n_phases: c_uint,
    pub offset: *mut u32,
    pub phase: *mut u32,
    pub n_taps: *mut u32,
    pub taps: *mut c_double,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstVideoScaler(c_void);

#[repr(C)]
pub struct GstVideoSinkClass {
    pub parent_class: gst_base::GstBaseSinkClass,
    pub show_frame: Option<unsafe extern "C" fn(*mut GstVideoSink, *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstVideoSinkPrivate(c_void);

#[repr(C)]
pub struct GstVideoTimeCode {
    pub config: GstVideoTimeCodeConfig,
    pub hours: c_uint,
    pub minutes: c_uint,
    pub seconds: c_uint,
    pub frames: c_uint,
    pub field_count: c_uint,
}

#[repr(C)]
pub struct GstVideoTimeCodeConfig {
    pub fps_n: c_uint,
    pub fps_d: c_uint,
    pub flags: GstVideoTimeCodeFlags,
    pub latest_daily_jam: *mut glib::GDateTime,
}

#[repr(C)]
pub struct GstVideoTimeCodeInterval {
    pub hours: c_uint,
    pub minutes: c_uint,
    pub seconds: c_uint,
    pub frames: c_uint,
}

#[repr(C)]
pub struct GstVideoTimeCodeMeta {
    pub meta: gst::GstMeta,
    pub tc: GstVideoTimeCode,
}

// Classes
#[repr(C)]
pub struct GstColorBalanceChannel {
    pub parent: gobject::GObject,
    pub label: *mut c_char,
    pub min_value: c_int,
    pub max_value: c_int,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstVideoBufferPool {
    pub bufferpool: gst::GstBufferPool,
    pub priv_: *mut GstVideoBufferPoolPrivate,
}

#[repr(C)]
pub struct GstVideoDecoder {
    pub element: gst::GstElement,
    pub sinkpad: *mut gst::GstPad,
    pub srcpad: *mut gst::GstPad,
    pub stream_lock: glib::GRecMutex,
    pub input_segment: gst::GstSegment,
    pub output_segment: gst::GstSegment,
    pub priv_: *mut GstVideoDecoderPrivate,
    pub padding: [c_void; 20],
}

#[repr(C)]
pub struct GstVideoEncoder {
    pub element: gst::GstElement,
    pub sinkpad: *mut gst::GstPad,
    pub srcpad: *mut gst::GstPad,
    pub stream_lock: glib::GRecMutex,
    pub input_segment: gst::GstSegment,
    pub output_segment: gst::GstSegment,
    pub priv_: *mut GstVideoEncoderPrivate,
    pub padding: [c_void; 20],
}

#[repr(C)]
pub struct GstVideoFilter {
    pub element: gst_base::GstBaseTransform,
    pub negotiated: gboolean,
    pub in_info: GstVideoInfo,
    pub out_info: GstVideoInfo,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstVideoMultiviewFlagsSet(c_void);

#[repr(C)]
pub struct GstVideoSink {
    pub element: gst_base::GstBaseSink,
    pub width: c_int,
    pub height: c_int,
    pub priv_: *mut GstVideoSinkPrivate,
    pub _gst_reserved: [gpointer; 4],
}

// Interfaces
#[repr(C)]
pub struct GstColorBalance(c_void);
#[repr(C)]
pub struct GstNavigation(c_void);
#[repr(C)]
pub struct GstVideoDirection(c_void);
#[repr(C)]
pub struct GstVideoOrientation(c_void);
#[repr(C)]
pub struct GstVideoOverlay(c_void);

extern "C" {

    //=========================================================================
    // GstVideoColorMatrix
    //=========================================================================
    #[cfg(feature = "v1_6")]
    pub fn gst_video_color_matrix_get_Kr_Kb(matrix: GstVideoColorMatrix, Kr: *mut c_double, Kb: *mut c_double) -> gboolean;

    //=========================================================================
    // GstVideoColorPrimaries
    //=========================================================================
    #[cfg(feature = "v1_6")]
    pub fn gst_video_color_primaries_get_info(primaries: GstVideoColorPrimaries) -> *const GstVideoColorPrimariesInfo;

    //=========================================================================
    // GstVideoColorRange
    //=========================================================================
    pub fn gst_video_color_range_offsets(range: GstVideoColorRange, info: *const GstVideoFormatInfo, offset: c_int, scale: c_int);

    //=========================================================================
    // GstVideoFieldOrder
    //=========================================================================
    #[cfg(feature = "v1_12")]
    pub fn gst_video_field_order_from_string(order: *const c_char) -> GstVideoFieldOrder;
    #[cfg(feature = "v1_12")]
    pub fn gst_video_field_order_to_string(order: GstVideoFieldOrder) -> *const c_char;

    //=========================================================================
    // GstVideoFormat
    //=========================================================================
    pub fn gst_video_format_from_fourcc(fourcc: u32) -> GstVideoFormat;
    pub fn gst_video_format_from_masks(depth: c_int, bpp: c_int, endianness: c_int, red_mask: c_uint, green_mask: c_uint, blue_mask: c_uint, alpha_mask: c_uint) -> GstVideoFormat;
    pub fn gst_video_format_from_string(format: *const c_char) -> GstVideoFormat;
    pub fn gst_video_format_get_info(format: GstVideoFormat) -> *const GstVideoFormatInfo;
    #[cfg(feature = "v1_2")]
    pub fn gst_video_format_get_palette(format: GstVideoFormat, size: *mut size_t) -> gconstpointer;
    pub fn gst_video_format_to_fourcc(format: GstVideoFormat) -> u32;
    pub fn gst_video_format_to_string(format: GstVideoFormat) -> *const c_char;

    //=========================================================================
    // GstVideoInterlaceMode
    //=========================================================================
    #[cfg(feature = "v1_6")]
    pub fn gst_video_interlace_mode_from_string(mode: *const c_char) -> GstVideoInterlaceMode;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_interlace_mode_to_string(mode: GstVideoInterlaceMode) -> *const c_char;

    //=========================================================================
    // GstVideoMultiviewMode
    //=========================================================================
    #[cfg(feature = "v1_6")]
    pub fn gst_video_multiview_mode_from_caps_string(caps_mview_mode: *const c_char) -> GstVideoMultiviewMode;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_multiview_mode_to_caps_string(mview_mode: GstVideoMultiviewMode) -> *const c_char;

    //=========================================================================
    // GstVideoAffineTransformationMeta
    //=========================================================================
    #[cfg(feature = "v1_8")]
    pub fn gst_video_affine_transformation_meta_apply_matrix(meta: *mut GstVideoAffineTransformationMeta, matrix: c_float);
    pub fn gst_video_affine_transformation_meta_get_info() -> *const gst::GstMetaInfo;

    //=========================================================================
    // GstVideoAlignment
    //=========================================================================
    pub fn gst_video_alignment_reset(align: *mut GstVideoAlignment);

    //=========================================================================
    // GstVideoChromaResample
    //=========================================================================
    pub fn gst_video_chroma_resample_free(resample: *mut GstVideoChromaResample);
    pub fn gst_video_chroma_resample_get_info(resample: *mut GstVideoChromaResample, n_lines: *mut c_uint, offset: *mut c_int);
    pub fn gst_video_chroma_resample_new(method: GstVideoChromaMethod, site: GstVideoChromaSite, flags: GstVideoChromaFlags, format: GstVideoFormat, h_factor: c_int, v_factor: c_int) -> *mut GstVideoChromaResample;

    //=========================================================================
    // GstVideoCodecFrame
    //=========================================================================
    pub fn gst_video_codec_frame_get_type() -> GType;
    pub fn gst_video_codec_frame_get_user_data(frame: *mut GstVideoCodecFrame) -> gpointer;
    pub fn gst_video_codec_frame_ref(frame: *mut GstVideoCodecFrame) -> *mut GstVideoCodecFrame;
    pub fn gst_video_codec_frame_set_user_data(frame: *mut GstVideoCodecFrame, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_video_codec_frame_unref(frame: *mut GstVideoCodecFrame);

    //=========================================================================
    // GstVideoCodecState
    //=========================================================================
    pub fn gst_video_codec_state_get_type() -> GType;
    pub fn gst_video_codec_state_ref(state: *mut GstVideoCodecState) -> *mut GstVideoCodecState;
    pub fn gst_video_codec_state_unref(state: *mut GstVideoCodecState);

    //=========================================================================
    // GstVideoColorimetry
    //=========================================================================
    pub fn gst_video_colorimetry_from_string(cinfo: *mut GstVideoColorimetry, color: *const c_char) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_colorimetry_is_equal(cinfo: *const GstVideoColorimetry, other: *const GstVideoColorimetry) -> gboolean;
    pub fn gst_video_colorimetry_matches(cinfo: *const GstVideoColorimetry, color: *const c_char) -> gboolean;
    pub fn gst_video_colorimetry_to_string(cinfo: *const GstVideoColorimetry) -> *mut c_char;

    //=========================================================================
    // GstVideoConverter
    //=========================================================================
    #[cfg(feature = "v1_6")]
    pub fn gst_video_converter_frame(convert: *mut GstVideoConverter, src: *const GstVideoFrame, dest: *mut GstVideoFrame);
    #[cfg(feature = "v1_6")]
    pub fn gst_video_converter_free(convert: *mut GstVideoConverter);
    pub fn gst_video_converter_get_config(convert: *mut GstVideoConverter) -> *const gst::GstStructure;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_converter_set_config(convert: *mut GstVideoConverter, config: *mut gst::GstStructure) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_converter_new(in_info: *mut GstVideoInfo, out_info: *mut GstVideoInfo, config: *mut gst::GstStructure) -> *mut GstVideoConverter;

    //=========================================================================
    // GstVideoCropMeta
    //=========================================================================
    pub fn gst_video_crop_meta_get_info() -> *const gst::GstMetaInfo;

    //=========================================================================
    // GstVideoDither
    //=========================================================================
    pub fn gst_video_dither_free(dither: *mut GstVideoDither);
    pub fn gst_video_dither_line(dither: *mut GstVideoDither, line: gpointer, x: c_uint, y: c_uint, width: c_uint);
    pub fn gst_video_dither_new(method: GstVideoDitherMethod, flags: GstVideoDitherFlags, format: GstVideoFormat, quantizer: c_uint, width: c_uint) -> *mut GstVideoDither;

    //=========================================================================
    // GstVideoFrame
    //=========================================================================
    pub fn gst_video_frame_copy(dest: *mut GstVideoFrame, src: *const GstVideoFrame) -> gboolean;
    pub fn gst_video_frame_copy_plane(dest: *mut GstVideoFrame, src: *const GstVideoFrame, plane: c_uint) -> gboolean;
    pub fn gst_video_frame_map(frame: *mut GstVideoFrame, info: *mut GstVideoInfo, buffer: *mut gst::GstBuffer, flags: gst::GstMapFlags) -> gboolean;
    pub fn gst_video_frame_map_id(frame: *mut GstVideoFrame, info: *mut GstVideoInfo, buffer: *mut gst::GstBuffer, id: c_int, flags: gst::GstMapFlags) -> gboolean;
    pub fn gst_video_frame_unmap(frame: *mut GstVideoFrame);

    //=========================================================================
    // GstVideoGLTextureUploadMeta
    //=========================================================================
    pub fn gst_video_gl_texture_upload_meta_upload(meta: *mut GstVideoGLTextureUploadMeta, texture_id: c_uint) -> gboolean;
    pub fn gst_video_gl_texture_upload_meta_get_info() -> *const gst::GstMetaInfo;

    //=========================================================================
    // GstVideoInfo
    //=========================================================================
    pub fn gst_video_info_get_type() -> GType;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_info_new() -> *mut GstVideoInfo;
    pub fn gst_video_info_align(info: *mut GstVideoInfo, align: *mut GstVideoAlignment) -> gboolean;
    pub fn gst_video_info_convert(info: *mut GstVideoInfo, src_format: gst::GstFormat, src_value: i64, dest_format: gst::GstFormat, dest_value: *mut i64) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_info_copy(info: *const GstVideoInfo) -> *mut GstVideoInfo;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_info_free(info: *mut GstVideoInfo);
    pub fn gst_video_info_from_caps(info: *mut GstVideoInfo, caps: *const gst::GstCaps) -> gboolean;
    pub fn gst_video_info_init(info: *mut GstVideoInfo);
    pub fn gst_video_info_is_equal(info: *const GstVideoInfo, other: *const GstVideoInfo) -> gboolean;
    pub fn gst_video_info_set_format(info: *mut GstVideoInfo, format: GstVideoFormat, width: c_uint, height: c_uint) -> gboolean;
    pub fn gst_video_info_to_caps(info: *mut GstVideoInfo) -> *mut gst::GstCaps;

    //=========================================================================
    // GstVideoMeta
    //=========================================================================
    pub fn gst_video_meta_map(meta: *mut GstVideoMeta, plane: c_uint, info: *mut gst::GstMapInfo, data: *mut gpointer, stride: *mut c_int, flags: gst::GstMapFlags) -> gboolean;
    pub fn gst_video_meta_unmap(meta: *mut GstVideoMeta, plane: c_uint, info: *mut gst::GstMapInfo) -> gboolean;
    pub fn gst_video_meta_get_info() -> *const gst::GstMetaInfo;

    //=========================================================================
    // GstVideoMetaTransform
    //=========================================================================
    pub fn gst_video_meta_transform_scale_get_quark() -> glib::GQuark;

    //=========================================================================
    // GstVideoOverlayComposition
    //=========================================================================
    pub fn gst_video_overlay_composition_get_type() -> GType;
    pub fn gst_video_overlay_composition_new(rectangle: *mut GstVideoOverlayRectangle) -> *mut GstVideoOverlayComposition;
    pub fn gst_video_overlay_composition_add_rectangle(comp: *mut GstVideoOverlayComposition, rectangle: *mut GstVideoOverlayRectangle);
    pub fn gst_video_overlay_composition_blend(comp: *mut GstVideoOverlayComposition, video_buf: *mut GstVideoFrame) -> gboolean;
    pub fn gst_video_overlay_composition_copy(comp: *mut GstVideoOverlayComposition) -> *mut GstVideoOverlayComposition;
    pub fn gst_video_overlay_composition_get_rectangle(comp: *mut GstVideoOverlayComposition, n: c_uint) -> *mut GstVideoOverlayRectangle;
    pub fn gst_video_overlay_composition_get_seqnum(comp: *mut GstVideoOverlayComposition) -> c_uint;
    pub fn gst_video_overlay_composition_make_writable(comp: *mut GstVideoOverlayComposition) -> *mut GstVideoOverlayComposition;
    pub fn gst_video_overlay_composition_n_rectangles(comp: *mut GstVideoOverlayComposition) -> c_uint;

    //=========================================================================
    // GstVideoOverlayCompositionMeta
    //=========================================================================
    pub fn gst_video_overlay_composition_meta_get_info() -> *const gst::GstMetaInfo;

    //=========================================================================
    // GstVideoOverlayRectangle
    //=========================================================================
    pub fn gst_video_overlay_rectangle_get_type() -> GType;
    pub fn gst_video_overlay_rectangle_new_raw(pixels: *mut gst::GstBuffer, render_x: c_int, render_y: c_int, render_width: c_uint, render_height: c_uint, flags: GstVideoOverlayFormatFlags) -> *mut GstVideoOverlayRectangle;
    pub fn gst_video_overlay_rectangle_copy(rectangle: *mut GstVideoOverlayRectangle) -> *mut GstVideoOverlayRectangle;
    pub fn gst_video_overlay_rectangle_get_flags(rectangle: *mut GstVideoOverlayRectangle) -> GstVideoOverlayFormatFlags;
    pub fn gst_video_overlay_rectangle_get_global_alpha(rectangle: *mut GstVideoOverlayRectangle) -> c_float;
    pub fn gst_video_overlay_rectangle_get_pixels_argb(rectangle: *mut GstVideoOverlayRectangle, flags: GstVideoOverlayFormatFlags) -> *mut gst::GstBuffer;
    pub fn gst_video_overlay_rectangle_get_pixels_ayuv(rectangle: *mut GstVideoOverlayRectangle, flags: GstVideoOverlayFormatFlags) -> *mut gst::GstBuffer;
    pub fn gst_video_overlay_rectangle_get_pixels_raw(rectangle: *mut GstVideoOverlayRectangle, flags: GstVideoOverlayFormatFlags) -> *mut gst::GstBuffer;
    pub fn gst_video_overlay_rectangle_get_pixels_unscaled_argb(rectangle: *mut GstVideoOverlayRectangle, flags: GstVideoOverlayFormatFlags) -> *mut gst::GstBuffer;
    pub fn gst_video_overlay_rectangle_get_pixels_unscaled_ayuv(rectangle: *mut GstVideoOverlayRectangle, flags: GstVideoOverlayFormatFlags) -> *mut gst::GstBuffer;
    pub fn gst_video_overlay_rectangle_get_pixels_unscaled_raw(rectangle: *mut GstVideoOverlayRectangle, flags: GstVideoOverlayFormatFlags) -> *mut gst::GstBuffer;
    pub fn gst_video_overlay_rectangle_get_render_rectangle(rectangle: *mut GstVideoOverlayRectangle, render_x: *mut c_int, render_y: *mut c_int, render_width: *mut c_uint, render_height: *mut c_uint) -> gboolean;
    pub fn gst_video_overlay_rectangle_get_seqnum(rectangle: *mut GstVideoOverlayRectangle) -> c_uint;
    pub fn gst_video_overlay_rectangle_set_global_alpha(rectangle: *mut GstVideoOverlayRectangle, global_alpha: c_float);
    pub fn gst_video_overlay_rectangle_set_render_rectangle(rectangle: *mut GstVideoOverlayRectangle, render_x: c_int, render_y: c_int, render_width: c_uint, render_height: c_uint);

    //=========================================================================
    // GstVideoRegionOfInterestMeta
    //=========================================================================
    pub fn gst_video_region_of_interest_meta_get_info() -> *const gst::GstMetaInfo;

    //=========================================================================
    // GstVideoResampler
    //=========================================================================
    #[cfg(feature = "v1_6")]
    pub fn gst_video_resampler_clear(resampler: *mut GstVideoResampler);
    pub fn gst_video_resampler_init(resampler: *mut GstVideoResampler, method: GstVideoResamplerMethod, flags: GstVideoResamplerFlags, n_phases: c_uint, n_taps: c_uint, shift: c_double, in_size: c_uint, out_size: c_uint, options: *mut gst::GstStructure) -> gboolean;

    //=========================================================================
    // GstVideoScaler
    //=========================================================================
    pub fn gst_video_scaler_2d(hscale: *mut GstVideoScaler, vscale: *mut GstVideoScaler, format: GstVideoFormat, src: gpointer, src_stride: c_int, dest: gpointer, dest_stride: c_int, x: c_uint, y: c_uint, width: c_uint, height: c_uint);
    #[cfg(feature = "v1_6")]
    pub fn gst_video_scaler_combine_packed_YUV(y_scale: *mut GstVideoScaler, uv_scale: *mut GstVideoScaler, in_format: GstVideoFormat, out_format: GstVideoFormat) -> *mut GstVideoScaler;
    pub fn gst_video_scaler_free(scale: *mut GstVideoScaler);
    pub fn gst_video_scaler_get_coeff(scale: *mut GstVideoScaler, out_offset: c_uint, in_offset: *mut c_uint, n_taps: *mut c_uint) -> *const c_double;
    pub fn gst_video_scaler_get_max_taps(scale: *mut GstVideoScaler) -> c_uint;
    pub fn gst_video_scaler_horizontal(scale: *mut GstVideoScaler, format: GstVideoFormat, src: gpointer, dest: gpointer, dest_offset: c_uint, width: c_uint);
    pub fn gst_video_scaler_vertical(scale: *mut GstVideoScaler, format: GstVideoFormat, src_lines: gpointer, dest: gpointer, dest_offset: c_uint, width: c_uint);
    pub fn gst_video_scaler_new(method: GstVideoResamplerMethod, flags: GstVideoScalerFlags, n_taps: c_uint, in_size: c_uint, out_size: c_uint, options: *mut gst::GstStructure) -> *mut GstVideoScaler;

    //=========================================================================
    // GstVideoTimeCode
    //=========================================================================
    pub fn gst_video_time_code_get_type() -> GType;
    #[cfg(feature = "v1_10")]
    pub fn gst_video_time_code_new(fps_n: c_uint, fps_d: c_uint, latest_daily_jam: *mut glib::GDateTime, flags: GstVideoTimeCodeFlags, hours: c_uint, minutes: c_uint, seconds: c_uint, frames: c_uint, field_count: c_uint) -> *mut GstVideoTimeCode;
    #[cfg(feature = "v1_10")]
    pub fn gst_video_time_code_new_empty() -> *mut GstVideoTimeCode;
    #[cfg(feature = "v1_12")]
    pub fn gst_video_time_code_new_from_date_time(fps_n: c_uint, fps_d: c_uint, dt: *mut glib::GDateTime, flags: GstVideoTimeCodeFlags, field_count: c_uint) -> *mut GstVideoTimeCode;
    #[cfg(feature = "v1_12")]
    pub fn gst_video_time_code_new_from_string(tc_str: *const c_char) -> *mut GstVideoTimeCode;
    #[cfg(feature = "v1_10")]
    pub fn gst_video_time_code_add_frames(tc: *mut GstVideoTimeCode, frames: i64);
    #[cfg(feature = "v1_12")]
    pub fn gst_video_time_code_add_interval(tc: *const GstVideoTimeCode, tc_inter: *const GstVideoTimeCodeInterval) -> *mut GstVideoTimeCode;
    #[cfg(feature = "v1_10")]
    pub fn gst_video_time_code_clear(tc: *mut GstVideoTimeCode);
    #[cfg(feature = "v1_10")]
    pub fn gst_video_time_code_compare(tc1: *const GstVideoTimeCode, tc2: *const GstVideoTimeCode) -> c_int;
    #[cfg(feature = "v1_10")]
    pub fn gst_video_time_code_copy(tc: *const GstVideoTimeCode) -> *mut GstVideoTimeCode;
    #[cfg(feature = "v1_10")]
    pub fn gst_video_time_code_frames_since_daily_jam(tc: *const GstVideoTimeCode) -> u64;
    #[cfg(feature = "v1_10")]
    pub fn gst_video_time_code_free(tc: *mut GstVideoTimeCode);
    #[cfg(feature = "v1_10")]
    pub fn gst_video_time_code_increment_frame(tc: *mut GstVideoTimeCode);
    #[cfg(feature = "v1_10")]
    pub fn gst_video_time_code_init(tc: *mut GstVideoTimeCode, fps_n: c_uint, fps_d: c_uint, latest_daily_jam: *mut glib::GDateTime, flags: GstVideoTimeCodeFlags, hours: c_uint, minutes: c_uint, seconds: c_uint, frames: c_uint, field_count: c_uint);
    #[cfg(feature = "v1_12")]
    pub fn gst_video_time_code_init_from_date_time(tc: *mut GstVideoTimeCode, fps_n: c_uint, fps_d: c_uint, dt: *mut glib::GDateTime, flags: GstVideoTimeCodeFlags, field_count: c_uint);
    #[cfg(feature = "v1_10")]
    pub fn gst_video_time_code_is_valid(tc: *const GstVideoTimeCode) -> gboolean;
    #[cfg(feature = "v1_10")]
    pub fn gst_video_time_code_nsec_since_daily_jam(tc: *const GstVideoTimeCode) -> u64;
    #[cfg(feature = "v1_10")]
    pub fn gst_video_time_code_to_date_time(tc: *const GstVideoTimeCode) -> *mut glib::GDateTime;
    #[cfg(feature = "v1_10")]
    pub fn gst_video_time_code_to_string(tc: *const GstVideoTimeCode) -> *mut c_char;

    //=========================================================================
    // GstVideoTimeCodeInterval
    //=========================================================================
    pub fn gst_video_time_code_interval_get_type() -> GType;
    #[cfg(feature = "v1_12")]
    pub fn gst_video_time_code_interval_new(hours: c_uint, minutes: c_uint, seconds: c_uint, frames: c_uint) -> *mut GstVideoTimeCodeInterval;
    #[cfg(feature = "v1_12")]
    pub fn gst_video_time_code_interval_new_from_string(tc_inter_str: *const c_char) -> *mut GstVideoTimeCodeInterval;
    #[cfg(feature = "v1_12")]
    pub fn gst_video_time_code_interval_clear(tc: *mut GstVideoTimeCodeInterval);
    #[cfg(feature = "v1_12")]
    pub fn gst_video_time_code_interval_copy(tc: *const GstVideoTimeCodeInterval) -> *mut GstVideoTimeCodeInterval;
    #[cfg(feature = "v1_12")]
    pub fn gst_video_time_code_interval_free(tc: *mut GstVideoTimeCodeInterval);
    #[cfg(feature = "v1_12")]
    pub fn gst_video_time_code_interval_init(tc: *mut GstVideoTimeCodeInterval, hours: c_uint, minutes: c_uint, seconds: c_uint, frames: c_uint);

    //=========================================================================
    // GstVideoTimeCodeMeta
    //=========================================================================
    pub fn gst_video_time_code_meta_get_info() -> *const gst::GstMetaInfo;

    //=========================================================================
    // GstColorBalanceChannel
    //=========================================================================
    pub fn gst_color_balance_channel_get_type() -> GType;

    //=========================================================================
    // GstVideoBufferPool
    //=========================================================================
    pub fn gst_video_buffer_pool_get_type() -> GType;
    pub fn gst_video_buffer_pool_new() -> *mut gst::GstBufferPool;

    //=========================================================================
    // GstVideoDecoder
    //=========================================================================
    pub fn gst_video_decoder_get_type() -> GType;
    pub fn gst_video_decoder_add_to_frame(decoder: *mut GstVideoDecoder, n_bytes: c_int);
    pub fn gst_video_decoder_allocate_output_buffer(decoder: *mut GstVideoDecoder) -> *mut gst::GstBuffer;
    pub fn gst_video_decoder_allocate_output_frame(decoder: *mut GstVideoDecoder, frame: *mut GstVideoCodecFrame) -> gst::GstFlowReturn;
    #[cfg(feature = "v1_12")]
    pub fn gst_video_decoder_allocate_output_frame_with_params(decoder: *mut GstVideoDecoder, frame: *mut GstVideoCodecFrame, params: *mut gst::GstBufferPoolAcquireParams) -> gst::GstFlowReturn;
    pub fn gst_video_decoder_drop_frame(dec: *mut GstVideoDecoder, frame: *mut GstVideoCodecFrame) -> gst::GstFlowReturn;
    pub fn gst_video_decoder_finish_frame(decoder: *mut GstVideoDecoder, frame: *mut GstVideoCodecFrame) -> gst::GstFlowReturn;
    pub fn gst_video_decoder_get_allocator(decoder: *mut GstVideoDecoder, allocator: *mut *mut gst::GstAllocator, params: *mut gst::GstAllocationParams);
    pub fn gst_video_decoder_get_buffer_pool(decoder: *mut GstVideoDecoder) -> *mut gst::GstBufferPool;
    pub fn gst_video_decoder_get_estimate_rate(dec: *mut GstVideoDecoder) -> c_int;
    pub fn gst_video_decoder_get_frame(decoder: *mut GstVideoDecoder, frame_number: c_int) -> *mut GstVideoCodecFrame;
    pub fn gst_video_decoder_get_frames(decoder: *mut GstVideoDecoder) -> *mut glib::GList;
    pub fn gst_video_decoder_get_latency(decoder: *mut GstVideoDecoder, min_latency: *mut gst::GstClockTime, max_latency: *mut gst::GstClockTime);
    pub fn gst_video_decoder_get_max_decode_time(decoder: *mut GstVideoDecoder, frame: *mut GstVideoCodecFrame) -> gst::GstClockTimeDiff;
    pub fn gst_video_decoder_get_max_errors(dec: *mut GstVideoDecoder) -> c_int;
    #[cfg(feature = "v1_4")]
    pub fn gst_video_decoder_get_needs_format(dec: *mut GstVideoDecoder) -> gboolean;
    pub fn gst_video_decoder_get_oldest_frame(decoder: *mut GstVideoDecoder) -> *mut GstVideoCodecFrame;
    pub fn gst_video_decoder_get_output_state(decoder: *mut GstVideoDecoder) -> *mut GstVideoCodecState;
    pub fn gst_video_decoder_get_packetized(decoder: *mut GstVideoDecoder) -> gboolean;
    #[cfg(feature = "v1_4")]
    pub fn gst_video_decoder_get_pending_frame_size(decoder: *mut GstVideoDecoder) -> size_t;
    #[cfg(feature = "v1_0_3")]
    pub fn gst_video_decoder_get_qos_proportion(decoder: *mut GstVideoDecoder) -> c_double;
    pub fn gst_video_decoder_have_frame(decoder: *mut GstVideoDecoder) -> gst::GstFlowReturn;
    pub fn gst_video_decoder_merge_tags(decoder: *mut GstVideoDecoder, tags: *const gst::GstTagList, mode: gst::GstTagMergeMode);
    pub fn gst_video_decoder_negotiate(decoder: *mut GstVideoDecoder) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_decoder_proxy_getcaps(decoder: *mut GstVideoDecoder, caps: *mut gst::GstCaps, filter: *mut gst::GstCaps) -> *mut gst::GstCaps;
    #[cfg(feature = "v1_2_2")]
    pub fn gst_video_decoder_release_frame(dec: *mut GstVideoDecoder, frame: *mut GstVideoCodecFrame);
    pub fn gst_video_decoder_set_estimate_rate(dec: *mut GstVideoDecoder, enabled: gboolean);
    pub fn gst_video_decoder_set_latency(decoder: *mut GstVideoDecoder, min_latency: gst::GstClockTime, max_latency: gst::GstClockTime);
    pub fn gst_video_decoder_set_max_errors(dec: *mut GstVideoDecoder, num: c_int);
    #[cfg(feature = "v1_4")]
    pub fn gst_video_decoder_set_needs_format(dec: *mut GstVideoDecoder, enabled: gboolean);
    pub fn gst_video_decoder_set_output_state(decoder: *mut GstVideoDecoder, fmt: GstVideoFormat, width: c_uint, height: c_uint, reference: *mut GstVideoCodecState) -> *mut GstVideoCodecState;
    pub fn gst_video_decoder_set_packetized(decoder: *mut GstVideoDecoder, packetized: gboolean);
    #[cfg(feature = "v1_6")]
    pub fn gst_video_decoder_set_use_default_pad_acceptcaps(decoder: *mut GstVideoDecoder, use_: gboolean);

    //=========================================================================
    // GstVideoEncoder
    //=========================================================================
    pub fn gst_video_encoder_get_type() -> GType;
    pub fn gst_video_encoder_allocate_output_buffer(encoder: *mut GstVideoEncoder, size: size_t) -> *mut gst::GstBuffer;
    pub fn gst_video_encoder_allocate_output_frame(encoder: *mut GstVideoEncoder, frame: *mut GstVideoCodecFrame, size: size_t) -> gst::GstFlowReturn;
    pub fn gst_video_encoder_finish_frame(encoder: *mut GstVideoEncoder, frame: *mut GstVideoCodecFrame) -> gst::GstFlowReturn;
    pub fn gst_video_encoder_get_allocator(encoder: *mut GstVideoEncoder, allocator: *mut *mut gst::GstAllocator, params: *mut gst::GstAllocationParams);
    pub fn gst_video_encoder_get_frame(encoder: *mut GstVideoEncoder, frame_number: c_int) -> *mut GstVideoCodecFrame;
    pub fn gst_video_encoder_get_frames(encoder: *mut GstVideoEncoder) -> *mut glib::GList;
    pub fn gst_video_encoder_get_latency(encoder: *mut GstVideoEncoder, min_latency: *mut gst::GstClockTime, max_latency: *mut gst::GstClockTime);
    pub fn gst_video_encoder_get_oldest_frame(encoder: *mut GstVideoEncoder) -> *mut GstVideoCodecFrame;
    pub fn gst_video_encoder_get_output_state(encoder: *mut GstVideoEncoder) -> *mut GstVideoCodecState;
    pub fn gst_video_encoder_merge_tags(encoder: *mut GstVideoEncoder, tags: *const gst::GstTagList, mode: gst::GstTagMergeMode);
    pub fn gst_video_encoder_negotiate(encoder: *mut GstVideoEncoder) -> gboolean;
    pub fn gst_video_encoder_proxy_getcaps(enc: *mut GstVideoEncoder, caps: *mut gst::GstCaps, filter: *mut gst::GstCaps) -> *mut gst::GstCaps;
    pub fn gst_video_encoder_set_headers(encoder: *mut GstVideoEncoder, headers: *mut glib::GList);
    pub fn gst_video_encoder_set_latency(encoder: *mut GstVideoEncoder, min_latency: gst::GstClockTime, max_latency: gst::GstClockTime);
    pub fn gst_video_encoder_set_min_pts(encoder: *mut GstVideoEncoder, min_pts: gst::GstClockTime);
    pub fn gst_video_encoder_set_output_state(encoder: *mut GstVideoEncoder, caps: *mut gst::GstCaps, reference: *mut GstVideoCodecState) -> *mut GstVideoCodecState;

    //=========================================================================
    // GstVideoFilter
    //=========================================================================
    pub fn gst_video_filter_get_type() -> GType;

    //=========================================================================
    // GstVideoMultiviewFlagsSet
    //=========================================================================
    pub fn gst_video_multiview_flagset_get_type() -> GType;

    //=========================================================================
    // GstVideoSink
    //=========================================================================
    pub fn gst_video_sink_get_type() -> GType;
    pub fn gst_video_sink_center_rect(src: GstVideoRectangle, dst: GstVideoRectangle, result: *mut GstVideoRectangle, scaling: gboolean);

    //=========================================================================
    // GstColorBalance
    //=========================================================================
    pub fn gst_color_balance_get_type() -> GType;
    pub fn gst_color_balance_get_balance_type(balance: *mut GstColorBalance) -> GstColorBalanceType;
    pub fn gst_color_balance_get_value(balance: *mut GstColorBalance, channel: *mut GstColorBalanceChannel) -> c_int;
    pub fn gst_color_balance_list_channels(balance: *mut GstColorBalance) -> *const glib::GList;
    pub fn gst_color_balance_set_value(balance: *mut GstColorBalance, channel: *mut GstColorBalanceChannel, value: c_int);
    pub fn gst_color_balance_value_changed(balance: *mut GstColorBalance, channel: *mut GstColorBalanceChannel, value: c_int);

    //=========================================================================
    // GstNavigation
    //=========================================================================
    pub fn gst_navigation_get_type() -> GType;
    pub fn gst_navigation_event_get_type(event: *mut gst::GstEvent) -> GstNavigationEventType;
    pub fn gst_navigation_event_parse_command(event: *mut gst::GstEvent, command: *mut GstNavigationCommand) -> gboolean;
    pub fn gst_navigation_event_parse_key_event(event: *mut gst::GstEvent, key: *mut *const c_char) -> gboolean;
    pub fn gst_navigation_event_parse_mouse_button_event(event: *mut gst::GstEvent, button: *mut c_int, x: *mut c_double, y: *mut c_double) -> gboolean;
    pub fn gst_navigation_event_parse_mouse_move_event(event: *mut gst::GstEvent, x: *mut c_double, y: *mut c_double) -> gboolean;
    pub fn gst_navigation_message_get_type(message: *mut gst::GstMessage) -> GstNavigationMessageType;
    pub fn gst_navigation_message_new_angles_changed(src: *mut gst::GstObject, cur_angle: c_uint, n_angles: c_uint) -> *mut gst::GstMessage;
    pub fn gst_navigation_message_new_commands_changed(src: *mut gst::GstObject) -> *mut gst::GstMessage;
    #[cfg(feature = "v1_6")]
    pub fn gst_navigation_message_new_event(src: *mut gst::GstObject, event: *mut gst::GstEvent) -> *mut gst::GstMessage;
    pub fn gst_navigation_message_new_mouse_over(src: *mut gst::GstObject, active: gboolean) -> *mut gst::GstMessage;
    pub fn gst_navigation_message_parse_angles_changed(message: *mut gst::GstMessage, cur_angle: *mut c_uint, n_angles: *mut c_uint) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_navigation_message_parse_event(message: *mut gst::GstMessage, event: *mut *mut gst::GstEvent) -> gboolean;
    pub fn gst_navigation_message_parse_mouse_over(message: *mut gst::GstMessage, active: *mut gboolean) -> gboolean;
    pub fn gst_navigation_query_get_type(query: *mut gst::GstQuery) -> GstNavigationQueryType;
    pub fn gst_navigation_query_new_angles() -> *mut gst::GstQuery;
    pub fn gst_navigation_query_new_commands() -> *mut gst::GstQuery;
    pub fn gst_navigation_query_parse_angles(query: *mut gst::GstQuery, cur_angle: *mut c_uint, n_angles: *mut c_uint) -> gboolean;
    pub fn gst_navigation_query_parse_commands_length(query: *mut gst::GstQuery, n_cmds: *mut c_uint) -> gboolean;
    pub fn gst_navigation_query_parse_commands_nth(query: *mut gst::GstQuery, nth: c_uint, cmd: *mut GstNavigationCommand) -> gboolean;
    pub fn gst_navigation_query_set_angles(query: *mut gst::GstQuery, cur_angle: c_uint, n_angles: c_uint);
    pub fn gst_navigation_query_set_commands(query: *mut gst::GstQuery, n_cmds: c_int, ...);
    pub fn gst_navigation_query_set_commandsv(query: *mut gst::GstQuery, n_cmds: c_int, cmds: *mut GstNavigationCommand);
    pub fn gst_navigation_send_command(navigation: *mut GstNavigation, command: GstNavigationCommand);
    pub fn gst_navigation_send_event(navigation: *mut GstNavigation, structure: *mut gst::GstStructure);
    pub fn gst_navigation_send_key_event(navigation: *mut GstNavigation, event: *const c_char, key: *const c_char);
    pub fn gst_navigation_send_mouse_event(navigation: *mut GstNavigation, event: *const c_char, button: c_int, x: c_double, y: c_double);

    //=========================================================================
    // GstVideoDirection
    //=========================================================================
    pub fn gst_video_direction_get_type() -> GType;

    //=========================================================================
    // GstVideoOrientation
    //=========================================================================
    pub fn gst_video_orientation_get_type() -> GType;
    pub fn gst_video_orientation_get_hcenter(video_orientation: *mut GstVideoOrientation, center: *mut c_int) -> gboolean;
    pub fn gst_video_orientation_get_hflip(video_orientation: *mut GstVideoOrientation, flip: *mut gboolean) -> gboolean;
    pub fn gst_video_orientation_get_vcenter(video_orientation: *mut GstVideoOrientation, center: *mut c_int) -> gboolean;
    pub fn gst_video_orientation_get_vflip(video_orientation: *mut GstVideoOrientation, flip: *mut gboolean) -> gboolean;
    pub fn gst_video_orientation_set_hcenter(video_orientation: *mut GstVideoOrientation, center: c_int) -> gboolean;
    pub fn gst_video_orientation_set_hflip(video_orientation: *mut GstVideoOrientation, flip: gboolean) -> gboolean;
    pub fn gst_video_orientation_set_vcenter(video_orientation: *mut GstVideoOrientation, center: c_int) -> gboolean;
    pub fn gst_video_orientation_set_vflip(video_orientation: *mut GstVideoOrientation, flip: gboolean) -> gboolean;

    //=========================================================================
    // GstVideoOverlay
    //=========================================================================
    pub fn gst_video_overlay_get_type() -> GType;
    pub fn gst_video_overlay_expose(overlay: *mut GstVideoOverlay);
    pub fn gst_video_overlay_got_window_handle(overlay: *mut GstVideoOverlay, handle: uintptr_t);
    pub fn gst_video_overlay_handle_events(overlay: *mut GstVideoOverlay, handle_events: gboolean);
    pub fn gst_video_overlay_prepare_window_handle(overlay: *mut GstVideoOverlay);
    pub fn gst_video_overlay_set_render_rectangle(overlay: *mut GstVideoOverlay, x: c_int, y: c_int, width: c_int, height: c_int) -> gboolean;
    pub fn gst_video_overlay_set_window_handle(overlay: *mut GstVideoOverlay, handle: uintptr_t);

    //=========================================================================
    // Other functions
    //=========================================================================
    #[cfg(feature = "v1_8")]
    pub fn gst_buffer_add_video_affine_transformation_meta(buffer: *mut gst::GstBuffer) -> *mut GstVideoAffineTransformationMeta;
    pub fn gst_buffer_add_video_gl_texture_upload_meta(buffer: *mut gst::GstBuffer, texture_orientation: GstVideoGLTextureOrientation, n_textures: c_uint, texture_type: GstVideoGLTextureType, upload: GstVideoGLTextureUpload, user_data: gpointer, user_data_copy: gobject::GBoxedCopyFunc, user_data_free: gobject::GBoxedFreeFunc) -> *mut GstVideoGLTextureUploadMeta;
    pub fn gst_buffer_add_video_meta(buffer: *mut gst::GstBuffer, flags: GstVideoFrameFlags, format: GstVideoFormat, width: c_uint, height: c_uint) -> *mut GstVideoMeta;
    pub fn gst_buffer_add_video_meta_full(buffer: *mut gst::GstBuffer, flags: GstVideoFrameFlags, format: GstVideoFormat, width: c_uint, height: c_uint, n_planes: c_uint, offset: size_t, stride: c_int) -> *mut GstVideoMeta;
    pub fn gst_buffer_add_video_overlay_composition_meta(buf: *mut gst::GstBuffer, comp: *mut GstVideoOverlayComposition) -> *mut GstVideoOverlayCompositionMeta;
    pub fn gst_buffer_add_video_region_of_interest_meta(buffer: *mut gst::GstBuffer, roi_type: *const c_char, x: c_uint, y: c_uint, w: c_uint, h: c_uint) -> *mut GstVideoRegionOfInterestMeta;
    pub fn gst_buffer_add_video_region_of_interest_meta_id(buffer: *mut gst::GstBuffer, roi_type: glib::GQuark, x: c_uint, y: c_uint, w: c_uint, h: c_uint) -> *mut GstVideoRegionOfInterestMeta;
    #[cfg(feature = "v1_10")]
    pub fn gst_buffer_add_video_time_code_meta(buffer: *mut gst::GstBuffer, tc: *mut GstVideoTimeCode) -> *mut GstVideoTimeCodeMeta;
    #[cfg(feature = "v1_10")]
    pub fn gst_buffer_add_video_time_code_meta_full(buffer: *mut gst::GstBuffer, fps_n: c_uint, fps_d: c_uint, latest_daily_jam: *mut glib::GDateTime, flags: GstVideoTimeCodeFlags, hours: c_uint, minutes: c_uint, seconds: c_uint, frames: c_uint, field_count: c_uint) -> *mut GstVideoTimeCodeMeta;
    pub fn gst_buffer_get_video_meta(buffer: *mut gst::GstBuffer) -> *mut GstVideoMeta;
    pub fn gst_buffer_get_video_meta_id(buffer: *mut gst::GstBuffer, id: c_int) -> *mut GstVideoMeta;
    pub fn gst_buffer_get_video_region_of_interest_meta_id(buffer: *mut gst::GstBuffer, id: c_int) -> *mut GstVideoRegionOfInterestMeta;
    pub fn gst_buffer_pool_config_get_video_alignment(config: *mut gst::GstStructure, align: *mut GstVideoAlignment) -> gboolean;
    pub fn gst_buffer_pool_config_set_video_alignment(config: *mut gst::GstStructure, align: *mut GstVideoAlignment);
    pub fn gst_is_video_overlay_prepare_window_handle_message(msg: *mut gst::GstMessage) -> gboolean;
    pub fn gst_video_affine_transformation_meta_api_get_type() -> GType;
    pub fn gst_video_blend(dest: *mut GstVideoFrame, src: *mut GstVideoFrame, x: c_int, y: c_int, global_alpha: c_float) -> gboolean;
    pub fn gst_video_blend_scale_linear_RGBA(src: *mut GstVideoInfo, src_buffer: *mut gst::GstBuffer, dest_height: c_int, dest_width: c_int, dest: *mut GstVideoInfo, dest_buffer: *mut *mut gst::GstBuffer);
    pub fn gst_video_calculate_display_ratio(dar_n: *mut c_uint, dar_d: *mut c_uint, video_width: c_uint, video_height: c_uint, video_par_n: c_uint, video_par_d: c_uint, display_par_n: c_uint, display_par_d: c_uint) -> gboolean;
    pub fn gst_video_chroma_from_string(s: *const c_char) -> GstVideoChromaSite;
    pub fn gst_video_chroma_resample(resample: *mut GstVideoChromaResample, lines: gpointer, width: c_int);
    pub fn gst_video_chroma_to_string(site: GstVideoChromaSite) -> *const c_char;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_color_transfer_decode(func: GstVideoTransferFunction, val: c_double) -> c_double;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_color_transfer_encode(func: GstVideoTransferFunction, val: c_double) -> c_double;
    pub fn gst_video_convert_sample(sample: *mut gst::GstSample, to_caps: *const gst::GstCaps, timeout: gst::GstClockTime, error: *mut *mut glib::GError) -> *mut gst::GstSample;
    pub fn gst_video_convert_sample_async(sample: *mut gst::GstSample, to_caps: *const gst::GstCaps, timeout: gst::GstClockTime, callback: GstVideoConvertSampleCallback, user_data: gpointer, destroy_notify: glib::GDestroyNotify);
    pub fn gst_video_crop_meta_api_get_type() -> GType;
    pub fn gst_video_event_is_force_key_unit(event: *mut gst::GstEvent) -> gboolean;
    pub fn gst_video_event_new_downstream_force_key_unit(timestamp: gst::GstClockTime, stream_time: gst::GstClockTime, running_time: gst::GstClockTime, all_headers: gboolean, count: c_uint) -> *mut gst::GstEvent;
    pub fn gst_video_event_new_still_frame(in_still: gboolean) -> *mut gst::GstEvent;
    pub fn gst_video_event_new_upstream_force_key_unit(running_time: gst::GstClockTime, all_headers: gboolean, count: c_uint) -> *mut gst::GstEvent;
    pub fn gst_video_event_parse_downstream_force_key_unit(event: *mut gst::GstEvent, timestamp: *mut gst::GstClockTime, stream_time: *mut gst::GstClockTime, running_time: *mut gst::GstClockTime, all_headers: *mut gboolean, count: *mut c_uint) -> gboolean;
    pub fn gst_video_event_parse_still_frame(event: *mut gst::GstEvent, in_still: *mut gboolean) -> gboolean;
    pub fn gst_video_event_parse_upstream_force_key_unit(event: *mut gst::GstEvent, running_time: *mut gst::GstClockTime, all_headers: *mut gboolean, count: *mut c_uint) -> gboolean;
    pub fn gst_video_gl_texture_upload_meta_api_get_type() -> GType;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_guess_framerate(duration: gst::GstClockTime, dest_n: *mut c_int, dest_d: *mut c_int) -> gboolean;
    pub fn gst_video_meta_api_get_type() -> GType;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_multiview_get_doubled_height_modes() -> *const gobject::GValue;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_multiview_get_doubled_size_modes() -> *const gobject::GValue;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_multiview_get_doubled_width_modes() -> *const gobject::GValue;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_multiview_get_mono_modes() -> *const gobject::GValue;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_multiview_get_unpacked_modes() -> *const gobject::GValue;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_multiview_guess_half_aspect(mv_mode: GstVideoMultiviewMode, width: c_uint, height: c_uint, par_n: c_uint, par_d: c_uint) -> gboolean;
    #[cfg(feature = "v1_6")]
    pub fn gst_video_multiview_video_info_change_mode(info: *mut GstVideoInfo, out_mview_mode: GstVideoMultiviewMode, out_mview_flags: GstVideoMultiviewFlags);
    pub fn gst_video_overlay_composition_meta_api_get_type() -> GType;
    pub fn gst_video_region_of_interest_meta_api_get_type() -> GType;
    #[cfg(feature = "v1_4")]
    pub fn gst_video_tile_get_index(mode: GstVideoTileMode, x: c_int, y: c_int, x_tiles: c_int, y_tiles: c_int) -> c_uint;
    pub fn gst_video_time_code_meta_api_get_type() -> GType;

}
