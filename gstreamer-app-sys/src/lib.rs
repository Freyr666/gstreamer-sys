// This file was generated by gir (038b513) from gir-files (???)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals)]

extern crate libc;
#[macro_use] extern crate bitflags;
extern crate glib_sys as glib;
extern crate gobject_sys as gobject;
extern crate gstreamer_sys as gst;
extern crate gstreamer_base_sys as gst_base;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType, Volatile};

// Enums
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum GstAppStreamType {
    Stream = 0,
    Seekable = 1,
    RandomAccess = 2,
}
pub const GST_APP_STREAM_TYPE_STREAM: GstAppStreamType = GstAppStreamType::Stream;
pub const GST_APP_STREAM_TYPE_SEEKABLE: GstAppStreamType = GstAppStreamType::Seekable;
pub const GST_APP_STREAM_TYPE_RANDOM_ACCESS: GstAppStreamType = GstAppStreamType::RandomAccess;

// Records
#[repr(C)]
pub struct GstAppSinkCallbacks {
    pub eos: Option<unsafe extern "C" fn(*mut GstAppSink, gpointer)>,
    pub new_preroll: Option<unsafe extern "C" fn(*mut GstAppSink, gpointer) -> gst::GstFlowReturn>,
    pub new_sample: Option<unsafe extern "C" fn(*mut GstAppSink, gpointer) -> gst::GstFlowReturn>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAppSinkClass {
    pub basesink_class: gst_base::GstBaseSinkClass,
    pub eos: Option<unsafe extern "C" fn(*mut GstAppSink)>,
    pub new_preroll: Option<unsafe extern "C" fn(*mut GstAppSink) -> gst::GstFlowReturn>,
    pub new_sample: Option<unsafe extern "C" fn(*mut GstAppSink) -> gst::GstFlowReturn>,
    pub pull_preroll: Option<unsafe extern "C" fn(*mut GstAppSink) -> *mut gst::GstSample>,
    pub pull_sample: Option<unsafe extern "C" fn(*mut GstAppSink) -> *mut gst::GstSample>,
    pub try_pull_preroll: Option<unsafe extern "C" fn(*mut GstAppSink, gst::GstClockTime) -> *mut gst::GstSample>,
    pub try_pull_sample: Option<unsafe extern "C" fn(*mut GstAppSink, gst::GstClockTime) -> *mut gst::GstSample>,
    pub _gst_reserved: [gpointer; 2],
}

#[repr(C)]
pub struct GstAppSinkPrivate(c_void);

#[repr(C)]
pub struct GstAppSrcCallbacks {
    pub need_data: Option<unsafe extern "C" fn(*mut GstAppSrc, c_uint, gpointer)>,
    pub enough_data: Option<unsafe extern "C" fn(*mut GstAppSrc, gpointer)>,
    pub seek_data: Option<unsafe extern "C" fn(*mut GstAppSrc, u64, gpointer) -> gboolean>,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAppSrcClass {
    pub basesrc_class: gst_base::GstBaseSrcClass,
    pub need_data: Option<unsafe extern "C" fn(*mut GstAppSrc, c_uint)>,
    pub enough_data: Option<unsafe extern "C" fn(*mut GstAppSrc)>,
    pub seek_data: Option<unsafe extern "C" fn(*mut GstAppSrc, u64) -> gboolean>,
    pub push_buffer: Option<unsafe extern "C" fn(*mut GstAppSrc, *mut gst::GstBuffer) -> gst::GstFlowReturn>,
    pub end_of_stream: Option<unsafe extern "C" fn(*mut GstAppSrc) -> gst::GstFlowReturn>,
    pub push_sample: Option<unsafe extern "C" fn(*mut GstAppSrc, *mut gst::GstSample) -> gst::GstFlowReturn>,
    pub _gst_reserved: [gpointer; 3],
}

#[repr(C)]
pub struct GstAppSrcPrivate(c_void);

// Classes
#[repr(C)]
pub struct GstAppSink {
    pub basesink: gst_base::GstBaseSink,
    pub priv_: *mut GstAppSinkPrivate,
    pub _gst_reserved: [gpointer; 4],
}

#[repr(C)]
pub struct GstAppSrc {
    pub basesrc: gst_base::GstBaseSrc,
    pub priv_: *mut GstAppSrcPrivate,
    pub _gst_reserved: [gpointer; 4],
}

extern "C" {

    //=========================================================================
    // GstAppSink
    //=========================================================================
    pub fn gst_app_sink_get_type() -> GType;
    #[cfg(feature = "v1_12")]
    pub fn gst_app_sink_get_buffer_list_support(appsink: *mut GstAppSink) -> gboolean;
    pub fn gst_app_sink_get_caps(appsink: *mut GstAppSink) -> *mut gst::GstCaps;
    pub fn gst_app_sink_get_drop(appsink: *mut GstAppSink) -> gboolean;
    pub fn gst_app_sink_get_emit_signals(appsink: *mut GstAppSink) -> gboolean;
    pub fn gst_app_sink_get_max_buffers(appsink: *mut GstAppSink) -> c_uint;
    pub fn gst_app_sink_get_wait_on_eos(appsink: *mut GstAppSink) -> gboolean;
    pub fn gst_app_sink_is_eos(appsink: *mut GstAppSink) -> gboolean;
    pub fn gst_app_sink_pull_preroll(appsink: *mut GstAppSink) -> *mut gst::GstSample;
    pub fn gst_app_sink_pull_sample(appsink: *mut GstAppSink) -> *mut gst::GstSample;
    #[cfg(feature = "v1_12")]
    pub fn gst_app_sink_set_buffer_list_support(appsink: *mut GstAppSink, enable_lists: gboolean);
    pub fn gst_app_sink_set_callbacks(appsink: *mut GstAppSink, callbacks: *mut GstAppSinkCallbacks, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_app_sink_set_caps(appsink: *mut GstAppSink, caps: *const gst::GstCaps);
    pub fn gst_app_sink_set_drop(appsink: *mut GstAppSink, drop: gboolean);
    pub fn gst_app_sink_set_emit_signals(appsink: *mut GstAppSink, emit: gboolean);
    pub fn gst_app_sink_set_max_buffers(appsink: *mut GstAppSink, max: c_uint);
    pub fn gst_app_sink_set_wait_on_eos(appsink: *mut GstAppSink, wait: gboolean);
    #[cfg(feature = "v1_10")]
    pub fn gst_app_sink_try_pull_preroll(appsink: *mut GstAppSink, timeout: gst::GstClockTime) -> *mut gst::GstSample;
    #[cfg(feature = "v1_10")]
    pub fn gst_app_sink_try_pull_sample(appsink: *mut GstAppSink, timeout: gst::GstClockTime) -> *mut gst::GstSample;

    //=========================================================================
    // GstAppSrc
    //=========================================================================
    pub fn gst_app_src_get_type() -> GType;
    pub fn gst_app_src_end_of_stream(appsrc: *mut GstAppSrc) -> gst::GstFlowReturn;
    pub fn gst_app_src_get_caps(appsrc: *mut GstAppSrc) -> *mut gst::GstCaps;
    #[cfg(feature = "v1_2")]
    pub fn gst_app_src_get_current_level_bytes(appsrc: *mut GstAppSrc) -> u64;
    #[cfg(feature = "v1_10")]
    pub fn gst_app_src_get_duration(appsrc: *mut GstAppSrc) -> gst::GstClockTime;
    pub fn gst_app_src_get_emit_signals(appsrc: *mut GstAppSrc) -> gboolean;
    pub fn gst_app_src_get_latency(appsrc: *mut GstAppSrc, min: *mut u64, max: *mut u64);
    pub fn gst_app_src_get_max_bytes(appsrc: *mut GstAppSrc) -> u64;
    pub fn gst_app_src_get_size(appsrc: *mut GstAppSrc) -> i64;
    pub fn gst_app_src_get_stream_type(appsrc: *mut GstAppSrc) -> GstAppStreamType;
    pub fn gst_app_src_push_buffer(appsrc: *mut GstAppSrc, buffer: *mut gst::GstBuffer) -> gst::GstFlowReturn;
    #[cfg(feature = "v1_6")]
    pub fn gst_app_src_push_sample(appsrc: *mut GstAppSrc, sample: *mut gst::GstSample) -> gst::GstFlowReturn;
    pub fn gst_app_src_set_callbacks(appsrc: *mut GstAppSrc, callbacks: *mut GstAppSrcCallbacks, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_app_src_set_caps(appsrc: *mut GstAppSrc, caps: *const gst::GstCaps);
    #[cfg(feature = "v1_10")]
    pub fn gst_app_src_set_duration(appsrc: *mut GstAppSrc, duration: gst::GstClockTime);
    pub fn gst_app_src_set_emit_signals(appsrc: *mut GstAppSrc, emit: gboolean);
    pub fn gst_app_src_set_latency(appsrc: *mut GstAppSrc, min: u64, max: u64);
    pub fn gst_app_src_set_max_bytes(appsrc: *mut GstAppSrc, max: u64);
    pub fn gst_app_src_set_size(appsrc: *mut GstAppSrc, size: i64);
    pub fn gst_app_src_set_stream_type(appsrc: *mut GstAppSrc, type_: GstAppStreamType);

}
